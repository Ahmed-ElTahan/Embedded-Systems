
36_TIMER0_Overflow_Interrupt_Signal2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000007fc  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000002  00800060  00800060  00000870  2**0
                  ALLOC
  2 .stab         000009d8  00000000  00000000  00000870  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000890  00000000  00000000  00001248  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 a1 03 	jmp	0x742	; 0x742 <__vector_11>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a2 36       	cpi	r26, 0x62	; 98
  6c:	b1 07       	cpc	r27, r17
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 63 03 	call	0x6c6	; 0x6c6 <main>
  74:	0c 94 fc 03 	jmp	0x7f8	; 0x7f8 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <SetPinDirection>:
*/
#include"DDIO.h" // This header file includes the appropriate IO definitions for the device that has been specified by the -MCU= compiler command-line switch.

// Function (1):  to set the pin number (0 to 31) direction as Input(floating)/Output/Input(pull up)
void SetPinDirection(u8 PinNumber, u8 PinDirection)
{
  7c:	df 93       	push	r29
  7e:	cf 93       	push	r28
  80:	00 d0       	rcall	.+0      	; 0x82 <SetPinDirection+0x6>
  82:	0f 92       	push	r0
  84:	cd b7       	in	r28, 0x3d	; 61
  86:	de b7       	in	r29, 0x3e	; 62
  88:	8a 83       	std	Y+2, r24	; 0x02
  8a:	6b 83       	std	Y+3, r22	; 0x03
	u8 PortLetter = PinNumber/NUM; // to get the Port letter (0 for A, 1 for B, 2 for C, 3 for D)
  8c:	8a 81       	ldd	r24, Y+2	; 0x02
  8e:	86 95       	lsr	r24
  90:	86 95       	lsr	r24
  92:	86 95       	lsr	r24
  94:	89 83       	std	Y+1, r24	; 0x01
	// PinNumber%NUM gives the number of the pin in the port from 0 to 7

	// 0 for port A
		if (PortLetter == PortA_Letter)
  96:	89 81       	ldd	r24, Y+1	; 0x01
  98:	88 23       	and	r24, r24
  9a:	09 f0       	breq	.+2      	; 0x9e <SetPinDirection+0x22>
  9c:	66 c0       	rjmp	.+204    	; 0x16a <SetPinDirection+0xee>
		{
			//DDRA
			if (PinDirection == INPUT) // Input (floating)
  9e:	8b 81       	ldd	r24, Y+3	; 0x03
  a0:	88 23       	and	r24, r24
  a2:	c1 f4       	brne	.+48     	; 0xd4 <SetPinDirection+0x58>
			{
				CLR_BIT(DDRA, PinNumber%NUM);
  a4:	aa e3       	ldi	r26, 0x3A	; 58
  a6:	b0 e0       	ldi	r27, 0x00	; 0
  a8:	ea e3       	ldi	r30, 0x3A	; 58
  aa:	f0 e0       	ldi	r31, 0x00	; 0
  ac:	80 81       	ld	r24, Z
  ae:	48 2f       	mov	r20, r24
  b0:	8a 81       	ldd	r24, Y+2	; 0x02
  b2:	88 2f       	mov	r24, r24
  b4:	90 e0       	ldi	r25, 0x00	; 0
  b6:	9c 01       	movw	r18, r24
  b8:	27 70       	andi	r18, 0x07	; 7
  ba:	30 70       	andi	r19, 0x00	; 0
  bc:	81 e0       	ldi	r24, 0x01	; 1
  be:	90 e0       	ldi	r25, 0x00	; 0
  c0:	02 2e       	mov	r0, r18
  c2:	02 c0       	rjmp	.+4      	; 0xc8 <SetPinDirection+0x4c>
  c4:	88 0f       	add	r24, r24
  c6:	99 1f       	adc	r25, r25
  c8:	0a 94       	dec	r0
  ca:	e2 f7       	brpl	.-8      	; 0xc4 <SetPinDirection+0x48>
  cc:	80 95       	com	r24
  ce:	84 23       	and	r24, r20
  d0:	8c 93       	st	X, r24
  d2:	87 c1       	rjmp	.+782    	; 0x3e2 <SetPinDirection+0x366>
			}
			else if (PinDirection == OUTPUT) // Output
  d4:	8b 81       	ldd	r24, Y+3	; 0x03
  d6:	81 30       	cpi	r24, 0x01	; 1
  d8:	b9 f4       	brne	.+46     	; 0x108 <SetPinDirection+0x8c>
			{
				SET_BIT(DDRA, PinNumber%NUM);
  da:	aa e3       	ldi	r26, 0x3A	; 58
  dc:	b0 e0       	ldi	r27, 0x00	; 0
  de:	ea e3       	ldi	r30, 0x3A	; 58
  e0:	f0 e0       	ldi	r31, 0x00	; 0
  e2:	80 81       	ld	r24, Z
  e4:	48 2f       	mov	r20, r24
  e6:	8a 81       	ldd	r24, Y+2	; 0x02
  e8:	88 2f       	mov	r24, r24
  ea:	90 e0       	ldi	r25, 0x00	; 0
  ec:	9c 01       	movw	r18, r24
  ee:	27 70       	andi	r18, 0x07	; 7
  f0:	30 70       	andi	r19, 0x00	; 0
  f2:	81 e0       	ldi	r24, 0x01	; 1
  f4:	90 e0       	ldi	r25, 0x00	; 0
  f6:	02 2e       	mov	r0, r18
  f8:	02 c0       	rjmp	.+4      	; 0xfe <SetPinDirection+0x82>
  fa:	88 0f       	add	r24, r24
  fc:	99 1f       	adc	r25, r25
  fe:	0a 94       	dec	r0
 100:	e2 f7       	brpl	.-8      	; 0xfa <SetPinDirection+0x7e>
 102:	84 2b       	or	r24, r20
 104:	8c 93       	st	X, r24
 106:	6d c1       	rjmp	.+730    	; 0x3e2 <SetPinDirection+0x366>
			}
			else if (PinDirection == INPUT_PU)
 108:	8b 81       	ldd	r24, Y+3	; 0x03
 10a:	82 30       	cpi	r24, 0x02	; 2
 10c:	09 f0       	breq	.+2      	; 0x110 <SetPinDirection+0x94>
 10e:	69 c1       	rjmp	.+722    	; 0x3e2 <SetPinDirection+0x366>
			{
				CLR_BIT(DDRA, PinNumber%NUM); // define as input
 110:	aa e3       	ldi	r26, 0x3A	; 58
 112:	b0 e0       	ldi	r27, 0x00	; 0
 114:	ea e3       	ldi	r30, 0x3A	; 58
 116:	f0 e0       	ldi	r31, 0x00	; 0
 118:	80 81       	ld	r24, Z
 11a:	48 2f       	mov	r20, r24
 11c:	8a 81       	ldd	r24, Y+2	; 0x02
 11e:	88 2f       	mov	r24, r24
 120:	90 e0       	ldi	r25, 0x00	; 0
 122:	9c 01       	movw	r18, r24
 124:	27 70       	andi	r18, 0x07	; 7
 126:	30 70       	andi	r19, 0x00	; 0
 128:	81 e0       	ldi	r24, 0x01	; 1
 12a:	90 e0       	ldi	r25, 0x00	; 0
 12c:	02 c0       	rjmp	.+4      	; 0x132 <SetPinDirection+0xb6>
 12e:	88 0f       	add	r24, r24
 130:	99 1f       	adc	r25, r25
 132:	2a 95       	dec	r18
 134:	e2 f7       	brpl	.-8      	; 0x12e <SetPinDirection+0xb2>
 136:	80 95       	com	r24
 138:	84 23       	and	r24, r20
 13a:	8c 93       	st	X, r24
				SET_BIT(PORTA, PinNumber%NUM); // write high to be Input (pull up)
 13c:	ab e3       	ldi	r26, 0x3B	; 59
 13e:	b0 e0       	ldi	r27, 0x00	; 0
 140:	eb e3       	ldi	r30, 0x3B	; 59
 142:	f0 e0       	ldi	r31, 0x00	; 0
 144:	80 81       	ld	r24, Z
 146:	48 2f       	mov	r20, r24
 148:	8a 81       	ldd	r24, Y+2	; 0x02
 14a:	88 2f       	mov	r24, r24
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	9c 01       	movw	r18, r24
 150:	27 70       	andi	r18, 0x07	; 7
 152:	30 70       	andi	r19, 0x00	; 0
 154:	81 e0       	ldi	r24, 0x01	; 1
 156:	90 e0       	ldi	r25, 0x00	; 0
 158:	02 2e       	mov	r0, r18
 15a:	02 c0       	rjmp	.+4      	; 0x160 <SetPinDirection+0xe4>
 15c:	88 0f       	add	r24, r24
 15e:	99 1f       	adc	r25, r25
 160:	0a 94       	dec	r0
 162:	e2 f7       	brpl	.-8      	; 0x15c <SetPinDirection+0xe0>
 164:	84 2b       	or	r24, r20
 166:	8c 93       	st	X, r24
 168:	3c c1       	rjmp	.+632    	; 0x3e2 <SetPinDirection+0x366>
			}
		}

	// 1 for port B
		else if (PortLetter == PortB_Letter)
 16a:	89 81       	ldd	r24, Y+1	; 0x01
 16c:	81 30       	cpi	r24, 0x01	; 1
 16e:	09 f0       	breq	.+2      	; 0x172 <SetPinDirection+0xf6>
 170:	66 c0       	rjmp	.+204    	; 0x23e <SetPinDirection+0x1c2>
		{
			//DDRB
			if (PinDirection == INPUT) // Input (floating)
 172:	8b 81       	ldd	r24, Y+3	; 0x03
 174:	88 23       	and	r24, r24
 176:	c1 f4       	brne	.+48     	; 0x1a8 <SetPinDirection+0x12c>
			{
				CLR_BIT(DDRB, PinNumber%NUM);
 178:	a7 e3       	ldi	r26, 0x37	; 55
 17a:	b0 e0       	ldi	r27, 0x00	; 0
 17c:	e7 e3       	ldi	r30, 0x37	; 55
 17e:	f0 e0       	ldi	r31, 0x00	; 0
 180:	80 81       	ld	r24, Z
 182:	48 2f       	mov	r20, r24
 184:	8a 81       	ldd	r24, Y+2	; 0x02
 186:	88 2f       	mov	r24, r24
 188:	90 e0       	ldi	r25, 0x00	; 0
 18a:	9c 01       	movw	r18, r24
 18c:	27 70       	andi	r18, 0x07	; 7
 18e:	30 70       	andi	r19, 0x00	; 0
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	02 2e       	mov	r0, r18
 196:	02 c0       	rjmp	.+4      	; 0x19c <SetPinDirection+0x120>
 198:	88 0f       	add	r24, r24
 19a:	99 1f       	adc	r25, r25
 19c:	0a 94       	dec	r0
 19e:	e2 f7       	brpl	.-8      	; 0x198 <SetPinDirection+0x11c>
 1a0:	80 95       	com	r24
 1a2:	84 23       	and	r24, r20
 1a4:	8c 93       	st	X, r24
 1a6:	1d c1       	rjmp	.+570    	; 0x3e2 <SetPinDirection+0x366>
			}
			else if (PinDirection == OUTPUT) // Output
 1a8:	8b 81       	ldd	r24, Y+3	; 0x03
 1aa:	81 30       	cpi	r24, 0x01	; 1
 1ac:	b9 f4       	brne	.+46     	; 0x1dc <SetPinDirection+0x160>
			{
				SET_BIT(DDRB, PinNumber%NUM);
 1ae:	a7 e3       	ldi	r26, 0x37	; 55
 1b0:	b0 e0       	ldi	r27, 0x00	; 0
 1b2:	e7 e3       	ldi	r30, 0x37	; 55
 1b4:	f0 e0       	ldi	r31, 0x00	; 0
 1b6:	80 81       	ld	r24, Z
 1b8:	48 2f       	mov	r20, r24
 1ba:	8a 81       	ldd	r24, Y+2	; 0x02
 1bc:	88 2f       	mov	r24, r24
 1be:	90 e0       	ldi	r25, 0x00	; 0
 1c0:	9c 01       	movw	r18, r24
 1c2:	27 70       	andi	r18, 0x07	; 7
 1c4:	30 70       	andi	r19, 0x00	; 0
 1c6:	81 e0       	ldi	r24, 0x01	; 1
 1c8:	90 e0       	ldi	r25, 0x00	; 0
 1ca:	02 2e       	mov	r0, r18
 1cc:	02 c0       	rjmp	.+4      	; 0x1d2 <SetPinDirection+0x156>
 1ce:	88 0f       	add	r24, r24
 1d0:	99 1f       	adc	r25, r25
 1d2:	0a 94       	dec	r0
 1d4:	e2 f7       	brpl	.-8      	; 0x1ce <SetPinDirection+0x152>
 1d6:	84 2b       	or	r24, r20
 1d8:	8c 93       	st	X, r24
 1da:	03 c1       	rjmp	.+518    	; 0x3e2 <SetPinDirection+0x366>
			}
			else if (PinDirection == INPUT_PU)
 1dc:	8b 81       	ldd	r24, Y+3	; 0x03
 1de:	82 30       	cpi	r24, 0x02	; 2
 1e0:	09 f0       	breq	.+2      	; 0x1e4 <SetPinDirection+0x168>
 1e2:	ff c0       	rjmp	.+510    	; 0x3e2 <SetPinDirection+0x366>
			{
				CLR_BIT(DDRB, PinNumber%NUM); // define as input
 1e4:	a7 e3       	ldi	r26, 0x37	; 55
 1e6:	b0 e0       	ldi	r27, 0x00	; 0
 1e8:	e7 e3       	ldi	r30, 0x37	; 55
 1ea:	f0 e0       	ldi	r31, 0x00	; 0
 1ec:	80 81       	ld	r24, Z
 1ee:	48 2f       	mov	r20, r24
 1f0:	8a 81       	ldd	r24, Y+2	; 0x02
 1f2:	88 2f       	mov	r24, r24
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	9c 01       	movw	r18, r24
 1f8:	27 70       	andi	r18, 0x07	; 7
 1fa:	30 70       	andi	r19, 0x00	; 0
 1fc:	81 e0       	ldi	r24, 0x01	; 1
 1fe:	90 e0       	ldi	r25, 0x00	; 0
 200:	02 c0       	rjmp	.+4      	; 0x206 <SetPinDirection+0x18a>
 202:	88 0f       	add	r24, r24
 204:	99 1f       	adc	r25, r25
 206:	2a 95       	dec	r18
 208:	e2 f7       	brpl	.-8      	; 0x202 <SetPinDirection+0x186>
 20a:	80 95       	com	r24
 20c:	84 23       	and	r24, r20
 20e:	8c 93       	st	X, r24
				SET_BIT(PORTB, PinNumber%NUM); // write high to be Input (pull up)
 210:	a8 e3       	ldi	r26, 0x38	; 56
 212:	b0 e0       	ldi	r27, 0x00	; 0
 214:	e8 e3       	ldi	r30, 0x38	; 56
 216:	f0 e0       	ldi	r31, 0x00	; 0
 218:	80 81       	ld	r24, Z
 21a:	48 2f       	mov	r20, r24
 21c:	8a 81       	ldd	r24, Y+2	; 0x02
 21e:	88 2f       	mov	r24, r24
 220:	90 e0       	ldi	r25, 0x00	; 0
 222:	9c 01       	movw	r18, r24
 224:	27 70       	andi	r18, 0x07	; 7
 226:	30 70       	andi	r19, 0x00	; 0
 228:	81 e0       	ldi	r24, 0x01	; 1
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	02 2e       	mov	r0, r18
 22e:	02 c0       	rjmp	.+4      	; 0x234 <SetPinDirection+0x1b8>
 230:	88 0f       	add	r24, r24
 232:	99 1f       	adc	r25, r25
 234:	0a 94       	dec	r0
 236:	e2 f7       	brpl	.-8      	; 0x230 <SetPinDirection+0x1b4>
 238:	84 2b       	or	r24, r20
 23a:	8c 93       	st	X, r24
 23c:	d2 c0       	rjmp	.+420    	; 0x3e2 <SetPinDirection+0x366>
			}
		}

	// 2 for port C
		else if (PortLetter == PortC_Letter)
 23e:	89 81       	ldd	r24, Y+1	; 0x01
 240:	82 30       	cpi	r24, 0x02	; 2
 242:	09 f0       	breq	.+2      	; 0x246 <SetPinDirection+0x1ca>
 244:	66 c0       	rjmp	.+204    	; 0x312 <SetPinDirection+0x296>
		{
			//DDRC
			if (PinDirection == INPUT) // Input (floating)
 246:	8b 81       	ldd	r24, Y+3	; 0x03
 248:	88 23       	and	r24, r24
 24a:	c1 f4       	brne	.+48     	; 0x27c <SetPinDirection+0x200>
			{
				CLR_BIT(DDRC, PinNumber%NUM);
 24c:	a4 e3       	ldi	r26, 0x34	; 52
 24e:	b0 e0       	ldi	r27, 0x00	; 0
 250:	e4 e3       	ldi	r30, 0x34	; 52
 252:	f0 e0       	ldi	r31, 0x00	; 0
 254:	80 81       	ld	r24, Z
 256:	48 2f       	mov	r20, r24
 258:	8a 81       	ldd	r24, Y+2	; 0x02
 25a:	88 2f       	mov	r24, r24
 25c:	90 e0       	ldi	r25, 0x00	; 0
 25e:	9c 01       	movw	r18, r24
 260:	27 70       	andi	r18, 0x07	; 7
 262:	30 70       	andi	r19, 0x00	; 0
 264:	81 e0       	ldi	r24, 0x01	; 1
 266:	90 e0       	ldi	r25, 0x00	; 0
 268:	02 2e       	mov	r0, r18
 26a:	02 c0       	rjmp	.+4      	; 0x270 <SetPinDirection+0x1f4>
 26c:	88 0f       	add	r24, r24
 26e:	99 1f       	adc	r25, r25
 270:	0a 94       	dec	r0
 272:	e2 f7       	brpl	.-8      	; 0x26c <SetPinDirection+0x1f0>
 274:	80 95       	com	r24
 276:	84 23       	and	r24, r20
 278:	8c 93       	st	X, r24
 27a:	b3 c0       	rjmp	.+358    	; 0x3e2 <SetPinDirection+0x366>
			}
			else if (PinDirection == OUTPUT) // Output
 27c:	8b 81       	ldd	r24, Y+3	; 0x03
 27e:	81 30       	cpi	r24, 0x01	; 1
 280:	b9 f4       	brne	.+46     	; 0x2b0 <SetPinDirection+0x234>
			{
				SET_BIT(DDRC, PinNumber%NUM);
 282:	a4 e3       	ldi	r26, 0x34	; 52
 284:	b0 e0       	ldi	r27, 0x00	; 0
 286:	e4 e3       	ldi	r30, 0x34	; 52
 288:	f0 e0       	ldi	r31, 0x00	; 0
 28a:	80 81       	ld	r24, Z
 28c:	48 2f       	mov	r20, r24
 28e:	8a 81       	ldd	r24, Y+2	; 0x02
 290:	88 2f       	mov	r24, r24
 292:	90 e0       	ldi	r25, 0x00	; 0
 294:	9c 01       	movw	r18, r24
 296:	27 70       	andi	r18, 0x07	; 7
 298:	30 70       	andi	r19, 0x00	; 0
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	90 e0       	ldi	r25, 0x00	; 0
 29e:	02 2e       	mov	r0, r18
 2a0:	02 c0       	rjmp	.+4      	; 0x2a6 <SetPinDirection+0x22a>
 2a2:	88 0f       	add	r24, r24
 2a4:	99 1f       	adc	r25, r25
 2a6:	0a 94       	dec	r0
 2a8:	e2 f7       	brpl	.-8      	; 0x2a2 <SetPinDirection+0x226>
 2aa:	84 2b       	or	r24, r20
 2ac:	8c 93       	st	X, r24
 2ae:	99 c0       	rjmp	.+306    	; 0x3e2 <SetPinDirection+0x366>
			}
			else if (PinDirection == INPUT_PU)
 2b0:	8b 81       	ldd	r24, Y+3	; 0x03
 2b2:	82 30       	cpi	r24, 0x02	; 2
 2b4:	09 f0       	breq	.+2      	; 0x2b8 <SetPinDirection+0x23c>
 2b6:	95 c0       	rjmp	.+298    	; 0x3e2 <SetPinDirection+0x366>
			{
				CLR_BIT(DDRC, PinNumber%NUM); // define as input
 2b8:	a4 e3       	ldi	r26, 0x34	; 52
 2ba:	b0 e0       	ldi	r27, 0x00	; 0
 2bc:	e4 e3       	ldi	r30, 0x34	; 52
 2be:	f0 e0       	ldi	r31, 0x00	; 0
 2c0:	80 81       	ld	r24, Z
 2c2:	48 2f       	mov	r20, r24
 2c4:	8a 81       	ldd	r24, Y+2	; 0x02
 2c6:	88 2f       	mov	r24, r24
 2c8:	90 e0       	ldi	r25, 0x00	; 0
 2ca:	9c 01       	movw	r18, r24
 2cc:	27 70       	andi	r18, 0x07	; 7
 2ce:	30 70       	andi	r19, 0x00	; 0
 2d0:	81 e0       	ldi	r24, 0x01	; 1
 2d2:	90 e0       	ldi	r25, 0x00	; 0
 2d4:	02 c0       	rjmp	.+4      	; 0x2da <SetPinDirection+0x25e>
 2d6:	88 0f       	add	r24, r24
 2d8:	99 1f       	adc	r25, r25
 2da:	2a 95       	dec	r18
 2dc:	e2 f7       	brpl	.-8      	; 0x2d6 <SetPinDirection+0x25a>
 2de:	80 95       	com	r24
 2e0:	84 23       	and	r24, r20
 2e2:	8c 93       	st	X, r24
				SET_BIT(PORTC, PinNumber%NUM); // write high to be Input (pull up)
 2e4:	a5 e3       	ldi	r26, 0x35	; 53
 2e6:	b0 e0       	ldi	r27, 0x00	; 0
 2e8:	e5 e3       	ldi	r30, 0x35	; 53
 2ea:	f0 e0       	ldi	r31, 0x00	; 0
 2ec:	80 81       	ld	r24, Z
 2ee:	48 2f       	mov	r20, r24
 2f0:	8a 81       	ldd	r24, Y+2	; 0x02
 2f2:	88 2f       	mov	r24, r24
 2f4:	90 e0       	ldi	r25, 0x00	; 0
 2f6:	9c 01       	movw	r18, r24
 2f8:	27 70       	andi	r18, 0x07	; 7
 2fa:	30 70       	andi	r19, 0x00	; 0
 2fc:	81 e0       	ldi	r24, 0x01	; 1
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	02 2e       	mov	r0, r18
 302:	02 c0       	rjmp	.+4      	; 0x308 <SetPinDirection+0x28c>
 304:	88 0f       	add	r24, r24
 306:	99 1f       	adc	r25, r25
 308:	0a 94       	dec	r0
 30a:	e2 f7       	brpl	.-8      	; 0x304 <SetPinDirection+0x288>
 30c:	84 2b       	or	r24, r20
 30e:	8c 93       	st	X, r24
 310:	68 c0       	rjmp	.+208    	; 0x3e2 <SetPinDirection+0x366>
			}
		}

	// 3 for port D
		else if (PortLetter == PortD_Letter)
 312:	89 81       	ldd	r24, Y+1	; 0x01
 314:	83 30       	cpi	r24, 0x03	; 3
 316:	09 f0       	breq	.+2      	; 0x31a <SetPinDirection+0x29e>
 318:	64 c0       	rjmp	.+200    	; 0x3e2 <SetPinDirection+0x366>
		{
			//DDRA
			if (PinDirection == INPUT) // Input (floating)
 31a:	8b 81       	ldd	r24, Y+3	; 0x03
 31c:	88 23       	and	r24, r24
 31e:	c1 f4       	brne	.+48     	; 0x350 <SetPinDirection+0x2d4>
			{
				CLR_BIT(DDRD, PinNumber%NUM);
 320:	a1 e3       	ldi	r26, 0x31	; 49
 322:	b0 e0       	ldi	r27, 0x00	; 0
 324:	e1 e3       	ldi	r30, 0x31	; 49
 326:	f0 e0       	ldi	r31, 0x00	; 0
 328:	80 81       	ld	r24, Z
 32a:	48 2f       	mov	r20, r24
 32c:	8a 81       	ldd	r24, Y+2	; 0x02
 32e:	88 2f       	mov	r24, r24
 330:	90 e0       	ldi	r25, 0x00	; 0
 332:	9c 01       	movw	r18, r24
 334:	27 70       	andi	r18, 0x07	; 7
 336:	30 70       	andi	r19, 0x00	; 0
 338:	81 e0       	ldi	r24, 0x01	; 1
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	02 2e       	mov	r0, r18
 33e:	02 c0       	rjmp	.+4      	; 0x344 <SetPinDirection+0x2c8>
 340:	88 0f       	add	r24, r24
 342:	99 1f       	adc	r25, r25
 344:	0a 94       	dec	r0
 346:	e2 f7       	brpl	.-8      	; 0x340 <SetPinDirection+0x2c4>
 348:	80 95       	com	r24
 34a:	84 23       	and	r24, r20
 34c:	8c 93       	st	X, r24
 34e:	49 c0       	rjmp	.+146    	; 0x3e2 <SetPinDirection+0x366>
			}
			else if (PinDirection == OUTPUT) // Output
 350:	8b 81       	ldd	r24, Y+3	; 0x03
 352:	81 30       	cpi	r24, 0x01	; 1
 354:	b9 f4       	brne	.+46     	; 0x384 <SetPinDirection+0x308>
			{
				SET_BIT(DDRD, PinNumber%NUM);
 356:	a1 e3       	ldi	r26, 0x31	; 49
 358:	b0 e0       	ldi	r27, 0x00	; 0
 35a:	e1 e3       	ldi	r30, 0x31	; 49
 35c:	f0 e0       	ldi	r31, 0x00	; 0
 35e:	80 81       	ld	r24, Z
 360:	48 2f       	mov	r20, r24
 362:	8a 81       	ldd	r24, Y+2	; 0x02
 364:	88 2f       	mov	r24, r24
 366:	90 e0       	ldi	r25, 0x00	; 0
 368:	9c 01       	movw	r18, r24
 36a:	27 70       	andi	r18, 0x07	; 7
 36c:	30 70       	andi	r19, 0x00	; 0
 36e:	81 e0       	ldi	r24, 0x01	; 1
 370:	90 e0       	ldi	r25, 0x00	; 0
 372:	02 2e       	mov	r0, r18
 374:	02 c0       	rjmp	.+4      	; 0x37a <SetPinDirection+0x2fe>
 376:	88 0f       	add	r24, r24
 378:	99 1f       	adc	r25, r25
 37a:	0a 94       	dec	r0
 37c:	e2 f7       	brpl	.-8      	; 0x376 <SetPinDirection+0x2fa>
 37e:	84 2b       	or	r24, r20
 380:	8c 93       	st	X, r24
 382:	2f c0       	rjmp	.+94     	; 0x3e2 <SetPinDirection+0x366>
			}
			else if (PinDirection == INPUT_PU)
 384:	8b 81       	ldd	r24, Y+3	; 0x03
 386:	82 30       	cpi	r24, 0x02	; 2
 388:	61 f5       	brne	.+88     	; 0x3e2 <SetPinDirection+0x366>
			{
				CLR_BIT(DDRD, PinNumber%NUM); // define as input
 38a:	a1 e3       	ldi	r26, 0x31	; 49
 38c:	b0 e0       	ldi	r27, 0x00	; 0
 38e:	e1 e3       	ldi	r30, 0x31	; 49
 390:	f0 e0       	ldi	r31, 0x00	; 0
 392:	80 81       	ld	r24, Z
 394:	48 2f       	mov	r20, r24
 396:	8a 81       	ldd	r24, Y+2	; 0x02
 398:	88 2f       	mov	r24, r24
 39a:	90 e0       	ldi	r25, 0x00	; 0
 39c:	9c 01       	movw	r18, r24
 39e:	27 70       	andi	r18, 0x07	; 7
 3a0:	30 70       	andi	r19, 0x00	; 0
 3a2:	81 e0       	ldi	r24, 0x01	; 1
 3a4:	90 e0       	ldi	r25, 0x00	; 0
 3a6:	02 c0       	rjmp	.+4      	; 0x3ac <SetPinDirection+0x330>
 3a8:	88 0f       	add	r24, r24
 3aa:	99 1f       	adc	r25, r25
 3ac:	2a 95       	dec	r18
 3ae:	e2 f7       	brpl	.-8      	; 0x3a8 <SetPinDirection+0x32c>
 3b0:	80 95       	com	r24
 3b2:	84 23       	and	r24, r20
 3b4:	8c 93       	st	X, r24
				SET_BIT(PORTD, PinNumber%NUM); // write high to be Input (pull up)
 3b6:	a2 e3       	ldi	r26, 0x32	; 50
 3b8:	b0 e0       	ldi	r27, 0x00	; 0
 3ba:	e2 e3       	ldi	r30, 0x32	; 50
 3bc:	f0 e0       	ldi	r31, 0x00	; 0
 3be:	80 81       	ld	r24, Z
 3c0:	48 2f       	mov	r20, r24
 3c2:	8a 81       	ldd	r24, Y+2	; 0x02
 3c4:	88 2f       	mov	r24, r24
 3c6:	90 e0       	ldi	r25, 0x00	; 0
 3c8:	9c 01       	movw	r18, r24
 3ca:	27 70       	andi	r18, 0x07	; 7
 3cc:	30 70       	andi	r19, 0x00	; 0
 3ce:	81 e0       	ldi	r24, 0x01	; 1
 3d0:	90 e0       	ldi	r25, 0x00	; 0
 3d2:	02 2e       	mov	r0, r18
 3d4:	02 c0       	rjmp	.+4      	; 0x3da <SetPinDirection+0x35e>
 3d6:	88 0f       	add	r24, r24
 3d8:	99 1f       	adc	r25, r25
 3da:	0a 94       	dec	r0
 3dc:	e2 f7       	brpl	.-8      	; 0x3d6 <SetPinDirection+0x35a>
 3de:	84 2b       	or	r24, r20
 3e0:	8c 93       	st	X, r24
			}
		}

}
 3e2:	0f 90       	pop	r0
 3e4:	0f 90       	pop	r0
 3e6:	0f 90       	pop	r0
 3e8:	cf 91       	pop	r28
 3ea:	df 91       	pop	r29
 3ec:	08 95       	ret

000003ee <SetPinValue>:

// Function (2): to set the output of the output pins (0-31)
void SetPinValue(u8 PinNumber, u8 PinValue)
{
 3ee:	df 93       	push	r29
 3f0:	cf 93       	push	r28
 3f2:	00 d0       	rcall	.+0      	; 0x3f4 <SetPinValue+0x6>
 3f4:	0f 92       	push	r0
 3f6:	cd b7       	in	r28, 0x3d	; 61
 3f8:	de b7       	in	r29, 0x3e	; 62
 3fa:	8a 83       	std	Y+2, r24	; 0x02
 3fc:	6b 83       	std	Y+3, r22	; 0x03
	u8 PortLetter = PinNumber/NUM; // to get the Port letter (0 for A, 1 for B, 2 for C, 3 for D)
 3fe:	8a 81       	ldd	r24, Y+2	; 0x02
 400:	86 95       	lsr	r24
 402:	86 95       	lsr	r24
 404:	86 95       	lsr	r24
 406:	89 83       	std	Y+1, r24	; 0x01
	// PinNumber%NUM gives the number of the pin in the port from 0 to 7


	if (PortLetter == PortA_Letter) // 0 for port A
 408:	89 81       	ldd	r24, Y+1	; 0x01
 40a:	88 23       	and	r24, r24
 40c:	b1 f5       	brne	.+108    	; 0x47a <SetPinValue+0x8c>
	{
		//PORTA
		if (PinValue == LOW) // Low
 40e:	8b 81       	ldd	r24, Y+3	; 0x03
 410:	88 23       	and	r24, r24
 412:	c1 f4       	brne	.+48     	; 0x444 <SetPinValue+0x56>
		{
			CLR_BIT(PORTA, PinNumber%NUM);
 414:	ab e3       	ldi	r26, 0x3B	; 59
 416:	b0 e0       	ldi	r27, 0x00	; 0
 418:	eb e3       	ldi	r30, 0x3B	; 59
 41a:	f0 e0       	ldi	r31, 0x00	; 0
 41c:	80 81       	ld	r24, Z
 41e:	48 2f       	mov	r20, r24
 420:	8a 81       	ldd	r24, Y+2	; 0x02
 422:	88 2f       	mov	r24, r24
 424:	90 e0       	ldi	r25, 0x00	; 0
 426:	9c 01       	movw	r18, r24
 428:	27 70       	andi	r18, 0x07	; 7
 42a:	30 70       	andi	r19, 0x00	; 0
 42c:	81 e0       	ldi	r24, 0x01	; 1
 42e:	90 e0       	ldi	r25, 0x00	; 0
 430:	02 2e       	mov	r0, r18
 432:	02 c0       	rjmp	.+4      	; 0x438 <SetPinValue+0x4a>
 434:	88 0f       	add	r24, r24
 436:	99 1f       	adc	r25, r25
 438:	0a 94       	dec	r0
 43a:	e2 f7       	brpl	.-8      	; 0x434 <SetPinValue+0x46>
 43c:	80 95       	com	r24
 43e:	84 23       	and	r24, r20
 440:	8c 93       	st	X, r24
 442:	c4 c0       	rjmp	.+392    	; 0x5cc <SetPinValue+0x1de>
		}
		else if (PinValue == HIGH) // High
 444:	8b 81       	ldd	r24, Y+3	; 0x03
 446:	81 30       	cpi	r24, 0x01	; 1
 448:	09 f0       	breq	.+2      	; 0x44c <SetPinValue+0x5e>
 44a:	c0 c0       	rjmp	.+384    	; 0x5cc <SetPinValue+0x1de>
		{
			SET_BIT(PORTA, PinNumber%NUM);
 44c:	ab e3       	ldi	r26, 0x3B	; 59
 44e:	b0 e0       	ldi	r27, 0x00	; 0
 450:	eb e3       	ldi	r30, 0x3B	; 59
 452:	f0 e0       	ldi	r31, 0x00	; 0
 454:	80 81       	ld	r24, Z
 456:	48 2f       	mov	r20, r24
 458:	8a 81       	ldd	r24, Y+2	; 0x02
 45a:	88 2f       	mov	r24, r24
 45c:	90 e0       	ldi	r25, 0x00	; 0
 45e:	9c 01       	movw	r18, r24
 460:	27 70       	andi	r18, 0x07	; 7
 462:	30 70       	andi	r19, 0x00	; 0
 464:	81 e0       	ldi	r24, 0x01	; 1
 466:	90 e0       	ldi	r25, 0x00	; 0
 468:	02 2e       	mov	r0, r18
 46a:	02 c0       	rjmp	.+4      	; 0x470 <SetPinValue+0x82>
 46c:	88 0f       	add	r24, r24
 46e:	99 1f       	adc	r25, r25
 470:	0a 94       	dec	r0
 472:	e2 f7       	brpl	.-8      	; 0x46c <SetPinValue+0x7e>
 474:	84 2b       	or	r24, r20
 476:	8c 93       	st	X, r24
 478:	a9 c0       	rjmp	.+338    	; 0x5cc <SetPinValue+0x1de>
		}
	}

	else if (PortLetter == PortB_Letter) // 1 for port B
 47a:	89 81       	ldd	r24, Y+1	; 0x01
 47c:	81 30       	cpi	r24, 0x01	; 1
 47e:	b1 f5       	brne	.+108    	; 0x4ec <SetPinValue+0xfe>
	{
		//PORTB
		if (PinValue == LOW) // Low
 480:	8b 81       	ldd	r24, Y+3	; 0x03
 482:	88 23       	and	r24, r24
 484:	c1 f4       	brne	.+48     	; 0x4b6 <SetPinValue+0xc8>
		{
			CLR_BIT(PORTB, PinNumber%NUM);
 486:	a8 e3       	ldi	r26, 0x38	; 56
 488:	b0 e0       	ldi	r27, 0x00	; 0
 48a:	e8 e3       	ldi	r30, 0x38	; 56
 48c:	f0 e0       	ldi	r31, 0x00	; 0
 48e:	80 81       	ld	r24, Z
 490:	48 2f       	mov	r20, r24
 492:	8a 81       	ldd	r24, Y+2	; 0x02
 494:	88 2f       	mov	r24, r24
 496:	90 e0       	ldi	r25, 0x00	; 0
 498:	9c 01       	movw	r18, r24
 49a:	27 70       	andi	r18, 0x07	; 7
 49c:	30 70       	andi	r19, 0x00	; 0
 49e:	81 e0       	ldi	r24, 0x01	; 1
 4a0:	90 e0       	ldi	r25, 0x00	; 0
 4a2:	02 2e       	mov	r0, r18
 4a4:	02 c0       	rjmp	.+4      	; 0x4aa <SetPinValue+0xbc>
 4a6:	88 0f       	add	r24, r24
 4a8:	99 1f       	adc	r25, r25
 4aa:	0a 94       	dec	r0
 4ac:	e2 f7       	brpl	.-8      	; 0x4a6 <SetPinValue+0xb8>
 4ae:	80 95       	com	r24
 4b0:	84 23       	and	r24, r20
 4b2:	8c 93       	st	X, r24
 4b4:	8b c0       	rjmp	.+278    	; 0x5cc <SetPinValue+0x1de>
		}
		else if (PinValue == HIGH) // High
 4b6:	8b 81       	ldd	r24, Y+3	; 0x03
 4b8:	81 30       	cpi	r24, 0x01	; 1
 4ba:	09 f0       	breq	.+2      	; 0x4be <SetPinValue+0xd0>
 4bc:	87 c0       	rjmp	.+270    	; 0x5cc <SetPinValue+0x1de>
		{
			SET_BIT(PORTB, PinNumber%NUM);
 4be:	a8 e3       	ldi	r26, 0x38	; 56
 4c0:	b0 e0       	ldi	r27, 0x00	; 0
 4c2:	e8 e3       	ldi	r30, 0x38	; 56
 4c4:	f0 e0       	ldi	r31, 0x00	; 0
 4c6:	80 81       	ld	r24, Z
 4c8:	48 2f       	mov	r20, r24
 4ca:	8a 81       	ldd	r24, Y+2	; 0x02
 4cc:	88 2f       	mov	r24, r24
 4ce:	90 e0       	ldi	r25, 0x00	; 0
 4d0:	9c 01       	movw	r18, r24
 4d2:	27 70       	andi	r18, 0x07	; 7
 4d4:	30 70       	andi	r19, 0x00	; 0
 4d6:	81 e0       	ldi	r24, 0x01	; 1
 4d8:	90 e0       	ldi	r25, 0x00	; 0
 4da:	02 2e       	mov	r0, r18
 4dc:	02 c0       	rjmp	.+4      	; 0x4e2 <SetPinValue+0xf4>
 4de:	88 0f       	add	r24, r24
 4e0:	99 1f       	adc	r25, r25
 4e2:	0a 94       	dec	r0
 4e4:	e2 f7       	brpl	.-8      	; 0x4de <SetPinValue+0xf0>
 4e6:	84 2b       	or	r24, r20
 4e8:	8c 93       	st	X, r24
 4ea:	70 c0       	rjmp	.+224    	; 0x5cc <SetPinValue+0x1de>
		}
	}


	else if (PortLetter == PortC_Letter) // 2 for port C
 4ec:	89 81       	ldd	r24, Y+1	; 0x01
 4ee:	82 30       	cpi	r24, 0x02	; 2
 4f0:	b1 f5       	brne	.+108    	; 0x55e <SetPinValue+0x170>
	{
		//PORTC
		if (PinValue == LOW) // Low
 4f2:	8b 81       	ldd	r24, Y+3	; 0x03
 4f4:	88 23       	and	r24, r24
 4f6:	c1 f4       	brne	.+48     	; 0x528 <SetPinValue+0x13a>
		{
			CLR_BIT(PORTC, PinNumber%NUM);
 4f8:	a5 e3       	ldi	r26, 0x35	; 53
 4fa:	b0 e0       	ldi	r27, 0x00	; 0
 4fc:	e5 e3       	ldi	r30, 0x35	; 53
 4fe:	f0 e0       	ldi	r31, 0x00	; 0
 500:	80 81       	ld	r24, Z
 502:	48 2f       	mov	r20, r24
 504:	8a 81       	ldd	r24, Y+2	; 0x02
 506:	88 2f       	mov	r24, r24
 508:	90 e0       	ldi	r25, 0x00	; 0
 50a:	9c 01       	movw	r18, r24
 50c:	27 70       	andi	r18, 0x07	; 7
 50e:	30 70       	andi	r19, 0x00	; 0
 510:	81 e0       	ldi	r24, 0x01	; 1
 512:	90 e0       	ldi	r25, 0x00	; 0
 514:	02 2e       	mov	r0, r18
 516:	02 c0       	rjmp	.+4      	; 0x51c <SetPinValue+0x12e>
 518:	88 0f       	add	r24, r24
 51a:	99 1f       	adc	r25, r25
 51c:	0a 94       	dec	r0
 51e:	e2 f7       	brpl	.-8      	; 0x518 <SetPinValue+0x12a>
 520:	80 95       	com	r24
 522:	84 23       	and	r24, r20
 524:	8c 93       	st	X, r24
 526:	52 c0       	rjmp	.+164    	; 0x5cc <SetPinValue+0x1de>
		}
		else if (PinValue == HIGH) // High
 528:	8b 81       	ldd	r24, Y+3	; 0x03
 52a:	81 30       	cpi	r24, 0x01	; 1
 52c:	09 f0       	breq	.+2      	; 0x530 <SetPinValue+0x142>
 52e:	4e c0       	rjmp	.+156    	; 0x5cc <SetPinValue+0x1de>
		{
			SET_BIT(PORTC, PinNumber%NUM);
 530:	a5 e3       	ldi	r26, 0x35	; 53
 532:	b0 e0       	ldi	r27, 0x00	; 0
 534:	e5 e3       	ldi	r30, 0x35	; 53
 536:	f0 e0       	ldi	r31, 0x00	; 0
 538:	80 81       	ld	r24, Z
 53a:	48 2f       	mov	r20, r24
 53c:	8a 81       	ldd	r24, Y+2	; 0x02
 53e:	88 2f       	mov	r24, r24
 540:	90 e0       	ldi	r25, 0x00	; 0
 542:	9c 01       	movw	r18, r24
 544:	27 70       	andi	r18, 0x07	; 7
 546:	30 70       	andi	r19, 0x00	; 0
 548:	81 e0       	ldi	r24, 0x01	; 1
 54a:	90 e0       	ldi	r25, 0x00	; 0
 54c:	02 2e       	mov	r0, r18
 54e:	02 c0       	rjmp	.+4      	; 0x554 <SetPinValue+0x166>
 550:	88 0f       	add	r24, r24
 552:	99 1f       	adc	r25, r25
 554:	0a 94       	dec	r0
 556:	e2 f7       	brpl	.-8      	; 0x550 <SetPinValue+0x162>
 558:	84 2b       	or	r24, r20
 55a:	8c 93       	st	X, r24
 55c:	37 c0       	rjmp	.+110    	; 0x5cc <SetPinValue+0x1de>
		}
	}

	else if (PortLetter == PortD_Letter) // 3 for port D
 55e:	89 81       	ldd	r24, Y+1	; 0x01
 560:	83 30       	cpi	r24, 0x03	; 3
 562:	a1 f5       	brne	.+104    	; 0x5cc <SetPinValue+0x1de>
	{
		//PORTD
		if (PinValue == LOW) // Low
 564:	8b 81       	ldd	r24, Y+3	; 0x03
 566:	88 23       	and	r24, r24
 568:	c1 f4       	brne	.+48     	; 0x59a <SetPinValue+0x1ac>
		{
			CLR_BIT(PORTD, PinNumber%NUM);
 56a:	a2 e3       	ldi	r26, 0x32	; 50
 56c:	b0 e0       	ldi	r27, 0x00	; 0
 56e:	e2 e3       	ldi	r30, 0x32	; 50
 570:	f0 e0       	ldi	r31, 0x00	; 0
 572:	80 81       	ld	r24, Z
 574:	48 2f       	mov	r20, r24
 576:	8a 81       	ldd	r24, Y+2	; 0x02
 578:	88 2f       	mov	r24, r24
 57a:	90 e0       	ldi	r25, 0x00	; 0
 57c:	9c 01       	movw	r18, r24
 57e:	27 70       	andi	r18, 0x07	; 7
 580:	30 70       	andi	r19, 0x00	; 0
 582:	81 e0       	ldi	r24, 0x01	; 1
 584:	90 e0       	ldi	r25, 0x00	; 0
 586:	02 2e       	mov	r0, r18
 588:	02 c0       	rjmp	.+4      	; 0x58e <SetPinValue+0x1a0>
 58a:	88 0f       	add	r24, r24
 58c:	99 1f       	adc	r25, r25
 58e:	0a 94       	dec	r0
 590:	e2 f7       	brpl	.-8      	; 0x58a <SetPinValue+0x19c>
 592:	80 95       	com	r24
 594:	84 23       	and	r24, r20
 596:	8c 93       	st	X, r24
 598:	19 c0       	rjmp	.+50     	; 0x5cc <SetPinValue+0x1de>
		}
		else if (PinValue == HIGH) // High
 59a:	8b 81       	ldd	r24, Y+3	; 0x03
 59c:	81 30       	cpi	r24, 0x01	; 1
 59e:	b1 f4       	brne	.+44     	; 0x5cc <SetPinValue+0x1de>
		{
			SET_BIT(PORTD, PinNumber%NUM);
 5a0:	a2 e3       	ldi	r26, 0x32	; 50
 5a2:	b0 e0       	ldi	r27, 0x00	; 0
 5a4:	e2 e3       	ldi	r30, 0x32	; 50
 5a6:	f0 e0       	ldi	r31, 0x00	; 0
 5a8:	80 81       	ld	r24, Z
 5aa:	48 2f       	mov	r20, r24
 5ac:	8a 81       	ldd	r24, Y+2	; 0x02
 5ae:	88 2f       	mov	r24, r24
 5b0:	90 e0       	ldi	r25, 0x00	; 0
 5b2:	9c 01       	movw	r18, r24
 5b4:	27 70       	andi	r18, 0x07	; 7
 5b6:	30 70       	andi	r19, 0x00	; 0
 5b8:	81 e0       	ldi	r24, 0x01	; 1
 5ba:	90 e0       	ldi	r25, 0x00	; 0
 5bc:	02 2e       	mov	r0, r18
 5be:	02 c0       	rjmp	.+4      	; 0x5c4 <SetPinValue+0x1d6>
 5c0:	88 0f       	add	r24, r24
 5c2:	99 1f       	adc	r25, r25
 5c4:	0a 94       	dec	r0
 5c6:	e2 f7       	brpl	.-8      	; 0x5c0 <SetPinValue+0x1d2>
 5c8:	84 2b       	or	r24, r20
 5ca:	8c 93       	st	X, r24
		}
	}
}
 5cc:	0f 90       	pop	r0
 5ce:	0f 90       	pop	r0
 5d0:	0f 90       	pop	r0
 5d2:	cf 91       	pop	r28
 5d4:	df 91       	pop	r29
 5d6:	08 95       	ret

000005d8 <GetPinValue>:



// Fucntion (3): to get the value of the input pin
u8 GetPinValue(u8 PinNumber) // return the value of pin 0 - 31
{
 5d8:	df 93       	push	r29
 5da:	cf 93       	push	r28
 5dc:	00 d0       	rcall	.+0      	; 0x5de <GetPinValue+0x6>
 5de:	00 d0       	rcall	.+0      	; 0x5e0 <GetPinValue+0x8>
 5e0:	cd b7       	in	r28, 0x3d	; 61
 5e2:	de b7       	in	r29, 0x3e	; 62
 5e4:	8a 83       	std	Y+2, r24	; 0x02
	u8 PortLetter = PinNumber/NUM; // to get the Port letter (0 for A, 1 for B, 2 for C, 3 for D)
 5e6:	8a 81       	ldd	r24, Y+2	; 0x02
 5e8:	86 95       	lsr	r24
 5ea:	86 95       	lsr	r24
 5ec:	86 95       	lsr	r24
 5ee:	89 83       	std	Y+1, r24	; 0x01
	// PinNumber%NUM gives the number of the pin in the port from 0 to 7

	if (PortLetter == PortA_Letter) // 0 for port A
 5f0:	89 81       	ldd	r24, Y+1	; 0x01
 5f2:	88 23       	and	r24, r24
 5f4:	a9 f4       	brne	.+42     	; 0x620 <GetPinValue+0x48>
	{
		//PINA
		return GET_BIT(PINA, PinNumber%NUM);
 5f6:	e9 e3       	ldi	r30, 0x39	; 57
 5f8:	f0 e0       	ldi	r31, 0x00	; 0
 5fa:	80 81       	ld	r24, Z
 5fc:	28 2f       	mov	r18, r24
 5fe:	30 e0       	ldi	r19, 0x00	; 0
 600:	8a 81       	ldd	r24, Y+2	; 0x02
 602:	88 2f       	mov	r24, r24
 604:	90 e0       	ldi	r25, 0x00	; 0
 606:	87 70       	andi	r24, 0x07	; 7
 608:	90 70       	andi	r25, 0x00	; 0
 60a:	a9 01       	movw	r20, r18
 60c:	02 c0       	rjmp	.+4      	; 0x612 <GetPinValue+0x3a>
 60e:	55 95       	asr	r21
 610:	47 95       	ror	r20
 612:	8a 95       	dec	r24
 614:	e2 f7       	brpl	.-8      	; 0x60e <GetPinValue+0x36>
 616:	ca 01       	movw	r24, r20
 618:	58 2f       	mov	r21, r24
 61a:	51 70       	andi	r21, 0x01	; 1
 61c:	5b 83       	std	Y+3, r21	; 0x03
 61e:	49 c0       	rjmp	.+146    	; 0x6b2 <GetPinValue+0xda>
	}
	else if (PortLetter == PortB_Letter) // 1 for port B
 620:	89 81       	ldd	r24, Y+1	; 0x01
 622:	81 30       	cpi	r24, 0x01	; 1
 624:	a9 f4       	brne	.+42     	; 0x650 <GetPinValue+0x78>
	{
		//PINB
		return GET_BIT(PINB, PinNumber%NUM);
 626:	e6 e3       	ldi	r30, 0x36	; 54
 628:	f0 e0       	ldi	r31, 0x00	; 0
 62a:	80 81       	ld	r24, Z
 62c:	28 2f       	mov	r18, r24
 62e:	30 e0       	ldi	r19, 0x00	; 0
 630:	8a 81       	ldd	r24, Y+2	; 0x02
 632:	88 2f       	mov	r24, r24
 634:	90 e0       	ldi	r25, 0x00	; 0
 636:	87 70       	andi	r24, 0x07	; 7
 638:	90 70       	andi	r25, 0x00	; 0
 63a:	a9 01       	movw	r20, r18
 63c:	02 c0       	rjmp	.+4      	; 0x642 <GetPinValue+0x6a>
 63e:	55 95       	asr	r21
 640:	47 95       	ror	r20
 642:	8a 95       	dec	r24
 644:	e2 f7       	brpl	.-8      	; 0x63e <GetPinValue+0x66>
 646:	ca 01       	movw	r24, r20
 648:	58 2f       	mov	r21, r24
 64a:	51 70       	andi	r21, 0x01	; 1
 64c:	5b 83       	std	Y+3, r21	; 0x03
 64e:	31 c0       	rjmp	.+98     	; 0x6b2 <GetPinValue+0xda>
	}

	else if (PortLetter == PortC_Letter) // 2 for port C
 650:	89 81       	ldd	r24, Y+1	; 0x01
 652:	82 30       	cpi	r24, 0x02	; 2
 654:	a9 f4       	brne	.+42     	; 0x680 <GetPinValue+0xa8>
	{
		//PINC
		return GET_BIT(PINC, PinNumber%NUM);
 656:	e3 e3       	ldi	r30, 0x33	; 51
 658:	f0 e0       	ldi	r31, 0x00	; 0
 65a:	80 81       	ld	r24, Z
 65c:	28 2f       	mov	r18, r24
 65e:	30 e0       	ldi	r19, 0x00	; 0
 660:	8a 81       	ldd	r24, Y+2	; 0x02
 662:	88 2f       	mov	r24, r24
 664:	90 e0       	ldi	r25, 0x00	; 0
 666:	87 70       	andi	r24, 0x07	; 7
 668:	90 70       	andi	r25, 0x00	; 0
 66a:	a9 01       	movw	r20, r18
 66c:	02 c0       	rjmp	.+4      	; 0x672 <GetPinValue+0x9a>
 66e:	55 95       	asr	r21
 670:	47 95       	ror	r20
 672:	8a 95       	dec	r24
 674:	e2 f7       	brpl	.-8      	; 0x66e <GetPinValue+0x96>
 676:	ca 01       	movw	r24, r20
 678:	58 2f       	mov	r21, r24
 67a:	51 70       	andi	r21, 0x01	; 1
 67c:	5b 83       	std	Y+3, r21	; 0x03
 67e:	19 c0       	rjmp	.+50     	; 0x6b2 <GetPinValue+0xda>
	}

	else if (PortLetter == PortD_Letter) // 3 for port D
 680:	89 81       	ldd	r24, Y+1	; 0x01
 682:	83 30       	cpi	r24, 0x03	; 3
 684:	a9 f4       	brne	.+42     	; 0x6b0 <GetPinValue+0xd8>
	{
		//PIND
		return GET_BIT(PIND, PinNumber%NUM);
 686:	e0 e3       	ldi	r30, 0x30	; 48
 688:	f0 e0       	ldi	r31, 0x00	; 0
 68a:	80 81       	ld	r24, Z
 68c:	28 2f       	mov	r18, r24
 68e:	30 e0       	ldi	r19, 0x00	; 0
 690:	8a 81       	ldd	r24, Y+2	; 0x02
 692:	88 2f       	mov	r24, r24
 694:	90 e0       	ldi	r25, 0x00	; 0
 696:	87 70       	andi	r24, 0x07	; 7
 698:	90 70       	andi	r25, 0x00	; 0
 69a:	a9 01       	movw	r20, r18
 69c:	02 c0       	rjmp	.+4      	; 0x6a2 <GetPinValue+0xca>
 69e:	55 95       	asr	r21
 6a0:	47 95       	ror	r20
 6a2:	8a 95       	dec	r24
 6a4:	e2 f7       	brpl	.-8      	; 0x69e <GetPinValue+0xc6>
 6a6:	ca 01       	movw	r24, r20
 6a8:	58 2f       	mov	r21, r24
 6aa:	51 70       	andi	r21, 0x01	; 1
 6ac:	5b 83       	std	Y+3, r21	; 0x03
 6ae:	01 c0       	rjmp	.+2      	; 0x6b2 <GetPinValue+0xda>
 6b0:	02 c0       	rjmp	.+4      	; 0x6b6 <GetPinValue+0xde>
	}
}
 6b2:	8b 81       	ldd	r24, Y+3	; 0x03
 6b4:	8c 83       	std	Y+4, r24	; 0x04
 6b6:	8c 81       	ldd	r24, Y+4	; 0x04
 6b8:	0f 90       	pop	r0
 6ba:	0f 90       	pop	r0
 6bc:	0f 90       	pop	r0
 6be:	0f 90       	pop	r0
 6c0:	cf 91       	pop	r28
 6c2:	df 91       	pop	r29
 6c4:	08 95       	ret

000006c6 <main>:

// Enum


void main(void)
{
 6c6:	df 93       	push	r29
 6c8:	cf 93       	push	r28
 6ca:	cd b7       	in	r28, 0x3d	; 61
 6cc:	de b7       	in	r29, 0x3e	; 62

	// Declaration and Initialization (executed once)
	SetPinDirection(LED_Pin, OUTPUT); // define LED pin as output
 6ce:	80 e1       	ldi	r24, 0x10	; 16
 6d0:	61 e0       	ldi	r22, 0x01	; 1
 6d2:	0e 94 3e 00 	call	0x7c	; 0x7c <SetPinDirection>
	// program variables


	// Module Initialization
		// Timers Initialization
			CLR_BIT(TCCR0, WGM00); // Normal wave generation mode
 6d6:	a3 e5       	ldi	r26, 0x53	; 83
 6d8:	b0 e0       	ldi	r27, 0x00	; 0
 6da:	e3 e5       	ldi	r30, 0x53	; 83
 6dc:	f0 e0       	ldi	r31, 0x00	; 0
 6de:	80 81       	ld	r24, Z
 6e0:	8f 7b       	andi	r24, 0xBF	; 191
 6e2:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, WGM01); // Normal wave generation mode
 6e4:	a3 e5       	ldi	r26, 0x53	; 83
 6e6:	b0 e0       	ldi	r27, 0x00	; 0
 6e8:	e3 e5       	ldi	r30, 0x53	; 83
 6ea:	f0 e0       	ldi	r31, 0x00	; 0
 6ec:	80 81       	ld	r24, Z
 6ee:	87 7f       	andi	r24, 0xF7	; 247
 6f0:	8c 93       	st	X, r24
			SET_BIT(SREG, I); // global interrupt enable
 6f2:	af e5       	ldi	r26, 0x5F	; 95
 6f4:	b0 e0       	ldi	r27, 0x00	; 0
 6f6:	ef e5       	ldi	r30, 0x5F	; 95
 6f8:	f0 e0       	ldi	r31, 0x00	; 0
 6fa:	80 81       	ld	r24, Z
 6fc:	80 68       	ori	r24, 0x80	; 128
 6fe:	8c 93       	st	X, r24
			SET_BIT(TIMSK, TOIE0); // enable timer0 interrupt
 700:	a9 e5       	ldi	r26, 0x59	; 89
 702:	b0 e0       	ldi	r27, 0x00	; 0
 704:	e9 e5       	ldi	r30, 0x59	; 89
 706:	f0 e0       	ldi	r31, 0x00	; 0
 708:	80 81       	ld	r24, Z
 70a:	81 60       	ori	r24, 0x01	; 1
 70c:	8c 93       	st	X, r24
			TCNT0 = OneSecInitTCNT0_1024; // initially for the fractional part for 1 second
 70e:	e2 e5       	ldi	r30, 0x52	; 82
 710:	f0 e0       	ldi	r31, 0x00	; 0
 712:	8b e7       	ldi	r24, 0x7B	; 123
 714:	80 83       	st	Z, r24
			SET_BIT(TCCR0, CS02); CLR_BIT(TCCR0, CS01); SET_BIT(TCCR0, CS00); // Start the timer TCCR0 = 0b00000101; prescaler 1024
 716:	a3 e5       	ldi	r26, 0x53	; 83
 718:	b0 e0       	ldi	r27, 0x00	; 0
 71a:	e3 e5       	ldi	r30, 0x53	; 83
 71c:	f0 e0       	ldi	r31, 0x00	; 0
 71e:	80 81       	ld	r24, Z
 720:	84 60       	ori	r24, 0x04	; 4
 722:	8c 93       	st	X, r24
 724:	a3 e5       	ldi	r26, 0x53	; 83
 726:	b0 e0       	ldi	r27, 0x00	; 0
 728:	e3 e5       	ldi	r30, 0x53	; 83
 72a:	f0 e0       	ldi	r31, 0x00	; 0
 72c:	80 81       	ld	r24, Z
 72e:	8d 7f       	andi	r24, 0xFD	; 253
 730:	8c 93       	st	X, r24
 732:	a3 e5       	ldi	r26, 0x53	; 83
 734:	b0 e0       	ldi	r27, 0x00	; 0
 736:	e3 e5       	ldi	r30, 0x53	; 83
 738:	f0 e0       	ldi	r31, 0x00	; 0
 73a:	80 81       	ld	r24, Z
 73c:	81 60       	ori	r24, 0x01	; 1
 73e:	8c 93       	st	X, r24
 740:	ff cf       	rjmp	.-2      	; 0x740 <main+0x7a>

00000742 <__vector_11>:
}


// Interrupt function to be executed when an overflow takes place in timer 0 register TCNT0
ISR(__vector_11) // Timer/Counter0 Overflow vector no. (12) - 1
{
 742:	1f 92       	push	r1
 744:	0f 92       	push	r0
 746:	0f b6       	in	r0, 0x3f	; 63
 748:	0f 92       	push	r0
 74a:	11 24       	eor	r1, r1
 74c:	2f 93       	push	r18
 74e:	3f 93       	push	r19
 750:	4f 93       	push	r20
 752:	5f 93       	push	r21
 754:	6f 93       	push	r22
 756:	7f 93       	push	r23
 758:	8f 93       	push	r24
 75a:	9f 93       	push	r25
 75c:	af 93       	push	r26
 75e:	bf 93       	push	r27
 760:	ef 93       	push	r30
 762:	ff 93       	push	r31
 764:	df 93       	push	r29
 766:	cf 93       	push	r28
 768:	cd b7       	in	r28, 0x3d	; 61
 76a:	de b7       	in	r29, 0x3e	; 62

	overflows++; // each time this function is called increment the counter
 76c:	80 91 60 00 	lds	r24, 0x0060
 770:	8f 5f       	subi	r24, 0xFF	; 255
 772:	80 93 60 00 	sts	0x0060, r24

	// --------------------------------------- One Seconds Starts ---------------------------------------------
	if ( (overflows == OneSecCounts_1024) && (LED_State == LED_ON) )
 776:	80 91 60 00 	lds	r24, 0x0060
 77a:	8f 31       	cpi	r24, 0x1F	; 31
 77c:	99 f4       	brne	.+38     	; 0x7a4 <__vector_11+0x62>
 77e:	80 91 61 00 	lds	r24, 0x0061
 782:	81 30       	cpi	r24, 0x01	; 1
 784:	79 f4       	brne	.+30     	; 0x7a4 <__vector_11+0x62>
	{
		// Come to this function when one second has passed and the LED state is on to turn it off
		LED_State = LED_OFF;
 786:	10 92 61 00 	sts	0x0061, r1
		SetPinValue(LED_Pin, LED_State);
 78a:	90 91 61 00 	lds	r25, 0x0061
 78e:	80 e1       	ldi	r24, 0x10	; 16
 790:	69 2f       	mov	r22, r25
 792:	0e 94 f7 01 	call	0x3ee	; 0x3ee <SetPinValue>
		overflows = 0; // reset the counter
 796:	10 92 60 00 	sts	0x0060, r1
		TCNT0 = TwoSecInitTCNT0_1024; // For the next part (two seconds), initialize the Timer 0 register TCNT0 with the number corresponding to the fraction part needed for the two seconds
 79a:	e2 e5       	ldi	r30, 0x52	; 82
 79c:	f0 e0       	ldi	r31, 0x00	; 0
 79e:	86 ef       	ldi	r24, 0xF6	; 246
 7a0:	80 83       	st	Z, r24
 7a2:	17 c0       	rjmp	.+46     	; 0x7d2 <__vector_11+0x90>
	// --------------------------------------- One Seconds Ends with (LED OFF) --------------------------------
	// the LED exits with OFF state and will wait for 2 seconds in the next loop with this state


	// --------------------------------------- Two Seconds Starts ---------------------------------------------
	else if ( (overflows == TwoSecCounts_1024) && (LED_State == LED_OFF) )
 7a4:	80 91 60 00 	lds	r24, 0x0060
 7a8:	8e 33       	cpi	r24, 0x3E	; 62
 7aa:	99 f4       	brne	.+38     	; 0x7d2 <__vector_11+0x90>
 7ac:	80 91 61 00 	lds	r24, 0x0061
 7b0:	88 23       	and	r24, r24
 7b2:	79 f4       	brne	.+30     	; 0x7d2 <__vector_11+0x90>
	{
		// Come to this function when two seconds has passed and the LED state is off to turn it on
		LED_State = LED_ON;
 7b4:	81 e0       	ldi	r24, 0x01	; 1
 7b6:	80 93 61 00 	sts	0x0061, r24
		SetPinValue(LED_Pin, LED_State);
 7ba:	90 91 61 00 	lds	r25, 0x0061
 7be:	80 e1       	ldi	r24, 0x10	; 16
 7c0:	69 2f       	mov	r22, r25
 7c2:	0e 94 f7 01 	call	0x3ee	; 0x3ee <SetPinValue>
		overflows = 0; // reset the counter
 7c6:	10 92 60 00 	sts	0x0060, r1
		TCNT0 = OneSecInitTCNT0_1024; // For the next part (one seconds), initialize the Timer 0 register TCNT0 with the number corresponding to the fraction part needed for the one second
 7ca:	e2 e5       	ldi	r30, 0x52	; 82
 7cc:	f0 e0       	ldi	r31, 0x00	; 0
 7ce:	8b e7       	ldi	r24, 0x7B	; 123
 7d0:	80 83       	st	Z, r24
	}
	// --------------------------------------- Two Seconds Ends with (LED ON) --------------------------------
	// the LED exits with ON state and will wait for one second in the next loop with this state

	// flag resets automatically
}
 7d2:	cf 91       	pop	r28
 7d4:	df 91       	pop	r29
 7d6:	ff 91       	pop	r31
 7d8:	ef 91       	pop	r30
 7da:	bf 91       	pop	r27
 7dc:	af 91       	pop	r26
 7de:	9f 91       	pop	r25
 7e0:	8f 91       	pop	r24
 7e2:	7f 91       	pop	r23
 7e4:	6f 91       	pop	r22
 7e6:	5f 91       	pop	r21
 7e8:	4f 91       	pop	r20
 7ea:	3f 91       	pop	r19
 7ec:	2f 91       	pop	r18
 7ee:	0f 90       	pop	r0
 7f0:	0f be       	out	0x3f, r0	; 63
 7f2:	0f 90       	pop	r0
 7f4:	1f 90       	pop	r1
 7f6:	18 95       	reti

000007f8 <_exit>:
 7f8:	f8 94       	cli

000007fa <__stop_program>:
 7fa:	ff cf       	rjmp	.-2      	; 0x7fa <__stop_program>
