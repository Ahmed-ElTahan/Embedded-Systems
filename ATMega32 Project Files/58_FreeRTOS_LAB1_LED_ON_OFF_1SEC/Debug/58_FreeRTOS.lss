
58_FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000026fc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  000026fc  00002790  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002f7  00800068  00800068  00002798  2**0
                  ALLOC
  3 .stab         00004344  00000000  00000000  00002798  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002936  00000000  00000000  00006adc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 ee 07 	jmp	0xfdc	; 0xfdc <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec ef       	ldi	r30, 0xFC	; 252
      68:	f6 e2       	ldi	r31, 0x26	; 38
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 35       	cpi	r26, 0x5F	; 95
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 7c 13 	jmp	0x26f8	; 0x26f8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	cd b7       	in	r28, 0x3d	; 61
      a6:	de b7       	in	r29, 0x3e	; 62
      a8:	ea e3       	ldi	r30, 0x3A	; 58
      aa:	f0 e0       	ldi	r31, 0x00	; 0
      ac:	8f ef       	ldi	r24, 0xFF	; 255
      ae:	80 83       	st	Z, r24
      b0:	88 e8       	ldi	r24, 0x88	; 136
      b2:	90 e0       	ldi	r25, 0x00	; 0
      b4:	60 e0       	ldi	r22, 0x00	; 0
      b6:	70 e0       	ldi	r23, 0x00	; 0
      b8:	45 e5       	ldi	r20, 0x55	; 85
      ba:	50 e0       	ldi	r21, 0x00	; 0
      bc:	20 e0       	ldi	r18, 0x00	; 0
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	03 e0       	ldi	r16, 0x03	; 3
      c2:	ee 24       	eor	r14, r14
      c4:	ff 24       	eor	r15, r15
      c6:	cc 24       	eor	r12, r12
      c8:	dd 24       	eor	r13, r13
      ca:	aa 24       	eor	r10, r10
      cc:	bb 24       	eor	r11, r11
      ce:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <xTaskGenericCreate>
      d2:	84 e9       	ldi	r24, 0x94	; 148
      d4:	90 e0       	ldi	r25, 0x00	; 0
      d6:	60 e0       	ldi	r22, 0x00	; 0
      d8:	70 e0       	ldi	r23, 0x00	; 0
      da:	45 e5       	ldi	r20, 0x55	; 85
      dc:	50 e0       	ldi	r21, 0x00	; 0
      de:	20 e0       	ldi	r18, 0x00	; 0
      e0:	30 e0       	ldi	r19, 0x00	; 0
      e2:	03 e0       	ldi	r16, 0x03	; 3
      e4:	ee 24       	eor	r14, r14
      e6:	ff 24       	eor	r15, r15
      e8:	cc 24       	eor	r12, r12
      ea:	dd 24       	eor	r13, r13
      ec:	aa 24       	eor	r10, r10
      ee:	bb 24       	eor	r11, r11
      f0:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <xTaskGenericCreate>
      f4:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <vTaskStartScheduler>
      f8:	80 e0       	ldi	r24, 0x00	; 0
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	cf 91       	pop	r28
      fe:	df 91       	pop	r29
     100:	0f 91       	pop	r16
     102:	ff 90       	pop	r15
     104:	ef 90       	pop	r14
     106:	df 90       	pop	r13
     108:	cf 90       	pop	r12
     10a:	bf 90       	pop	r11
     10c:	af 90       	pop	r10
     10e:	08 95       	ret

00000110 <task1_code>:
    
}

/*Task1 Code */
 void task1_code(void*pvParamter)
{
     110:	df 93       	push	r29
     112:	cf 93       	push	r28
     114:	00 d0       	rcall	.+0      	; 0x116 <task1_code+0x6>
     116:	cd b7       	in	r28, 0x3d	; 61
     118:	de b7       	in	r29, 0x3e	; 62
     11a:	9a 83       	std	Y+2, r25	; 0x02
     11c:	89 83       	std	Y+1, r24	; 0x01
	
	for (;;)
	{
		PORTA = 0xFF;
     11e:	eb e3       	ldi	r30, 0x3B	; 59
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	8f ef       	ldi	r24, 0xFF	; 255
     124:	80 83       	st	Z, r24
     126:	fb cf       	rjmp	.-10     	; 0x11e <task1_code+0xe>

00000128 <task2_code>:
		
}

/*Task 2 Code*/
 void task2_code(void*pvParamter)
{
     128:	df 93       	push	r29
     12a:	cf 93       	push	r28
     12c:	00 d0       	rcall	.+0      	; 0x12e <task2_code+0x6>
     12e:	cd b7       	in	r28, 0x3d	; 61
     130:	de b7       	in	r29, 0x3e	; 62
     132:	9a 83       	std	Y+2, r25	; 0x02
     134:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		PORTA = 0x00;
     136:	eb e3       	ldi	r30, 0x3B	; 59
     138:	f0 e0       	ldi	r31, 0x00	; 0
     13a:	10 82       	st	Z, r1
     13c:	fc cf       	rjmp	.-8      	; 0x136 <task2_code+0xe>

0000013e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     13e:	df 93       	push	r29
     140:	cf 93       	push	r28
     142:	cd b7       	in	r28, 0x3d	; 61
     144:	de b7       	in	r29, 0x3e	; 62
     146:	27 97       	sbiw	r28, 0x07	; 7
     148:	0f b6       	in	r0, 0x3f	; 63
     14a:	f8 94       	cli
     14c:	de bf       	out	0x3e, r29	; 62
     14e:	0f be       	out	0x3f, r0	; 63
     150:	cd bf       	out	0x3d, r28	; 61
     152:	9d 83       	std	Y+5, r25	; 0x05
     154:	8c 83       	std	Y+4, r24	; 0x04
     156:	6e 83       	std	Y+6, r22	; 0x06
     158:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     15a:	8a e1       	ldi	r24, 0x1A	; 26
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	0e 94 77 03 	call	0x6ee	; 0x6ee <pvPortMalloc>
     162:	9a 83       	std	Y+2, r25	; 0x02
     164:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     166:	89 81       	ldd	r24, Y+1	; 0x01
     168:	9a 81       	ldd	r25, Y+2	; 0x02
     16a:	00 97       	sbiw	r24, 0x00	; 0
     16c:	09 f4       	brne	.+2      	; 0x170 <xCoRoutineCreate+0x32>
     16e:	6f c0       	rjmp	.+222    	; 0x24e <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     170:	80 91 68 00 	lds	r24, 0x0068
     174:	90 91 69 00 	lds	r25, 0x0069
     178:	00 97       	sbiw	r24, 0x00	; 0
     17a:	41 f4       	brne	.+16     	; 0x18c <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     17c:	89 81       	ldd	r24, Y+1	; 0x01
     17e:	9a 81       	ldd	r25, Y+2	; 0x02
     180:	90 93 69 00 	sts	0x0069, r25
     184:	80 93 68 00 	sts	0x0068, r24
			prvInitialiseCoRoutineLists();
     188:	0e 94 06 03 	call	0x60c	; 0x60c <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     18c:	8e 81       	ldd	r24, Y+6	; 0x06
     18e:	82 30       	cpi	r24, 0x02	; 2
     190:	10 f0       	brcs	.+4      	; 0x196 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     192:	81 e0       	ldi	r24, 0x01	; 1
     194:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     196:	e9 81       	ldd	r30, Y+1	; 0x01
     198:	fa 81       	ldd	r31, Y+2	; 0x02
     19a:	11 8e       	std	Z+25, r1	; 0x19
     19c:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     19e:	e9 81       	ldd	r30, Y+1	; 0x01
     1a0:	fa 81       	ldd	r31, Y+2	; 0x02
     1a2:	8e 81       	ldd	r24, Y+6	; 0x06
     1a4:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1a6:	e9 81       	ldd	r30, Y+1	; 0x01
     1a8:	fa 81       	ldd	r31, Y+2	; 0x02
     1aa:	8f 81       	ldd	r24, Y+7	; 0x07
     1ac:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1ae:	e9 81       	ldd	r30, Y+1	; 0x01
     1b0:	fa 81       	ldd	r31, Y+2	; 0x02
     1b2:	8c 81       	ldd	r24, Y+4	; 0x04
     1b4:	9d 81       	ldd	r25, Y+5	; 0x05
     1b6:	91 83       	std	Z+1, r25	; 0x01
     1b8:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	9a 81       	ldd	r25, Y+2	; 0x02
     1be:	02 96       	adiw	r24, 0x02	; 2
     1c0:	0e 94 0d 04 	call	0x81a	; 0x81a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1c4:	89 81       	ldd	r24, Y+1	; 0x01
     1c6:	9a 81       	ldd	r25, Y+2	; 0x02
     1c8:	0c 96       	adiw	r24, 0x0c	; 12
     1ca:	0e 94 0d 04 	call	0x81a	; 0x81a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1ce:	e9 81       	ldd	r30, Y+1	; 0x01
     1d0:	fa 81       	ldd	r31, Y+2	; 0x02
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	9a 81       	ldd	r25, Y+2	; 0x02
     1d6:	91 87       	std	Z+9, r25	; 0x09
     1d8:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1da:	e9 81       	ldd	r30, Y+1	; 0x01
     1dc:	fa 81       	ldd	r31, Y+2	; 0x02
     1de:	89 81       	ldd	r24, Y+1	; 0x01
     1e0:	9a 81       	ldd	r25, Y+2	; 0x02
     1e2:	93 8b       	std	Z+19, r25	; 0x13
     1e4:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     1e6:	8e 81       	ldd	r24, Y+6	; 0x06
     1e8:	28 2f       	mov	r18, r24
     1ea:	30 e0       	ldi	r19, 0x00	; 0
     1ec:	85 e0       	ldi	r24, 0x05	; 5
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	82 1b       	sub	r24, r18
     1f2:	93 0b       	sbc	r25, r19
     1f4:	e9 81       	ldd	r30, Y+1	; 0x01
     1f6:	fa 81       	ldd	r31, Y+2	; 0x02
     1f8:	95 87       	std	Z+13, r25	; 0x0d
     1fa:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     1fc:	e9 81       	ldd	r30, Y+1	; 0x01
     1fe:	fa 81       	ldd	r31, Y+2	; 0x02
     200:	96 89       	ldd	r25, Z+22	; 0x16
     202:	80 91 6a 00 	lds	r24, 0x006A
     206:	89 17       	cp	r24, r25
     208:	28 f4       	brcc	.+10     	; 0x214 <xCoRoutineCreate+0xd6>
     20a:	e9 81       	ldd	r30, Y+1	; 0x01
     20c:	fa 81       	ldd	r31, Y+2	; 0x02
     20e:	86 89       	ldd	r24, Z+22	; 0x16
     210:	80 93 6a 00 	sts	0x006A, r24
     214:	e9 81       	ldd	r30, Y+1	; 0x01
     216:	fa 81       	ldd	r31, Y+2	; 0x02
     218:	86 89       	ldd	r24, Z+22	; 0x16
     21a:	28 2f       	mov	r18, r24
     21c:	30 e0       	ldi	r19, 0x00	; 0
     21e:	c9 01       	movw	r24, r18
     220:	88 0f       	add	r24, r24
     222:	99 1f       	adc	r25, r25
     224:	88 0f       	add	r24, r24
     226:	99 1f       	adc	r25, r25
     228:	88 0f       	add	r24, r24
     22a:	99 1f       	adc	r25, r25
     22c:	82 0f       	add	r24, r18
     22e:	93 1f       	adc	r25, r19
     230:	ac 01       	movw	r20, r24
     232:	4f 58       	subi	r20, 0x8F	; 143
     234:	5f 4f       	sbci	r21, 0xFF	; 255
     236:	89 81       	ldd	r24, Y+1	; 0x01
     238:	9a 81       	ldd	r25, Y+2	; 0x02
     23a:	9c 01       	movw	r18, r24
     23c:	2e 5f       	subi	r18, 0xFE	; 254
     23e:	3f 4f       	sbci	r19, 0xFF	; 255
     240:	ca 01       	movw	r24, r20
     242:	b9 01       	movw	r22, r18
     244:	0e 94 1d 04 	call	0x83a	; 0x83a <vListInsertEnd>

		xReturn = pdPASS;
     248:	81 e0       	ldi	r24, 0x01	; 1
     24a:	8b 83       	std	Y+3, r24	; 0x03
     24c:	02 c0       	rjmp	.+4      	; 0x252 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     24e:	8f ef       	ldi	r24, 0xFF	; 255
     250:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     252:	8b 81       	ldd	r24, Y+3	; 0x03
}
     254:	27 96       	adiw	r28, 0x07	; 7
     256:	0f b6       	in	r0, 0x3f	; 63
     258:	f8 94       	cli
     25a:	de bf       	out	0x3e, r29	; 62
     25c:	0f be       	out	0x3f, r0	; 63
     25e:	cd bf       	out	0x3d, r28	; 61
     260:	cf 91       	pop	r28
     262:	df 91       	pop	r29
     264:	08 95       	ret

00000266 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     266:	df 93       	push	r29
     268:	cf 93       	push	r28
     26a:	00 d0       	rcall	.+0      	; 0x26c <vCoRoutineAddToDelayedList+0x6>
     26c:	00 d0       	rcall	.+0      	; 0x26e <vCoRoutineAddToDelayedList+0x8>
     26e:	00 d0       	rcall	.+0      	; 0x270 <vCoRoutineAddToDelayedList+0xa>
     270:	cd b7       	in	r28, 0x3d	; 61
     272:	de b7       	in	r29, 0x3e	; 62
     274:	9c 83       	std	Y+4, r25	; 0x04
     276:	8b 83       	std	Y+3, r24	; 0x03
     278:	7e 83       	std	Y+6, r23	; 0x06
     27a:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     27c:	20 91 6b 00 	lds	r18, 0x006B
     280:	30 91 6c 00 	lds	r19, 0x006C
     284:	8b 81       	ldd	r24, Y+3	; 0x03
     286:	9c 81       	ldd	r25, Y+4	; 0x04
     288:	82 0f       	add	r24, r18
     28a:	93 1f       	adc	r25, r19
     28c:	9a 83       	std	Y+2, r25	; 0x02
     28e:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     290:	80 91 68 00 	lds	r24, 0x0068
     294:	90 91 69 00 	lds	r25, 0x0069
     298:	02 96       	adiw	r24, 0x02	; 2
     29a:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     29e:	e0 91 68 00 	lds	r30, 0x0068
     2a2:	f0 91 69 00 	lds	r31, 0x0069
     2a6:	89 81       	ldd	r24, Y+1	; 0x01
     2a8:	9a 81       	ldd	r25, Y+2	; 0x02
     2aa:	93 83       	std	Z+3, r25	; 0x03
     2ac:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     2ae:	20 91 6b 00 	lds	r18, 0x006B
     2b2:	30 91 6c 00 	lds	r19, 0x006C
     2b6:	89 81       	ldd	r24, Y+1	; 0x01
     2b8:	9a 81       	ldd	r25, Y+2	; 0x02
     2ba:	82 17       	cp	r24, r18
     2bc:	93 07       	cpc	r25, r19
     2be:	70 f4       	brcc	.+28     	; 0x2dc <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2c0:	80 91 97 00 	lds	r24, 0x0097
     2c4:	90 91 98 00 	lds	r25, 0x0098
     2c8:	20 91 68 00 	lds	r18, 0x0068
     2cc:	30 91 69 00 	lds	r19, 0x0069
     2d0:	2e 5f       	subi	r18, 0xFE	; 254
     2d2:	3f 4f       	sbci	r19, 0xFF	; 255
     2d4:	b9 01       	movw	r22, r18
     2d6:	0e 94 69 04 	call	0x8d2	; 0x8d2 <vListInsert>
     2da:	0d c0       	rjmp	.+26     	; 0x2f6 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2dc:	80 91 95 00 	lds	r24, 0x0095
     2e0:	90 91 96 00 	lds	r25, 0x0096
     2e4:	20 91 68 00 	lds	r18, 0x0068
     2e8:	30 91 69 00 	lds	r19, 0x0069
     2ec:	2e 5f       	subi	r18, 0xFE	; 254
     2ee:	3f 4f       	sbci	r19, 0xFF	; 255
     2f0:	b9 01       	movw	r22, r18
     2f2:	0e 94 69 04 	call	0x8d2	; 0x8d2 <vListInsert>
	}

	if( pxEventList )
     2f6:	8d 81       	ldd	r24, Y+5	; 0x05
     2f8:	9e 81       	ldd	r25, Y+6	; 0x06
     2fa:	00 97       	sbiw	r24, 0x00	; 0
     2fc:	61 f0       	breq	.+24     	; 0x316 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     2fe:	80 91 68 00 	lds	r24, 0x0068
     302:	90 91 69 00 	lds	r25, 0x0069
     306:	9c 01       	movw	r18, r24
     308:	24 5f       	subi	r18, 0xF4	; 244
     30a:	3f 4f       	sbci	r19, 0xFF	; 255
     30c:	8d 81       	ldd	r24, Y+5	; 0x05
     30e:	9e 81       	ldd	r25, Y+6	; 0x06
     310:	b9 01       	movw	r22, r18
     312:	0e 94 69 04 	call	0x8d2	; 0x8d2 <vListInsert>
	}
}
     316:	26 96       	adiw	r28, 0x06	; 6
     318:	0f b6       	in	r0, 0x3f	; 63
     31a:	f8 94       	cli
     31c:	de bf       	out	0x3e, r29	; 62
     31e:	0f be       	out	0x3f, r0	; 63
     320:	cd bf       	out	0x3d, r28	; 61
     322:	cf 91       	pop	r28
     324:	df 91       	pop	r29
     326:	08 95       	ret

00000328 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     328:	df 93       	push	r29
     32a:	cf 93       	push	r28
     32c:	00 d0       	rcall	.+0      	; 0x32e <prvCheckPendingReadyList+0x6>
     32e:	cd b7       	in	r28, 0x3d	; 61
     330:	de b7       	in	r29, 0x3e	; 62
     332:	3a c0       	rjmp	.+116    	; 0x3a8 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     334:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     336:	e0 91 9e 00 	lds	r30, 0x009E
     33a:	f0 91 9f 00 	lds	r31, 0x009F
     33e:	86 81       	ldd	r24, Z+6	; 0x06
     340:	97 81       	ldd	r25, Z+7	; 0x07
     342:	9a 83       	std	Y+2, r25	; 0x02
     344:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     346:	89 81       	ldd	r24, Y+1	; 0x01
     348:	9a 81       	ldd	r25, Y+2	; 0x02
     34a:	0c 96       	adiw	r24, 0x0c	; 12
     34c:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
		}
		portENABLE_INTERRUPTS();
     350:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     352:	89 81       	ldd	r24, Y+1	; 0x01
     354:	9a 81       	ldd	r25, Y+2	; 0x02
     356:	02 96       	adiw	r24, 0x02	; 2
     358:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     35c:	e9 81       	ldd	r30, Y+1	; 0x01
     35e:	fa 81       	ldd	r31, Y+2	; 0x02
     360:	96 89       	ldd	r25, Z+22	; 0x16
     362:	80 91 6a 00 	lds	r24, 0x006A
     366:	89 17       	cp	r24, r25
     368:	28 f4       	brcc	.+10     	; 0x374 <prvCheckPendingReadyList+0x4c>
     36a:	e9 81       	ldd	r30, Y+1	; 0x01
     36c:	fa 81       	ldd	r31, Y+2	; 0x02
     36e:	86 89       	ldd	r24, Z+22	; 0x16
     370:	80 93 6a 00 	sts	0x006A, r24
     374:	e9 81       	ldd	r30, Y+1	; 0x01
     376:	fa 81       	ldd	r31, Y+2	; 0x02
     378:	86 89       	ldd	r24, Z+22	; 0x16
     37a:	28 2f       	mov	r18, r24
     37c:	30 e0       	ldi	r19, 0x00	; 0
     37e:	c9 01       	movw	r24, r18
     380:	88 0f       	add	r24, r24
     382:	99 1f       	adc	r25, r25
     384:	88 0f       	add	r24, r24
     386:	99 1f       	adc	r25, r25
     388:	88 0f       	add	r24, r24
     38a:	99 1f       	adc	r25, r25
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	ac 01       	movw	r20, r24
     392:	4f 58       	subi	r20, 0x8F	; 143
     394:	5f 4f       	sbci	r21, 0xFF	; 255
     396:	89 81       	ldd	r24, Y+1	; 0x01
     398:	9a 81       	ldd	r25, Y+2	; 0x02
     39a:	9c 01       	movw	r18, r24
     39c:	2e 5f       	subi	r18, 0xFE	; 254
     39e:	3f 4f       	sbci	r19, 0xFF	; 255
     3a0:	ca 01       	movw	r24, r20
     3a2:	b9 01       	movw	r22, r18
     3a4:	0e 94 1d 04 	call	0x83a	; 0x83a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     3a8:	80 91 99 00 	lds	r24, 0x0099
     3ac:	88 23       	and	r24, r24
     3ae:	09 f0       	breq	.+2      	; 0x3b2 <prvCheckPendingReadyList+0x8a>
     3b0:	c1 cf       	rjmp	.-126    	; 0x334 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     3b2:	0f 90       	pop	r0
     3b4:	0f 90       	pop	r0
     3b6:	cf 91       	pop	r28
     3b8:	df 91       	pop	r29
     3ba:	08 95       	ret

000003bc <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     3bc:	df 93       	push	r29
     3be:	cf 93       	push	r28
     3c0:	00 d0       	rcall	.+0      	; 0x3c2 <prvCheckDelayedList+0x6>
     3c2:	00 d0       	rcall	.+0      	; 0x3c4 <prvCheckDelayedList+0x8>
     3c4:	cd b7       	in	r28, 0x3d	; 61
     3c6:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     3c8:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <xTaskGetTickCount>
     3cc:	20 91 6d 00 	lds	r18, 0x006D
     3d0:	30 91 6e 00 	lds	r19, 0x006E
     3d4:	82 1b       	sub	r24, r18
     3d6:	93 0b       	sbc	r25, r19
     3d8:	90 93 70 00 	sts	0x0070, r25
     3dc:	80 93 6f 00 	sts	0x006F, r24
     3e0:	85 c0       	rjmp	.+266    	; 0x4ec <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     3e2:	80 91 6b 00 	lds	r24, 0x006B
     3e6:	90 91 6c 00 	lds	r25, 0x006C
     3ea:	01 96       	adiw	r24, 0x01	; 1
     3ec:	90 93 6c 00 	sts	0x006C, r25
     3f0:	80 93 6b 00 	sts	0x006B, r24
		xPassedTicks--;
     3f4:	80 91 6f 00 	lds	r24, 0x006F
     3f8:	90 91 70 00 	lds	r25, 0x0070
     3fc:	01 97       	sbiw	r24, 0x01	; 1
     3fe:	90 93 70 00 	sts	0x0070, r25
     402:	80 93 6f 00 	sts	0x006F, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     406:	80 91 6b 00 	lds	r24, 0x006B
     40a:	90 91 6c 00 	lds	r25, 0x006C
     40e:	00 97       	sbiw	r24, 0x00	; 0
     410:	09 f0       	breq	.+2      	; 0x414 <prvCheckDelayedList+0x58>
     412:	64 c0       	rjmp	.+200    	; 0x4dc <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     414:	80 91 95 00 	lds	r24, 0x0095
     418:	90 91 96 00 	lds	r25, 0x0096
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     420:	80 91 97 00 	lds	r24, 0x0097
     424:	90 91 98 00 	lds	r25, 0x0098
     428:	90 93 96 00 	sts	0x0096, r25
     42c:	80 93 95 00 	sts	0x0095, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     430:	89 81       	ldd	r24, Y+1	; 0x01
     432:	9a 81       	ldd	r25, Y+2	; 0x02
     434:	90 93 98 00 	sts	0x0098, r25
     438:	80 93 97 00 	sts	0x0097, r24
     43c:	4f c0       	rjmp	.+158    	; 0x4dc <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     43e:	e0 91 95 00 	lds	r30, 0x0095
     442:	f0 91 96 00 	lds	r31, 0x0096
     446:	05 80       	ldd	r0, Z+5	; 0x05
     448:	f6 81       	ldd	r31, Z+6	; 0x06
     44a:	e0 2d       	mov	r30, r0
     44c:	86 81       	ldd	r24, Z+6	; 0x06
     44e:	97 81       	ldd	r25, Z+7	; 0x07
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     454:	eb 81       	ldd	r30, Y+3	; 0x03
     456:	fc 81       	ldd	r31, Y+4	; 0x04
     458:	22 81       	ldd	r18, Z+2	; 0x02
     45a:	33 81       	ldd	r19, Z+3	; 0x03
     45c:	80 91 6b 00 	lds	r24, 0x006B
     460:	90 91 6c 00 	lds	r25, 0x006C
     464:	82 17       	cp	r24, r18
     466:	93 07       	cpc	r25, r19
     468:	08 f4       	brcc	.+2      	; 0x46c <prvCheckDelayedList+0xb0>
     46a:	40 c0       	rjmp	.+128    	; 0x4ec <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     46c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     46e:	8b 81       	ldd	r24, Y+3	; 0x03
     470:	9c 81       	ldd	r25, Y+4	; 0x04
     472:	02 96       	adiw	r24, 0x02	; 2
     474:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     478:	eb 81       	ldd	r30, Y+3	; 0x03
     47a:	fc 81       	ldd	r31, Y+4	; 0x04
     47c:	84 89       	ldd	r24, Z+20	; 0x14
     47e:	95 89       	ldd	r25, Z+21	; 0x15
     480:	00 97       	sbiw	r24, 0x00	; 0
     482:	29 f0       	breq	.+10     	; 0x48e <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     484:	8b 81       	ldd	r24, Y+3	; 0x03
     486:	9c 81       	ldd	r25, Y+4	; 0x04
     488:	0c 96       	adiw	r24, 0x0c	; 12
     48a:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     48e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     490:	eb 81       	ldd	r30, Y+3	; 0x03
     492:	fc 81       	ldd	r31, Y+4	; 0x04
     494:	96 89       	ldd	r25, Z+22	; 0x16
     496:	80 91 6a 00 	lds	r24, 0x006A
     49a:	89 17       	cp	r24, r25
     49c:	28 f4       	brcc	.+10     	; 0x4a8 <prvCheckDelayedList+0xec>
     49e:	eb 81       	ldd	r30, Y+3	; 0x03
     4a0:	fc 81       	ldd	r31, Y+4	; 0x04
     4a2:	86 89       	ldd	r24, Z+22	; 0x16
     4a4:	80 93 6a 00 	sts	0x006A, r24
     4a8:	eb 81       	ldd	r30, Y+3	; 0x03
     4aa:	fc 81       	ldd	r31, Y+4	; 0x04
     4ac:	86 89       	ldd	r24, Z+22	; 0x16
     4ae:	28 2f       	mov	r18, r24
     4b0:	30 e0       	ldi	r19, 0x00	; 0
     4b2:	c9 01       	movw	r24, r18
     4b4:	88 0f       	add	r24, r24
     4b6:	99 1f       	adc	r25, r25
     4b8:	88 0f       	add	r24, r24
     4ba:	99 1f       	adc	r25, r25
     4bc:	88 0f       	add	r24, r24
     4be:	99 1f       	adc	r25, r25
     4c0:	82 0f       	add	r24, r18
     4c2:	93 1f       	adc	r25, r19
     4c4:	ac 01       	movw	r20, r24
     4c6:	4f 58       	subi	r20, 0x8F	; 143
     4c8:	5f 4f       	sbci	r21, 0xFF	; 255
     4ca:	8b 81       	ldd	r24, Y+3	; 0x03
     4cc:	9c 81       	ldd	r25, Y+4	; 0x04
     4ce:	9c 01       	movw	r18, r24
     4d0:	2e 5f       	subi	r18, 0xFE	; 254
     4d2:	3f 4f       	sbci	r19, 0xFF	; 255
     4d4:	ca 01       	movw	r24, r20
     4d6:	b9 01       	movw	r22, r18
     4d8:	0e 94 1d 04 	call	0x83a	; 0x83a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     4dc:	e0 91 95 00 	lds	r30, 0x0095
     4e0:	f0 91 96 00 	lds	r31, 0x0096
     4e4:	80 81       	ld	r24, Z
     4e6:	88 23       	and	r24, r24
     4e8:	09 f0       	breq	.+2      	; 0x4ec <prvCheckDelayedList+0x130>
     4ea:	a9 cf       	rjmp	.-174    	; 0x43e <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     4ec:	80 91 6f 00 	lds	r24, 0x006F
     4f0:	90 91 70 00 	lds	r25, 0x0070
     4f4:	00 97       	sbiw	r24, 0x00	; 0
     4f6:	09 f0       	breq	.+2      	; 0x4fa <prvCheckDelayedList+0x13e>
     4f8:	74 cf       	rjmp	.-280    	; 0x3e2 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     4fa:	80 91 6b 00 	lds	r24, 0x006B
     4fe:	90 91 6c 00 	lds	r25, 0x006C
     502:	90 93 6e 00 	sts	0x006E, r25
     506:	80 93 6d 00 	sts	0x006D, r24
}
     50a:	0f 90       	pop	r0
     50c:	0f 90       	pop	r0
     50e:	0f 90       	pop	r0
     510:	0f 90       	pop	r0
     512:	cf 91       	pop	r28
     514:	df 91       	pop	r29
     516:	08 95       	ret

00000518 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     518:	df 93       	push	r29
     51a:	cf 93       	push	r28
     51c:	00 d0       	rcall	.+0      	; 0x51e <vCoRoutineSchedule+0x6>
     51e:	cd b7       	in	r28, 0x3d	; 61
     520:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     522:	0e 94 94 01 	call	0x328	; 0x328 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     526:	0e 94 de 01 	call	0x3bc	; 0x3bc <prvCheckDelayedList>
     52a:	0a c0       	rjmp	.+20     	; 0x540 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     52c:	80 91 6a 00 	lds	r24, 0x006A
     530:	88 23       	and	r24, r24
     532:	09 f4       	brne	.+2      	; 0x536 <vCoRoutineSchedule+0x1e>
     534:	66 c0       	rjmp	.+204    	; 0x602 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     536:	80 91 6a 00 	lds	r24, 0x006A
     53a:	81 50       	subi	r24, 0x01	; 1
     53c:	80 93 6a 00 	sts	0x006A, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     540:	80 91 6a 00 	lds	r24, 0x006A
     544:	28 2f       	mov	r18, r24
     546:	30 e0       	ldi	r19, 0x00	; 0
     548:	c9 01       	movw	r24, r18
     54a:	88 0f       	add	r24, r24
     54c:	99 1f       	adc	r25, r25
     54e:	88 0f       	add	r24, r24
     550:	99 1f       	adc	r25, r25
     552:	88 0f       	add	r24, r24
     554:	99 1f       	adc	r25, r25
     556:	82 0f       	add	r24, r18
     558:	93 1f       	adc	r25, r19
     55a:	fc 01       	movw	r30, r24
     55c:	ef 58       	subi	r30, 0x8F	; 143
     55e:	ff 4f       	sbci	r31, 0xFF	; 255
     560:	80 81       	ld	r24, Z
     562:	88 23       	and	r24, r24
     564:	19 f3       	breq	.-58     	; 0x52c <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     566:	80 91 6a 00 	lds	r24, 0x006A
     56a:	28 2f       	mov	r18, r24
     56c:	30 e0       	ldi	r19, 0x00	; 0
     56e:	c9 01       	movw	r24, r18
     570:	88 0f       	add	r24, r24
     572:	99 1f       	adc	r25, r25
     574:	88 0f       	add	r24, r24
     576:	99 1f       	adc	r25, r25
     578:	88 0f       	add	r24, r24
     57a:	99 1f       	adc	r25, r25
     57c:	82 0f       	add	r24, r18
     57e:	93 1f       	adc	r25, r19
     580:	8f 58       	subi	r24, 0x8F	; 143
     582:	9f 4f       	sbci	r25, 0xFF	; 255
     584:	9a 83       	std	Y+2, r25	; 0x02
     586:	89 83       	std	Y+1, r24	; 0x01
     588:	e9 81       	ldd	r30, Y+1	; 0x01
     58a:	fa 81       	ldd	r31, Y+2	; 0x02
     58c:	01 80       	ldd	r0, Z+1	; 0x01
     58e:	f2 81       	ldd	r31, Z+2	; 0x02
     590:	e0 2d       	mov	r30, r0
     592:	82 81       	ldd	r24, Z+2	; 0x02
     594:	93 81       	ldd	r25, Z+3	; 0x03
     596:	e9 81       	ldd	r30, Y+1	; 0x01
     598:	fa 81       	ldd	r31, Y+2	; 0x02
     59a:	92 83       	std	Z+2, r25	; 0x02
     59c:	81 83       	std	Z+1, r24	; 0x01
     59e:	e9 81       	ldd	r30, Y+1	; 0x01
     5a0:	fa 81       	ldd	r31, Y+2	; 0x02
     5a2:	21 81       	ldd	r18, Z+1	; 0x01
     5a4:	32 81       	ldd	r19, Z+2	; 0x02
     5a6:	89 81       	ldd	r24, Y+1	; 0x01
     5a8:	9a 81       	ldd	r25, Y+2	; 0x02
     5aa:	03 96       	adiw	r24, 0x03	; 3
     5ac:	28 17       	cp	r18, r24
     5ae:	39 07       	cpc	r19, r25
     5b0:	59 f4       	brne	.+22     	; 0x5c8 <vCoRoutineSchedule+0xb0>
     5b2:	e9 81       	ldd	r30, Y+1	; 0x01
     5b4:	fa 81       	ldd	r31, Y+2	; 0x02
     5b6:	01 80       	ldd	r0, Z+1	; 0x01
     5b8:	f2 81       	ldd	r31, Z+2	; 0x02
     5ba:	e0 2d       	mov	r30, r0
     5bc:	82 81       	ldd	r24, Z+2	; 0x02
     5be:	93 81       	ldd	r25, Z+3	; 0x03
     5c0:	e9 81       	ldd	r30, Y+1	; 0x01
     5c2:	fa 81       	ldd	r31, Y+2	; 0x02
     5c4:	92 83       	std	Z+2, r25	; 0x02
     5c6:	81 83       	std	Z+1, r24	; 0x01
     5c8:	e9 81       	ldd	r30, Y+1	; 0x01
     5ca:	fa 81       	ldd	r31, Y+2	; 0x02
     5cc:	01 80       	ldd	r0, Z+1	; 0x01
     5ce:	f2 81       	ldd	r31, Z+2	; 0x02
     5d0:	e0 2d       	mov	r30, r0
     5d2:	86 81       	ldd	r24, Z+6	; 0x06
     5d4:	97 81       	ldd	r25, Z+7	; 0x07
     5d6:	90 93 69 00 	sts	0x0069, r25
     5da:	80 93 68 00 	sts	0x0068, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     5de:	e0 91 68 00 	lds	r30, 0x0068
     5e2:	f0 91 69 00 	lds	r31, 0x0069
     5e6:	40 81       	ld	r20, Z
     5e8:	51 81       	ldd	r21, Z+1	; 0x01
     5ea:	80 91 68 00 	lds	r24, 0x0068
     5ee:	90 91 69 00 	lds	r25, 0x0069
     5f2:	e0 91 68 00 	lds	r30, 0x0068
     5f6:	f0 91 69 00 	lds	r31, 0x0069
     5fa:	27 89       	ldd	r18, Z+23	; 0x17
     5fc:	62 2f       	mov	r22, r18
     5fe:	fa 01       	movw	r30, r20
     600:	09 95       	icall

	return;
}
     602:	0f 90       	pop	r0
     604:	0f 90       	pop	r0
     606:	cf 91       	pop	r28
     608:	df 91       	pop	r29
     60a:	08 95       	ret

0000060c <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     60c:	df 93       	push	r29
     60e:	cf 93       	push	r28
     610:	0f 92       	push	r0
     612:	cd b7       	in	r28, 0x3d	; 61
     614:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     616:	19 82       	std	Y+1, r1	; 0x01
     618:	13 c0       	rjmp	.+38     	; 0x640 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     61a:	89 81       	ldd	r24, Y+1	; 0x01
     61c:	28 2f       	mov	r18, r24
     61e:	30 e0       	ldi	r19, 0x00	; 0
     620:	c9 01       	movw	r24, r18
     622:	88 0f       	add	r24, r24
     624:	99 1f       	adc	r25, r25
     626:	88 0f       	add	r24, r24
     628:	99 1f       	adc	r25, r25
     62a:	88 0f       	add	r24, r24
     62c:	99 1f       	adc	r25, r25
     62e:	82 0f       	add	r24, r18
     630:	93 1f       	adc	r25, r19
     632:	8f 58       	subi	r24, 0x8F	; 143
     634:	9f 4f       	sbci	r25, 0xFF	; 255
     636:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     63a:	89 81       	ldd	r24, Y+1	; 0x01
     63c:	8f 5f       	subi	r24, 0xFF	; 255
     63e:	89 83       	std	Y+1, r24	; 0x01
     640:	89 81       	ldd	r24, Y+1	; 0x01
     642:	82 30       	cpi	r24, 0x02	; 2
     644:	50 f3       	brcs	.-44     	; 0x61a <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     646:	83 e8       	ldi	r24, 0x83	; 131
     648:	90 e0       	ldi	r25, 0x00	; 0
     64a:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     64e:	8c e8       	ldi	r24, 0x8C	; 140
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     656:	89 e9       	ldi	r24, 0x99	; 153
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     65e:	83 e8       	ldi	r24, 0x83	; 131
     660:	90 e0       	ldi	r25, 0x00	; 0
     662:	90 93 96 00 	sts	0x0096, r25
     666:	80 93 95 00 	sts	0x0095, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     66a:	8c e8       	ldi	r24, 0x8C	; 140
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	90 93 98 00 	sts	0x0098, r25
     672:	80 93 97 00 	sts	0x0097, r24
}
     676:	0f 90       	pop	r0
     678:	cf 91       	pop	r28
     67a:	df 91       	pop	r29
     67c:	08 95       	ret

0000067e <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     67e:	df 93       	push	r29
     680:	cf 93       	push	r28
     682:	00 d0       	rcall	.+0      	; 0x684 <xCoRoutineRemoveFromEventList+0x6>
     684:	00 d0       	rcall	.+0      	; 0x686 <xCoRoutineRemoveFromEventList+0x8>
     686:	0f 92       	push	r0
     688:	cd b7       	in	r28, 0x3d	; 61
     68a:	de b7       	in	r29, 0x3e	; 62
     68c:	9d 83       	std	Y+5, r25	; 0x05
     68e:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     690:	ec 81       	ldd	r30, Y+4	; 0x04
     692:	fd 81       	ldd	r31, Y+5	; 0x05
     694:	05 80       	ldd	r0, Z+5	; 0x05
     696:	f6 81       	ldd	r31, Z+6	; 0x06
     698:	e0 2d       	mov	r30, r0
     69a:	86 81       	ldd	r24, Z+6	; 0x06
     69c:	97 81       	ldd	r25, Z+7	; 0x07
     69e:	9b 83       	std	Y+3, r25	; 0x03
     6a0:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     6a2:	8a 81       	ldd	r24, Y+2	; 0x02
     6a4:	9b 81       	ldd	r25, Y+3	; 0x03
     6a6:	0c 96       	adiw	r24, 0x0c	; 12
     6a8:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     6ac:	8a 81       	ldd	r24, Y+2	; 0x02
     6ae:	9b 81       	ldd	r25, Y+3	; 0x03
     6b0:	9c 01       	movw	r18, r24
     6b2:	24 5f       	subi	r18, 0xF4	; 244
     6b4:	3f 4f       	sbci	r19, 0xFF	; 255
     6b6:	89 e9       	ldi	r24, 0x99	; 153
     6b8:	90 e0       	ldi	r25, 0x00	; 0
     6ba:	b9 01       	movw	r22, r18
     6bc:	0e 94 1d 04 	call	0x83a	; 0x83a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     6c0:	ea 81       	ldd	r30, Y+2	; 0x02
     6c2:	fb 81       	ldd	r31, Y+3	; 0x03
     6c4:	96 89       	ldd	r25, Z+22	; 0x16
     6c6:	e0 91 68 00 	lds	r30, 0x0068
     6ca:	f0 91 69 00 	lds	r31, 0x0069
     6ce:	86 89       	ldd	r24, Z+22	; 0x16
     6d0:	98 17       	cp	r25, r24
     6d2:	18 f0       	brcs	.+6      	; 0x6da <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     6d4:	81 e0       	ldi	r24, 0x01	; 1
     6d6:	89 83       	std	Y+1, r24	; 0x01
     6d8:	01 c0       	rjmp	.+2      	; 0x6dc <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     6da:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     6dc:	89 81       	ldd	r24, Y+1	; 0x01
}
     6de:	0f 90       	pop	r0
     6e0:	0f 90       	pop	r0
     6e2:	0f 90       	pop	r0
     6e4:	0f 90       	pop	r0
     6e6:	0f 90       	pop	r0
     6e8:	cf 91       	pop	r28
     6ea:	df 91       	pop	r29
     6ec:	08 95       	ret

000006ee <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     6ee:	df 93       	push	r29
     6f0:	cf 93       	push	r28
     6f2:	00 d0       	rcall	.+0      	; 0x6f4 <pvPortMalloc+0x6>
     6f4:	00 d0       	rcall	.+0      	; 0x6f6 <pvPortMalloc+0x8>
     6f6:	cd b7       	in	r28, 0x3d	; 61
     6f8:	de b7       	in	r29, 0x3e	; 62
     6fa:	9c 83       	std	Y+4, r25	; 0x04
     6fc:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     6fe:	1a 82       	std	Y+2, r1	; 0x02
     700:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     702:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     706:	80 91 a2 00 	lds	r24, 0x00A2
     70a:	90 91 a3 00 	lds	r25, 0x00A3
     70e:	2b 81       	ldd	r18, Y+3	; 0x03
     710:	3c 81       	ldd	r19, Y+4	; 0x04
     712:	82 0f       	add	r24, r18
     714:	93 1f       	adc	r25, r19
     716:	22 e0       	ldi	r18, 0x02	; 2
     718:	88 35       	cpi	r24, 0x58	; 88
     71a:	92 07       	cpc	r25, r18
     71c:	18 f5       	brcc	.+70     	; 0x764 <pvPortMalloc+0x76>
     71e:	20 91 a2 00 	lds	r18, 0x00A2
     722:	30 91 a3 00 	lds	r19, 0x00A3
     726:	8b 81       	ldd	r24, Y+3	; 0x03
     728:	9c 81       	ldd	r25, Y+4	; 0x04
     72a:	28 0f       	add	r18, r24
     72c:	39 1f       	adc	r19, r25
     72e:	80 91 a2 00 	lds	r24, 0x00A2
     732:	90 91 a3 00 	lds	r25, 0x00A3
     736:	82 17       	cp	r24, r18
     738:	93 07       	cpc	r25, r19
     73a:	a0 f4       	brcc	.+40     	; 0x764 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     73c:	80 91 a2 00 	lds	r24, 0x00A2
     740:	90 91 a3 00 	lds	r25, 0x00A3
     744:	8c 55       	subi	r24, 0x5C	; 92
     746:	9f 4f       	sbci	r25, 0xFF	; 255
     748:	9a 83       	std	Y+2, r25	; 0x02
     74a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     74c:	20 91 a2 00 	lds	r18, 0x00A2
     750:	30 91 a3 00 	lds	r19, 0x00A3
     754:	8b 81       	ldd	r24, Y+3	; 0x03
     756:	9c 81       	ldd	r25, Y+4	; 0x04
     758:	82 0f       	add	r24, r18
     75a:	93 1f       	adc	r25, r19
     75c:	90 93 a3 00 	sts	0x00A3, r25
     760:	80 93 a2 00 	sts	0x00A2, r24
		}	
	}
	xTaskResumeAll();
     764:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     768:	89 81       	ldd	r24, Y+1	; 0x01
     76a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     76c:	0f 90       	pop	r0
     76e:	0f 90       	pop	r0
     770:	0f 90       	pop	r0
     772:	0f 90       	pop	r0
     774:	cf 91       	pop	r28
     776:	df 91       	pop	r29
     778:	08 95       	ret

0000077a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     77a:	df 93       	push	r29
     77c:	cf 93       	push	r28
     77e:	00 d0       	rcall	.+0      	; 0x780 <vPortFree+0x6>
     780:	cd b7       	in	r28, 0x3d	; 61
     782:	de b7       	in	r29, 0x3e	; 62
     784:	9a 83       	std	Y+2, r25	; 0x02
     786:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     788:	0f 90       	pop	r0
     78a:	0f 90       	pop	r0
     78c:	cf 91       	pop	r28
     78e:	df 91       	pop	r29
     790:	08 95       	ret

00000792 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     792:	df 93       	push	r29
     794:	cf 93       	push	r28
     796:	cd b7       	in	r28, 0x3d	; 61
     798:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     79a:	10 92 a3 00 	sts	0x00A3, r1
     79e:	10 92 a2 00 	sts	0x00A2, r1
}
     7a2:	cf 91       	pop	r28
     7a4:	df 91       	pop	r29
     7a6:	08 95       	ret

000007a8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     7a8:	df 93       	push	r29
     7aa:	cf 93       	push	r28
     7ac:	cd b7       	in	r28, 0x3d	; 61
     7ae:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     7b0:	20 91 a2 00 	lds	r18, 0x00A2
     7b4:	30 91 a3 00 	lds	r19, 0x00A3
     7b8:	88 e5       	ldi	r24, 0x58	; 88
     7ba:	92 e0       	ldi	r25, 0x02	; 2
     7bc:	82 1b       	sub	r24, r18
     7be:	93 0b       	sbc	r25, r19
}
     7c0:	cf 91       	pop	r28
     7c2:	df 91       	pop	r29
     7c4:	08 95       	ret

000007c6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     7c6:	df 93       	push	r29
     7c8:	cf 93       	push	r28
     7ca:	00 d0       	rcall	.+0      	; 0x7cc <vListInitialise+0x6>
     7cc:	cd b7       	in	r28, 0x3d	; 61
     7ce:	de b7       	in	r29, 0x3e	; 62
     7d0:	9a 83       	std	Y+2, r25	; 0x02
     7d2:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     7d4:	89 81       	ldd	r24, Y+1	; 0x01
     7d6:	9a 81       	ldd	r25, Y+2	; 0x02
     7d8:	03 96       	adiw	r24, 0x03	; 3
     7da:	e9 81       	ldd	r30, Y+1	; 0x01
     7dc:	fa 81       	ldd	r31, Y+2	; 0x02
     7de:	92 83       	std	Z+2, r25	; 0x02
     7e0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     7e2:	e9 81       	ldd	r30, Y+1	; 0x01
     7e4:	fa 81       	ldd	r31, Y+2	; 0x02
     7e6:	8f ef       	ldi	r24, 0xFF	; 255
     7e8:	9f ef       	ldi	r25, 0xFF	; 255
     7ea:	94 83       	std	Z+4, r25	; 0x04
     7ec:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     7ee:	89 81       	ldd	r24, Y+1	; 0x01
     7f0:	9a 81       	ldd	r25, Y+2	; 0x02
     7f2:	03 96       	adiw	r24, 0x03	; 3
     7f4:	e9 81       	ldd	r30, Y+1	; 0x01
     7f6:	fa 81       	ldd	r31, Y+2	; 0x02
     7f8:	96 83       	std	Z+6, r25	; 0x06
     7fa:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     7fc:	89 81       	ldd	r24, Y+1	; 0x01
     7fe:	9a 81       	ldd	r25, Y+2	; 0x02
     800:	03 96       	adiw	r24, 0x03	; 3
     802:	e9 81       	ldd	r30, Y+1	; 0x01
     804:	fa 81       	ldd	r31, Y+2	; 0x02
     806:	90 87       	std	Z+8, r25	; 0x08
     808:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     80a:	e9 81       	ldd	r30, Y+1	; 0x01
     80c:	fa 81       	ldd	r31, Y+2	; 0x02
     80e:	10 82       	st	Z, r1
}
     810:	0f 90       	pop	r0
     812:	0f 90       	pop	r0
     814:	cf 91       	pop	r28
     816:	df 91       	pop	r29
     818:	08 95       	ret

0000081a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     81a:	df 93       	push	r29
     81c:	cf 93       	push	r28
     81e:	00 d0       	rcall	.+0      	; 0x820 <vListInitialiseItem+0x6>
     820:	cd b7       	in	r28, 0x3d	; 61
     822:	de b7       	in	r29, 0x3e	; 62
     824:	9a 83       	std	Y+2, r25	; 0x02
     826:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     828:	e9 81       	ldd	r30, Y+1	; 0x01
     82a:	fa 81       	ldd	r31, Y+2	; 0x02
     82c:	11 86       	std	Z+9, r1	; 0x09
     82e:	10 86       	std	Z+8, r1	; 0x08
}
     830:	0f 90       	pop	r0
     832:	0f 90       	pop	r0
     834:	cf 91       	pop	r28
     836:	df 91       	pop	r29
     838:	08 95       	ret

0000083a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     83a:	df 93       	push	r29
     83c:	cf 93       	push	r28
     83e:	00 d0       	rcall	.+0      	; 0x840 <vListInsertEnd+0x6>
     840:	00 d0       	rcall	.+0      	; 0x842 <vListInsertEnd+0x8>
     842:	00 d0       	rcall	.+0      	; 0x844 <vListInsertEnd+0xa>
     844:	cd b7       	in	r28, 0x3d	; 61
     846:	de b7       	in	r29, 0x3e	; 62
     848:	9c 83       	std	Y+4, r25	; 0x04
     84a:	8b 83       	std	Y+3, r24	; 0x03
     84c:	7e 83       	std	Y+6, r23	; 0x06
     84e:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     850:	eb 81       	ldd	r30, Y+3	; 0x03
     852:	fc 81       	ldd	r31, Y+4	; 0x04
     854:	81 81       	ldd	r24, Z+1	; 0x01
     856:	92 81       	ldd	r25, Z+2	; 0x02
     858:	9a 83       	std	Y+2, r25	; 0x02
     85a:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     85c:	e9 81       	ldd	r30, Y+1	; 0x01
     85e:	fa 81       	ldd	r31, Y+2	; 0x02
     860:	82 81       	ldd	r24, Z+2	; 0x02
     862:	93 81       	ldd	r25, Z+3	; 0x03
     864:	ed 81       	ldd	r30, Y+5	; 0x05
     866:	fe 81       	ldd	r31, Y+6	; 0x06
     868:	93 83       	std	Z+3, r25	; 0x03
     86a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     86c:	eb 81       	ldd	r30, Y+3	; 0x03
     86e:	fc 81       	ldd	r31, Y+4	; 0x04
     870:	81 81       	ldd	r24, Z+1	; 0x01
     872:	92 81       	ldd	r25, Z+2	; 0x02
     874:	ed 81       	ldd	r30, Y+5	; 0x05
     876:	fe 81       	ldd	r31, Y+6	; 0x06
     878:	95 83       	std	Z+5, r25	; 0x05
     87a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     87c:	e9 81       	ldd	r30, Y+1	; 0x01
     87e:	fa 81       	ldd	r31, Y+2	; 0x02
     880:	02 80       	ldd	r0, Z+2	; 0x02
     882:	f3 81       	ldd	r31, Z+3	; 0x03
     884:	e0 2d       	mov	r30, r0
     886:	8d 81       	ldd	r24, Y+5	; 0x05
     888:	9e 81       	ldd	r25, Y+6	; 0x06
     88a:	95 83       	std	Z+5, r25	; 0x05
     88c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     88e:	8d 81       	ldd	r24, Y+5	; 0x05
     890:	9e 81       	ldd	r25, Y+6	; 0x06
     892:	e9 81       	ldd	r30, Y+1	; 0x01
     894:	fa 81       	ldd	r31, Y+2	; 0x02
     896:	93 83       	std	Z+3, r25	; 0x03
     898:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     89a:	8d 81       	ldd	r24, Y+5	; 0x05
     89c:	9e 81       	ldd	r25, Y+6	; 0x06
     89e:	eb 81       	ldd	r30, Y+3	; 0x03
     8a0:	fc 81       	ldd	r31, Y+4	; 0x04
     8a2:	92 83       	std	Z+2, r25	; 0x02
     8a4:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8a6:	ed 81       	ldd	r30, Y+5	; 0x05
     8a8:	fe 81       	ldd	r31, Y+6	; 0x06
     8aa:	8b 81       	ldd	r24, Y+3	; 0x03
     8ac:	9c 81       	ldd	r25, Y+4	; 0x04
     8ae:	91 87       	std	Z+9, r25	; 0x09
     8b0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8b2:	eb 81       	ldd	r30, Y+3	; 0x03
     8b4:	fc 81       	ldd	r31, Y+4	; 0x04
     8b6:	80 81       	ld	r24, Z
     8b8:	8f 5f       	subi	r24, 0xFF	; 255
     8ba:	eb 81       	ldd	r30, Y+3	; 0x03
     8bc:	fc 81       	ldd	r31, Y+4	; 0x04
     8be:	80 83       	st	Z, r24
}
     8c0:	26 96       	adiw	r28, 0x06	; 6
     8c2:	0f b6       	in	r0, 0x3f	; 63
     8c4:	f8 94       	cli
     8c6:	de bf       	out	0x3e, r29	; 62
     8c8:	0f be       	out	0x3f, r0	; 63
     8ca:	cd bf       	out	0x3d, r28	; 61
     8cc:	cf 91       	pop	r28
     8ce:	df 91       	pop	r29
     8d0:	08 95       	ret

000008d2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     8d2:	df 93       	push	r29
     8d4:	cf 93       	push	r28
     8d6:	cd b7       	in	r28, 0x3d	; 61
     8d8:	de b7       	in	r29, 0x3e	; 62
     8da:	28 97       	sbiw	r28, 0x08	; 8
     8dc:	0f b6       	in	r0, 0x3f	; 63
     8de:	f8 94       	cli
     8e0:	de bf       	out	0x3e, r29	; 62
     8e2:	0f be       	out	0x3f, r0	; 63
     8e4:	cd bf       	out	0x3d, r28	; 61
     8e6:	9e 83       	std	Y+6, r25	; 0x06
     8e8:	8d 83       	std	Y+5, r24	; 0x05
     8ea:	78 87       	std	Y+8, r23	; 0x08
     8ec:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     8ee:	ef 81       	ldd	r30, Y+7	; 0x07
     8f0:	f8 85       	ldd	r31, Y+8	; 0x08
     8f2:	80 81       	ld	r24, Z
     8f4:	91 81       	ldd	r25, Z+1	; 0x01
     8f6:	9a 83       	std	Y+2, r25	; 0x02
     8f8:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     8fa:	89 81       	ldd	r24, Y+1	; 0x01
     8fc:	9a 81       	ldd	r25, Y+2	; 0x02
     8fe:	2f ef       	ldi	r18, 0xFF	; 255
     900:	8f 3f       	cpi	r24, 0xFF	; 255
     902:	92 07       	cpc	r25, r18
     904:	39 f4       	brne	.+14     	; 0x914 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     906:	ed 81       	ldd	r30, Y+5	; 0x05
     908:	fe 81       	ldd	r31, Y+6	; 0x06
     90a:	87 81       	ldd	r24, Z+7	; 0x07
     90c:	90 85       	ldd	r25, Z+8	; 0x08
     90e:	9c 83       	std	Y+4, r25	; 0x04
     910:	8b 83       	std	Y+3, r24	; 0x03
     912:	18 c0       	rjmp	.+48     	; 0x944 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     914:	8d 81       	ldd	r24, Y+5	; 0x05
     916:	9e 81       	ldd	r25, Y+6	; 0x06
     918:	03 96       	adiw	r24, 0x03	; 3
     91a:	9c 83       	std	Y+4, r25	; 0x04
     91c:	8b 83       	std	Y+3, r24	; 0x03
     91e:	06 c0       	rjmp	.+12     	; 0x92c <vListInsert+0x5a>
     920:	eb 81       	ldd	r30, Y+3	; 0x03
     922:	fc 81       	ldd	r31, Y+4	; 0x04
     924:	82 81       	ldd	r24, Z+2	; 0x02
     926:	93 81       	ldd	r25, Z+3	; 0x03
     928:	9c 83       	std	Y+4, r25	; 0x04
     92a:	8b 83       	std	Y+3, r24	; 0x03
     92c:	eb 81       	ldd	r30, Y+3	; 0x03
     92e:	fc 81       	ldd	r31, Y+4	; 0x04
     930:	02 80       	ldd	r0, Z+2	; 0x02
     932:	f3 81       	ldd	r31, Z+3	; 0x03
     934:	e0 2d       	mov	r30, r0
     936:	20 81       	ld	r18, Z
     938:	31 81       	ldd	r19, Z+1	; 0x01
     93a:	89 81       	ldd	r24, Y+1	; 0x01
     93c:	9a 81       	ldd	r25, Y+2	; 0x02
     93e:	82 17       	cp	r24, r18
     940:	93 07       	cpc	r25, r19
     942:	70 f7       	brcc	.-36     	; 0x920 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     944:	eb 81       	ldd	r30, Y+3	; 0x03
     946:	fc 81       	ldd	r31, Y+4	; 0x04
     948:	82 81       	ldd	r24, Z+2	; 0x02
     94a:	93 81       	ldd	r25, Z+3	; 0x03
     94c:	ef 81       	ldd	r30, Y+7	; 0x07
     94e:	f8 85       	ldd	r31, Y+8	; 0x08
     950:	93 83       	std	Z+3, r25	; 0x03
     952:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     954:	ef 81       	ldd	r30, Y+7	; 0x07
     956:	f8 85       	ldd	r31, Y+8	; 0x08
     958:	02 80       	ldd	r0, Z+2	; 0x02
     95a:	f3 81       	ldd	r31, Z+3	; 0x03
     95c:	e0 2d       	mov	r30, r0
     95e:	8f 81       	ldd	r24, Y+7	; 0x07
     960:	98 85       	ldd	r25, Y+8	; 0x08
     962:	95 83       	std	Z+5, r25	; 0x05
     964:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     966:	ef 81       	ldd	r30, Y+7	; 0x07
     968:	f8 85       	ldd	r31, Y+8	; 0x08
     96a:	8b 81       	ldd	r24, Y+3	; 0x03
     96c:	9c 81       	ldd	r25, Y+4	; 0x04
     96e:	95 83       	std	Z+5, r25	; 0x05
     970:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     972:	8f 81       	ldd	r24, Y+7	; 0x07
     974:	98 85       	ldd	r25, Y+8	; 0x08
     976:	eb 81       	ldd	r30, Y+3	; 0x03
     978:	fc 81       	ldd	r31, Y+4	; 0x04
     97a:	93 83       	std	Z+3, r25	; 0x03
     97c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     97e:	ef 81       	ldd	r30, Y+7	; 0x07
     980:	f8 85       	ldd	r31, Y+8	; 0x08
     982:	8d 81       	ldd	r24, Y+5	; 0x05
     984:	9e 81       	ldd	r25, Y+6	; 0x06
     986:	91 87       	std	Z+9, r25	; 0x09
     988:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     98a:	ed 81       	ldd	r30, Y+5	; 0x05
     98c:	fe 81       	ldd	r31, Y+6	; 0x06
     98e:	80 81       	ld	r24, Z
     990:	8f 5f       	subi	r24, 0xFF	; 255
     992:	ed 81       	ldd	r30, Y+5	; 0x05
     994:	fe 81       	ldd	r31, Y+6	; 0x06
     996:	80 83       	st	Z, r24
}
     998:	28 96       	adiw	r28, 0x08	; 8
     99a:	0f b6       	in	r0, 0x3f	; 63
     99c:	f8 94       	cli
     99e:	de bf       	out	0x3e, r29	; 62
     9a0:	0f be       	out	0x3f, r0	; 63
     9a2:	cd bf       	out	0x3d, r28	; 61
     9a4:	cf 91       	pop	r28
     9a6:	df 91       	pop	r29
     9a8:	08 95       	ret

000009aa <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     9aa:	df 93       	push	r29
     9ac:	cf 93       	push	r28
     9ae:	00 d0       	rcall	.+0      	; 0x9b0 <vListRemove+0x6>
     9b0:	00 d0       	rcall	.+0      	; 0x9b2 <vListRemove+0x8>
     9b2:	cd b7       	in	r28, 0x3d	; 61
     9b4:	de b7       	in	r29, 0x3e	; 62
     9b6:	9c 83       	std	Y+4, r25	; 0x04
     9b8:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9ba:	eb 81       	ldd	r30, Y+3	; 0x03
     9bc:	fc 81       	ldd	r31, Y+4	; 0x04
     9be:	a2 81       	ldd	r26, Z+2	; 0x02
     9c0:	b3 81       	ldd	r27, Z+3	; 0x03
     9c2:	eb 81       	ldd	r30, Y+3	; 0x03
     9c4:	fc 81       	ldd	r31, Y+4	; 0x04
     9c6:	84 81       	ldd	r24, Z+4	; 0x04
     9c8:	95 81       	ldd	r25, Z+5	; 0x05
     9ca:	15 96       	adiw	r26, 0x05	; 5
     9cc:	9c 93       	st	X, r25
     9ce:	8e 93       	st	-X, r24
     9d0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     9d2:	eb 81       	ldd	r30, Y+3	; 0x03
     9d4:	fc 81       	ldd	r31, Y+4	; 0x04
     9d6:	a4 81       	ldd	r26, Z+4	; 0x04
     9d8:	b5 81       	ldd	r27, Z+5	; 0x05
     9da:	eb 81       	ldd	r30, Y+3	; 0x03
     9dc:	fc 81       	ldd	r31, Y+4	; 0x04
     9de:	82 81       	ldd	r24, Z+2	; 0x02
     9e0:	93 81       	ldd	r25, Z+3	; 0x03
     9e2:	13 96       	adiw	r26, 0x03	; 3
     9e4:	9c 93       	st	X, r25
     9e6:	8e 93       	st	-X, r24
     9e8:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     9ea:	eb 81       	ldd	r30, Y+3	; 0x03
     9ec:	fc 81       	ldd	r31, Y+4	; 0x04
     9ee:	80 85       	ldd	r24, Z+8	; 0x08
     9f0:	91 85       	ldd	r25, Z+9	; 0x09
     9f2:	9a 83       	std	Y+2, r25	; 0x02
     9f4:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9f6:	e9 81       	ldd	r30, Y+1	; 0x01
     9f8:	fa 81       	ldd	r31, Y+2	; 0x02
     9fa:	21 81       	ldd	r18, Z+1	; 0x01
     9fc:	32 81       	ldd	r19, Z+2	; 0x02
     9fe:	8b 81       	ldd	r24, Y+3	; 0x03
     a00:	9c 81       	ldd	r25, Y+4	; 0x04
     a02:	28 17       	cp	r18, r24
     a04:	39 07       	cpc	r19, r25
     a06:	41 f4       	brne	.+16     	; 0xa18 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a08:	eb 81       	ldd	r30, Y+3	; 0x03
     a0a:	fc 81       	ldd	r31, Y+4	; 0x04
     a0c:	84 81       	ldd	r24, Z+4	; 0x04
     a0e:	95 81       	ldd	r25, Z+5	; 0x05
     a10:	e9 81       	ldd	r30, Y+1	; 0x01
     a12:	fa 81       	ldd	r31, Y+2	; 0x02
     a14:	92 83       	std	Z+2, r25	; 0x02
     a16:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     a18:	eb 81       	ldd	r30, Y+3	; 0x03
     a1a:	fc 81       	ldd	r31, Y+4	; 0x04
     a1c:	11 86       	std	Z+9, r1	; 0x09
     a1e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a20:	e9 81       	ldd	r30, Y+1	; 0x01
     a22:	fa 81       	ldd	r31, Y+2	; 0x02
     a24:	80 81       	ld	r24, Z
     a26:	81 50       	subi	r24, 0x01	; 1
     a28:	e9 81       	ldd	r30, Y+1	; 0x01
     a2a:	fa 81       	ldd	r31, Y+2	; 0x02
     a2c:	80 83       	st	Z, r24
}
     a2e:	0f 90       	pop	r0
     a30:	0f 90       	pop	r0
     a32:	0f 90       	pop	r0
     a34:	0f 90       	pop	r0
     a36:	cf 91       	pop	r28
     a38:	df 91       	pop	r29
     a3a:	08 95       	ret

00000a3c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     a3c:	df 93       	push	r29
     a3e:	cf 93       	push	r28
     a40:	cd b7       	in	r28, 0x3d	; 61
     a42:	de b7       	in	r29, 0x3e	; 62
     a44:	28 97       	sbiw	r28, 0x08	; 8
     a46:	0f b6       	in	r0, 0x3f	; 63
     a48:	f8 94       	cli
     a4a:	de bf       	out	0x3e, r29	; 62
     a4c:	0f be       	out	0x3f, r0	; 63
     a4e:	cd bf       	out	0x3d, r28	; 61
     a50:	9c 83       	std	Y+4, r25	; 0x04
     a52:	8b 83       	std	Y+3, r24	; 0x03
     a54:	7e 83       	std	Y+6, r23	; 0x06
     a56:	6d 83       	std	Y+5, r22	; 0x05
     a58:	58 87       	std	Y+8, r21	; 0x08
     a5a:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     a5c:	eb 81       	ldd	r30, Y+3	; 0x03
     a5e:	fc 81       	ldd	r31, Y+4	; 0x04
     a60:	81 e1       	ldi	r24, 0x11	; 17
     a62:	80 83       	st	Z, r24
	pxTopOfStack--;
     a64:	8b 81       	ldd	r24, Y+3	; 0x03
     a66:	9c 81       	ldd	r25, Y+4	; 0x04
     a68:	01 97       	sbiw	r24, 0x01	; 1
     a6a:	9c 83       	std	Y+4, r25	; 0x04
     a6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     a6e:	eb 81       	ldd	r30, Y+3	; 0x03
     a70:	fc 81       	ldd	r31, Y+4	; 0x04
     a72:	82 e2       	ldi	r24, 0x22	; 34
     a74:	80 83       	st	Z, r24
	pxTopOfStack--;
     a76:	8b 81       	ldd	r24, Y+3	; 0x03
     a78:	9c 81       	ldd	r25, Y+4	; 0x04
     a7a:	01 97       	sbiw	r24, 0x01	; 1
     a7c:	9c 83       	std	Y+4, r25	; 0x04
     a7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     a80:	eb 81       	ldd	r30, Y+3	; 0x03
     a82:	fc 81       	ldd	r31, Y+4	; 0x04
     a84:	83 e3       	ldi	r24, 0x33	; 51
     a86:	80 83       	st	Z, r24
	pxTopOfStack--;
     a88:	8b 81       	ldd	r24, Y+3	; 0x03
     a8a:	9c 81       	ldd	r25, Y+4	; 0x04
     a8c:	01 97       	sbiw	r24, 0x01	; 1
     a8e:	9c 83       	std	Y+4, r25	; 0x04
     a90:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     a92:	8d 81       	ldd	r24, Y+5	; 0x05
     a94:	9e 81       	ldd	r25, Y+6	; 0x06
     a96:	9a 83       	std	Y+2, r25	; 0x02
     a98:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     a9a:	89 81       	ldd	r24, Y+1	; 0x01
     a9c:	eb 81       	ldd	r30, Y+3	; 0x03
     a9e:	fc 81       	ldd	r31, Y+4	; 0x04
     aa0:	80 83       	st	Z, r24
	pxTopOfStack--;
     aa2:	8b 81       	ldd	r24, Y+3	; 0x03
     aa4:	9c 81       	ldd	r25, Y+4	; 0x04
     aa6:	01 97       	sbiw	r24, 0x01	; 1
     aa8:	9c 83       	std	Y+4, r25	; 0x04
     aaa:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     aac:	89 81       	ldd	r24, Y+1	; 0x01
     aae:	9a 81       	ldd	r25, Y+2	; 0x02
     ab0:	89 2f       	mov	r24, r25
     ab2:	99 27       	eor	r25, r25
     ab4:	9a 83       	std	Y+2, r25	; 0x02
     ab6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     ab8:	89 81       	ldd	r24, Y+1	; 0x01
     aba:	eb 81       	ldd	r30, Y+3	; 0x03
     abc:	fc 81       	ldd	r31, Y+4	; 0x04
     abe:	80 83       	st	Z, r24
	pxTopOfStack--;
     ac0:	8b 81       	ldd	r24, Y+3	; 0x03
     ac2:	9c 81       	ldd	r25, Y+4	; 0x04
     ac4:	01 97       	sbiw	r24, 0x01	; 1
     ac6:	9c 83       	std	Y+4, r25	; 0x04
     ac8:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     aca:	eb 81       	ldd	r30, Y+3	; 0x03
     acc:	fc 81       	ldd	r31, Y+4	; 0x04
     ace:	10 82       	st	Z, r1
	pxTopOfStack--;
     ad0:	8b 81       	ldd	r24, Y+3	; 0x03
     ad2:	9c 81       	ldd	r25, Y+4	; 0x04
     ad4:	01 97       	sbiw	r24, 0x01	; 1
     ad6:	9c 83       	std	Y+4, r25	; 0x04
     ad8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     ada:	eb 81       	ldd	r30, Y+3	; 0x03
     adc:	fc 81       	ldd	r31, Y+4	; 0x04
     ade:	80 e8       	ldi	r24, 0x80	; 128
     ae0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ae2:	8b 81       	ldd	r24, Y+3	; 0x03
     ae4:	9c 81       	ldd	r25, Y+4	; 0x04
     ae6:	01 97       	sbiw	r24, 0x01	; 1
     ae8:	9c 83       	std	Y+4, r25	; 0x04
     aea:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     aec:	eb 81       	ldd	r30, Y+3	; 0x03
     aee:	fc 81       	ldd	r31, Y+4	; 0x04
     af0:	10 82       	st	Z, r1
	pxTopOfStack--;
     af2:	8b 81       	ldd	r24, Y+3	; 0x03
     af4:	9c 81       	ldd	r25, Y+4	; 0x04
     af6:	01 97       	sbiw	r24, 0x01	; 1
     af8:	9c 83       	std	Y+4, r25	; 0x04
     afa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     afc:	eb 81       	ldd	r30, Y+3	; 0x03
     afe:	fc 81       	ldd	r31, Y+4	; 0x04
     b00:	82 e0       	ldi	r24, 0x02	; 2
     b02:	80 83       	st	Z, r24
	pxTopOfStack--;
     b04:	8b 81       	ldd	r24, Y+3	; 0x03
     b06:	9c 81       	ldd	r25, Y+4	; 0x04
     b08:	01 97       	sbiw	r24, 0x01	; 1
     b0a:	9c 83       	std	Y+4, r25	; 0x04
     b0c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     b0e:	eb 81       	ldd	r30, Y+3	; 0x03
     b10:	fc 81       	ldd	r31, Y+4	; 0x04
     b12:	83 e0       	ldi	r24, 0x03	; 3
     b14:	80 83       	st	Z, r24
	pxTopOfStack--;
     b16:	8b 81       	ldd	r24, Y+3	; 0x03
     b18:	9c 81       	ldd	r25, Y+4	; 0x04
     b1a:	01 97       	sbiw	r24, 0x01	; 1
     b1c:	9c 83       	std	Y+4, r25	; 0x04
     b1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     b20:	eb 81       	ldd	r30, Y+3	; 0x03
     b22:	fc 81       	ldd	r31, Y+4	; 0x04
     b24:	84 e0       	ldi	r24, 0x04	; 4
     b26:	80 83       	st	Z, r24
	pxTopOfStack--;
     b28:	8b 81       	ldd	r24, Y+3	; 0x03
     b2a:	9c 81       	ldd	r25, Y+4	; 0x04
     b2c:	01 97       	sbiw	r24, 0x01	; 1
     b2e:	9c 83       	std	Y+4, r25	; 0x04
     b30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     b32:	eb 81       	ldd	r30, Y+3	; 0x03
     b34:	fc 81       	ldd	r31, Y+4	; 0x04
     b36:	85 e0       	ldi	r24, 0x05	; 5
     b38:	80 83       	st	Z, r24
	pxTopOfStack--;
     b3a:	8b 81       	ldd	r24, Y+3	; 0x03
     b3c:	9c 81       	ldd	r25, Y+4	; 0x04
     b3e:	01 97       	sbiw	r24, 0x01	; 1
     b40:	9c 83       	std	Y+4, r25	; 0x04
     b42:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     b44:	eb 81       	ldd	r30, Y+3	; 0x03
     b46:	fc 81       	ldd	r31, Y+4	; 0x04
     b48:	86 e0       	ldi	r24, 0x06	; 6
     b4a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b4c:	8b 81       	ldd	r24, Y+3	; 0x03
     b4e:	9c 81       	ldd	r25, Y+4	; 0x04
     b50:	01 97       	sbiw	r24, 0x01	; 1
     b52:	9c 83       	std	Y+4, r25	; 0x04
     b54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     b56:	eb 81       	ldd	r30, Y+3	; 0x03
     b58:	fc 81       	ldd	r31, Y+4	; 0x04
     b5a:	87 e0       	ldi	r24, 0x07	; 7
     b5c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b5e:	8b 81       	ldd	r24, Y+3	; 0x03
     b60:	9c 81       	ldd	r25, Y+4	; 0x04
     b62:	01 97       	sbiw	r24, 0x01	; 1
     b64:	9c 83       	std	Y+4, r25	; 0x04
     b66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     b68:	eb 81       	ldd	r30, Y+3	; 0x03
     b6a:	fc 81       	ldd	r31, Y+4	; 0x04
     b6c:	88 e0       	ldi	r24, 0x08	; 8
     b6e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b70:	8b 81       	ldd	r24, Y+3	; 0x03
     b72:	9c 81       	ldd	r25, Y+4	; 0x04
     b74:	01 97       	sbiw	r24, 0x01	; 1
     b76:	9c 83       	std	Y+4, r25	; 0x04
     b78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     b7a:	eb 81       	ldd	r30, Y+3	; 0x03
     b7c:	fc 81       	ldd	r31, Y+4	; 0x04
     b7e:	89 e0       	ldi	r24, 0x09	; 9
     b80:	80 83       	st	Z, r24
	pxTopOfStack--;
     b82:	8b 81       	ldd	r24, Y+3	; 0x03
     b84:	9c 81       	ldd	r25, Y+4	; 0x04
     b86:	01 97       	sbiw	r24, 0x01	; 1
     b88:	9c 83       	std	Y+4, r25	; 0x04
     b8a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     b8c:	eb 81       	ldd	r30, Y+3	; 0x03
     b8e:	fc 81       	ldd	r31, Y+4	; 0x04
     b90:	80 e1       	ldi	r24, 0x10	; 16
     b92:	80 83       	st	Z, r24
	pxTopOfStack--;
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	01 97       	sbiw	r24, 0x01	; 1
     b9a:	9c 83       	std	Y+4, r25	; 0x04
     b9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     b9e:	eb 81       	ldd	r30, Y+3	; 0x03
     ba0:	fc 81       	ldd	r31, Y+4	; 0x04
     ba2:	81 e1       	ldi	r24, 0x11	; 17
     ba4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ba6:	8b 81       	ldd	r24, Y+3	; 0x03
     ba8:	9c 81       	ldd	r25, Y+4	; 0x04
     baa:	01 97       	sbiw	r24, 0x01	; 1
     bac:	9c 83       	std	Y+4, r25	; 0x04
     bae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     bb0:	eb 81       	ldd	r30, Y+3	; 0x03
     bb2:	fc 81       	ldd	r31, Y+4	; 0x04
     bb4:	82 e1       	ldi	r24, 0x12	; 18
     bb6:	80 83       	st	Z, r24
	pxTopOfStack--;
     bb8:	8b 81       	ldd	r24, Y+3	; 0x03
     bba:	9c 81       	ldd	r25, Y+4	; 0x04
     bbc:	01 97       	sbiw	r24, 0x01	; 1
     bbe:	9c 83       	std	Y+4, r25	; 0x04
     bc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     bc2:	eb 81       	ldd	r30, Y+3	; 0x03
     bc4:	fc 81       	ldd	r31, Y+4	; 0x04
     bc6:	83 e1       	ldi	r24, 0x13	; 19
     bc8:	80 83       	st	Z, r24
	pxTopOfStack--;
     bca:	8b 81       	ldd	r24, Y+3	; 0x03
     bcc:	9c 81       	ldd	r25, Y+4	; 0x04
     bce:	01 97       	sbiw	r24, 0x01	; 1
     bd0:	9c 83       	std	Y+4, r25	; 0x04
     bd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     bd4:	eb 81       	ldd	r30, Y+3	; 0x03
     bd6:	fc 81       	ldd	r31, Y+4	; 0x04
     bd8:	84 e1       	ldi	r24, 0x14	; 20
     bda:	80 83       	st	Z, r24
	pxTopOfStack--;
     bdc:	8b 81       	ldd	r24, Y+3	; 0x03
     bde:	9c 81       	ldd	r25, Y+4	; 0x04
     be0:	01 97       	sbiw	r24, 0x01	; 1
     be2:	9c 83       	std	Y+4, r25	; 0x04
     be4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     be6:	eb 81       	ldd	r30, Y+3	; 0x03
     be8:	fc 81       	ldd	r31, Y+4	; 0x04
     bea:	85 e1       	ldi	r24, 0x15	; 21
     bec:	80 83       	st	Z, r24
	pxTopOfStack--;
     bee:	8b 81       	ldd	r24, Y+3	; 0x03
     bf0:	9c 81       	ldd	r25, Y+4	; 0x04
     bf2:	01 97       	sbiw	r24, 0x01	; 1
     bf4:	9c 83       	std	Y+4, r25	; 0x04
     bf6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     bf8:	eb 81       	ldd	r30, Y+3	; 0x03
     bfa:	fc 81       	ldd	r31, Y+4	; 0x04
     bfc:	86 e1       	ldi	r24, 0x16	; 22
     bfe:	80 83       	st	Z, r24
	pxTopOfStack--;
     c00:	8b 81       	ldd	r24, Y+3	; 0x03
     c02:	9c 81       	ldd	r25, Y+4	; 0x04
     c04:	01 97       	sbiw	r24, 0x01	; 1
     c06:	9c 83       	std	Y+4, r25	; 0x04
     c08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     c0a:	eb 81       	ldd	r30, Y+3	; 0x03
     c0c:	fc 81       	ldd	r31, Y+4	; 0x04
     c0e:	87 e1       	ldi	r24, 0x17	; 23
     c10:	80 83       	st	Z, r24
	pxTopOfStack--;
     c12:	8b 81       	ldd	r24, Y+3	; 0x03
     c14:	9c 81       	ldd	r25, Y+4	; 0x04
     c16:	01 97       	sbiw	r24, 0x01	; 1
     c18:	9c 83       	std	Y+4, r25	; 0x04
     c1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     c1c:	eb 81       	ldd	r30, Y+3	; 0x03
     c1e:	fc 81       	ldd	r31, Y+4	; 0x04
     c20:	88 e1       	ldi	r24, 0x18	; 24
     c22:	80 83       	st	Z, r24
	pxTopOfStack--;
     c24:	8b 81       	ldd	r24, Y+3	; 0x03
     c26:	9c 81       	ldd	r25, Y+4	; 0x04
     c28:	01 97       	sbiw	r24, 0x01	; 1
     c2a:	9c 83       	std	Y+4, r25	; 0x04
     c2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     c2e:	eb 81       	ldd	r30, Y+3	; 0x03
     c30:	fc 81       	ldd	r31, Y+4	; 0x04
     c32:	89 e1       	ldi	r24, 0x19	; 25
     c34:	80 83       	st	Z, r24
	pxTopOfStack--;
     c36:	8b 81       	ldd	r24, Y+3	; 0x03
     c38:	9c 81       	ldd	r25, Y+4	; 0x04
     c3a:	01 97       	sbiw	r24, 0x01	; 1
     c3c:	9c 83       	std	Y+4, r25	; 0x04
     c3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     c40:	eb 81       	ldd	r30, Y+3	; 0x03
     c42:	fc 81       	ldd	r31, Y+4	; 0x04
     c44:	80 e2       	ldi	r24, 0x20	; 32
     c46:	80 83       	st	Z, r24
	pxTopOfStack--;
     c48:	8b 81       	ldd	r24, Y+3	; 0x03
     c4a:	9c 81       	ldd	r25, Y+4	; 0x04
     c4c:	01 97       	sbiw	r24, 0x01	; 1
     c4e:	9c 83       	std	Y+4, r25	; 0x04
     c50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     c52:	eb 81       	ldd	r30, Y+3	; 0x03
     c54:	fc 81       	ldd	r31, Y+4	; 0x04
     c56:	81 e2       	ldi	r24, 0x21	; 33
     c58:	80 83       	st	Z, r24
	pxTopOfStack--;
     c5a:	8b 81       	ldd	r24, Y+3	; 0x03
     c5c:	9c 81       	ldd	r25, Y+4	; 0x04
     c5e:	01 97       	sbiw	r24, 0x01	; 1
     c60:	9c 83       	std	Y+4, r25	; 0x04
     c62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     c64:	eb 81       	ldd	r30, Y+3	; 0x03
     c66:	fc 81       	ldd	r31, Y+4	; 0x04
     c68:	82 e2       	ldi	r24, 0x22	; 34
     c6a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c6c:	8b 81       	ldd	r24, Y+3	; 0x03
     c6e:	9c 81       	ldd	r25, Y+4	; 0x04
     c70:	01 97       	sbiw	r24, 0x01	; 1
     c72:	9c 83       	std	Y+4, r25	; 0x04
     c74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     c76:	eb 81       	ldd	r30, Y+3	; 0x03
     c78:	fc 81       	ldd	r31, Y+4	; 0x04
     c7a:	83 e2       	ldi	r24, 0x23	; 35
     c7c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c7e:	8b 81       	ldd	r24, Y+3	; 0x03
     c80:	9c 81       	ldd	r25, Y+4	; 0x04
     c82:	01 97       	sbiw	r24, 0x01	; 1
     c84:	9c 83       	std	Y+4, r25	; 0x04
     c86:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     c88:	8f 81       	ldd	r24, Y+7	; 0x07
     c8a:	98 85       	ldd	r25, Y+8	; 0x08
     c8c:	9a 83       	std	Y+2, r25	; 0x02
     c8e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c90:	89 81       	ldd	r24, Y+1	; 0x01
     c92:	eb 81       	ldd	r30, Y+3	; 0x03
     c94:	fc 81       	ldd	r31, Y+4	; 0x04
     c96:	80 83       	st	Z, r24
	pxTopOfStack--;
     c98:	8b 81       	ldd	r24, Y+3	; 0x03
     c9a:	9c 81       	ldd	r25, Y+4	; 0x04
     c9c:	01 97       	sbiw	r24, 0x01	; 1
     c9e:	9c 83       	std	Y+4, r25	; 0x04
     ca0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ca2:	89 81       	ldd	r24, Y+1	; 0x01
     ca4:	9a 81       	ldd	r25, Y+2	; 0x02
     ca6:	89 2f       	mov	r24, r25
     ca8:	99 27       	eor	r25, r25
     caa:	9a 83       	std	Y+2, r25	; 0x02
     cac:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	eb 81       	ldd	r30, Y+3	; 0x03
     cb2:	fc 81       	ldd	r31, Y+4	; 0x04
     cb4:	80 83       	st	Z, r24
	pxTopOfStack--;
     cb6:	8b 81       	ldd	r24, Y+3	; 0x03
     cb8:	9c 81       	ldd	r25, Y+4	; 0x04
     cba:	01 97       	sbiw	r24, 0x01	; 1
     cbc:	9c 83       	std	Y+4, r25	; 0x04
     cbe:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     cc0:	eb 81       	ldd	r30, Y+3	; 0x03
     cc2:	fc 81       	ldd	r31, Y+4	; 0x04
     cc4:	86 e2       	ldi	r24, 0x26	; 38
     cc6:	80 83       	st	Z, r24
	pxTopOfStack--;
     cc8:	8b 81       	ldd	r24, Y+3	; 0x03
     cca:	9c 81       	ldd	r25, Y+4	; 0x04
     ccc:	01 97       	sbiw	r24, 0x01	; 1
     cce:	9c 83       	std	Y+4, r25	; 0x04
     cd0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     cd2:	eb 81       	ldd	r30, Y+3	; 0x03
     cd4:	fc 81       	ldd	r31, Y+4	; 0x04
     cd6:	87 e2       	ldi	r24, 0x27	; 39
     cd8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cda:	8b 81       	ldd	r24, Y+3	; 0x03
     cdc:	9c 81       	ldd	r25, Y+4	; 0x04
     cde:	01 97       	sbiw	r24, 0x01	; 1
     ce0:	9c 83       	std	Y+4, r25	; 0x04
     ce2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     ce4:	eb 81       	ldd	r30, Y+3	; 0x03
     ce6:	fc 81       	ldd	r31, Y+4	; 0x04
     ce8:	88 e2       	ldi	r24, 0x28	; 40
     cea:	80 83       	st	Z, r24
	pxTopOfStack--;
     cec:	8b 81       	ldd	r24, Y+3	; 0x03
     cee:	9c 81       	ldd	r25, Y+4	; 0x04
     cf0:	01 97       	sbiw	r24, 0x01	; 1
     cf2:	9c 83       	std	Y+4, r25	; 0x04
     cf4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     cf6:	eb 81       	ldd	r30, Y+3	; 0x03
     cf8:	fc 81       	ldd	r31, Y+4	; 0x04
     cfa:	89 e2       	ldi	r24, 0x29	; 41
     cfc:	80 83       	st	Z, r24
	pxTopOfStack--;
     cfe:	8b 81       	ldd	r24, Y+3	; 0x03
     d00:	9c 81       	ldd	r25, Y+4	; 0x04
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	9c 83       	std	Y+4, r25	; 0x04
     d06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     d08:	eb 81       	ldd	r30, Y+3	; 0x03
     d0a:	fc 81       	ldd	r31, Y+4	; 0x04
     d0c:	80 e3       	ldi	r24, 0x30	; 48
     d0e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d10:	8b 81       	ldd	r24, Y+3	; 0x03
     d12:	9c 81       	ldd	r25, Y+4	; 0x04
     d14:	01 97       	sbiw	r24, 0x01	; 1
     d16:	9c 83       	std	Y+4, r25	; 0x04
     d18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     d1a:	eb 81       	ldd	r30, Y+3	; 0x03
     d1c:	fc 81       	ldd	r31, Y+4	; 0x04
     d1e:	81 e3       	ldi	r24, 0x31	; 49
     d20:	80 83       	st	Z, r24
	pxTopOfStack--;
     d22:	8b 81       	ldd	r24, Y+3	; 0x03
     d24:	9c 81       	ldd	r25, Y+4	; 0x04
     d26:	01 97       	sbiw	r24, 0x01	; 1
     d28:	9c 83       	std	Y+4, r25	; 0x04
     d2a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d2c:	8b 81       	ldd	r24, Y+3	; 0x03
     d2e:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d30:	28 96       	adiw	r28, 0x08	; 8
     d32:	0f b6       	in	r0, 0x3f	; 63
     d34:	f8 94       	cli
     d36:	de bf       	out	0x3e, r29	; 62
     d38:	0f be       	out	0x3f, r0	; 63
     d3a:	cd bf       	out	0x3d, r28	; 61
     d3c:	cf 91       	pop	r28
     d3e:	df 91       	pop	r29
     d40:	08 95       	ret

00000d42 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     d42:	df 93       	push	r29
     d44:	cf 93       	push	r28
     d46:	cd b7       	in	r28, 0x3d	; 61
     d48:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     d4a:	0e 94 91 07 	call	0xf22	; 0xf22 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d4e:	a0 91 fc 02 	lds	r26, 0x02FC
     d52:	b0 91 fd 02 	lds	r27, 0x02FD
     d56:	cd 91       	ld	r28, X+
     d58:	cd bf       	out	0x3d, r28	; 61
     d5a:	dd 91       	ld	r29, X+
     d5c:	de bf       	out	0x3e, r29	; 62
     d5e:	ff 91       	pop	r31
     d60:	ef 91       	pop	r30
     d62:	df 91       	pop	r29
     d64:	cf 91       	pop	r28
     d66:	bf 91       	pop	r27
     d68:	af 91       	pop	r26
     d6a:	9f 91       	pop	r25
     d6c:	8f 91       	pop	r24
     d6e:	7f 91       	pop	r23
     d70:	6f 91       	pop	r22
     d72:	5f 91       	pop	r21
     d74:	4f 91       	pop	r20
     d76:	3f 91       	pop	r19
     d78:	2f 91       	pop	r18
     d7a:	1f 91       	pop	r17
     d7c:	0f 91       	pop	r16
     d7e:	ff 90       	pop	r15
     d80:	ef 90       	pop	r14
     d82:	df 90       	pop	r13
     d84:	cf 90       	pop	r12
     d86:	bf 90       	pop	r11
     d88:	af 90       	pop	r10
     d8a:	9f 90       	pop	r9
     d8c:	8f 90       	pop	r8
     d8e:	7f 90       	pop	r7
     d90:	6f 90       	pop	r6
     d92:	5f 90       	pop	r5
     d94:	4f 90       	pop	r4
     d96:	3f 90       	pop	r3
     d98:	2f 90       	pop	r2
     d9a:	1f 90       	pop	r1
     d9c:	0f 90       	pop	r0
     d9e:	0f be       	out	0x3f, r0	; 63
     da0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     da2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     da4:	81 e0       	ldi	r24, 0x01	; 1
}
     da6:	cf 91       	pop	r28
     da8:	df 91       	pop	r29
     daa:	08 95       	ret

00000dac <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     dac:	df 93       	push	r29
     dae:	cf 93       	push	r28
     db0:	cd b7       	in	r28, 0x3d	; 61
     db2:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     db4:	cf 91       	pop	r28
     db6:	df 91       	pop	r29
     db8:	08 95       	ret

00000dba <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     dba:	0f 92       	push	r0
     dbc:	0f b6       	in	r0, 0x3f	; 63
     dbe:	f8 94       	cli
     dc0:	0f 92       	push	r0
     dc2:	1f 92       	push	r1
     dc4:	11 24       	eor	r1, r1
     dc6:	2f 92       	push	r2
     dc8:	3f 92       	push	r3
     dca:	4f 92       	push	r4
     dcc:	5f 92       	push	r5
     dce:	6f 92       	push	r6
     dd0:	7f 92       	push	r7
     dd2:	8f 92       	push	r8
     dd4:	9f 92       	push	r9
     dd6:	af 92       	push	r10
     dd8:	bf 92       	push	r11
     dda:	cf 92       	push	r12
     ddc:	df 92       	push	r13
     dde:	ef 92       	push	r14
     de0:	ff 92       	push	r15
     de2:	0f 93       	push	r16
     de4:	1f 93       	push	r17
     de6:	2f 93       	push	r18
     de8:	3f 93       	push	r19
     dea:	4f 93       	push	r20
     dec:	5f 93       	push	r21
     dee:	6f 93       	push	r22
     df0:	7f 93       	push	r23
     df2:	8f 93       	push	r24
     df4:	9f 93       	push	r25
     df6:	af 93       	push	r26
     df8:	bf 93       	push	r27
     dfa:	cf 93       	push	r28
     dfc:	df 93       	push	r29
     dfe:	ef 93       	push	r30
     e00:	ff 93       	push	r31
     e02:	a0 91 fc 02 	lds	r26, 0x02FC
     e06:	b0 91 fd 02 	lds	r27, 0x02FD
     e0a:	0d b6       	in	r0, 0x3d	; 61
     e0c:	0d 92       	st	X+, r0
     e0e:	0e b6       	in	r0, 0x3e	; 62
     e10:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e12:	0e 94 4e 10 	call	0x209c	; 0x209c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e16:	a0 91 fc 02 	lds	r26, 0x02FC
     e1a:	b0 91 fd 02 	lds	r27, 0x02FD
     e1e:	cd 91       	ld	r28, X+
     e20:	cd bf       	out	0x3d, r28	; 61
     e22:	dd 91       	ld	r29, X+
     e24:	de bf       	out	0x3e, r29	; 62
     e26:	ff 91       	pop	r31
     e28:	ef 91       	pop	r30
     e2a:	df 91       	pop	r29
     e2c:	cf 91       	pop	r28
     e2e:	bf 91       	pop	r27
     e30:	af 91       	pop	r26
     e32:	9f 91       	pop	r25
     e34:	8f 91       	pop	r24
     e36:	7f 91       	pop	r23
     e38:	6f 91       	pop	r22
     e3a:	5f 91       	pop	r21
     e3c:	4f 91       	pop	r20
     e3e:	3f 91       	pop	r19
     e40:	2f 91       	pop	r18
     e42:	1f 91       	pop	r17
     e44:	0f 91       	pop	r16
     e46:	ff 90       	pop	r15
     e48:	ef 90       	pop	r14
     e4a:	df 90       	pop	r13
     e4c:	cf 90       	pop	r12
     e4e:	bf 90       	pop	r11
     e50:	af 90       	pop	r10
     e52:	9f 90       	pop	r9
     e54:	8f 90       	pop	r8
     e56:	7f 90       	pop	r7
     e58:	6f 90       	pop	r6
     e5a:	5f 90       	pop	r5
     e5c:	4f 90       	pop	r4
     e5e:	3f 90       	pop	r3
     e60:	2f 90       	pop	r2
     e62:	1f 90       	pop	r1
     e64:	0f 90       	pop	r0
     e66:	0f be       	out	0x3f, r0	; 63
     e68:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e6a:	08 95       	ret

00000e6c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     e6c:	0f 92       	push	r0
     e6e:	0f b6       	in	r0, 0x3f	; 63
     e70:	f8 94       	cli
     e72:	0f 92       	push	r0
     e74:	1f 92       	push	r1
     e76:	11 24       	eor	r1, r1
     e78:	2f 92       	push	r2
     e7a:	3f 92       	push	r3
     e7c:	4f 92       	push	r4
     e7e:	5f 92       	push	r5
     e80:	6f 92       	push	r6
     e82:	7f 92       	push	r7
     e84:	8f 92       	push	r8
     e86:	9f 92       	push	r9
     e88:	af 92       	push	r10
     e8a:	bf 92       	push	r11
     e8c:	cf 92       	push	r12
     e8e:	df 92       	push	r13
     e90:	ef 92       	push	r14
     e92:	ff 92       	push	r15
     e94:	0f 93       	push	r16
     e96:	1f 93       	push	r17
     e98:	2f 93       	push	r18
     e9a:	3f 93       	push	r19
     e9c:	4f 93       	push	r20
     e9e:	5f 93       	push	r21
     ea0:	6f 93       	push	r22
     ea2:	7f 93       	push	r23
     ea4:	8f 93       	push	r24
     ea6:	9f 93       	push	r25
     ea8:	af 93       	push	r26
     eaa:	bf 93       	push	r27
     eac:	cf 93       	push	r28
     eae:	df 93       	push	r29
     eb0:	ef 93       	push	r30
     eb2:	ff 93       	push	r31
     eb4:	a0 91 fc 02 	lds	r26, 0x02FC
     eb8:	b0 91 fd 02 	lds	r27, 0x02FD
     ebc:	0d b6       	in	r0, 0x3d	; 61
     ebe:	0d 92       	st	X+, r0
     ec0:	0e b6       	in	r0, 0x3e	; 62
     ec2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     ec4:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <vTaskIncrementTick>
	vTaskSwitchContext();
     ec8:	0e 94 4e 10 	call	0x209c	; 0x209c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ecc:	a0 91 fc 02 	lds	r26, 0x02FC
     ed0:	b0 91 fd 02 	lds	r27, 0x02FD
     ed4:	cd 91       	ld	r28, X+
     ed6:	cd bf       	out	0x3d, r28	; 61
     ed8:	dd 91       	ld	r29, X+
     eda:	de bf       	out	0x3e, r29	; 62
     edc:	ff 91       	pop	r31
     ede:	ef 91       	pop	r30
     ee0:	df 91       	pop	r29
     ee2:	cf 91       	pop	r28
     ee4:	bf 91       	pop	r27
     ee6:	af 91       	pop	r26
     ee8:	9f 91       	pop	r25
     eea:	8f 91       	pop	r24
     eec:	7f 91       	pop	r23
     eee:	6f 91       	pop	r22
     ef0:	5f 91       	pop	r21
     ef2:	4f 91       	pop	r20
     ef4:	3f 91       	pop	r19
     ef6:	2f 91       	pop	r18
     ef8:	1f 91       	pop	r17
     efa:	0f 91       	pop	r16
     efc:	ff 90       	pop	r15
     efe:	ef 90       	pop	r14
     f00:	df 90       	pop	r13
     f02:	cf 90       	pop	r12
     f04:	bf 90       	pop	r11
     f06:	af 90       	pop	r10
     f08:	9f 90       	pop	r9
     f0a:	8f 90       	pop	r8
     f0c:	7f 90       	pop	r7
     f0e:	6f 90       	pop	r6
     f10:	5f 90       	pop	r5
     f12:	4f 90       	pop	r4
     f14:	3f 90       	pop	r3
     f16:	2f 90       	pop	r2
     f18:	1f 90       	pop	r1
     f1a:	0f 90       	pop	r0
     f1c:	0f be       	out	0x3f, r0	; 63
     f1e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f20:	08 95       	ret

00000f22 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f22:	df 93       	push	r29
     f24:	cf 93       	push	r28
     f26:	00 d0       	rcall	.+0      	; 0xf28 <prvSetupTimerInterrupt+0x6>
     f28:	00 d0       	rcall	.+0      	; 0xf2a <prvSetupTimerInterrupt+0x8>
     f2a:	00 d0       	rcall	.+0      	; 0xf2c <prvSetupTimerInterrupt+0xa>
     f2c:	cd b7       	in	r28, 0x3d	; 61
     f2e:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     f30:	80 e0       	ldi	r24, 0x00	; 0
     f32:	92 e1       	ldi	r25, 0x12	; 18
     f34:	aa e7       	ldi	r26, 0x7A	; 122
     f36:	b0 e0       	ldi	r27, 0x00	; 0
     f38:	8b 83       	std	Y+3, r24	; 0x03
     f3a:	9c 83       	std	Y+4, r25	; 0x04
     f3c:	ad 83       	std	Y+5, r26	; 0x05
     f3e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     f40:	8b 81       	ldd	r24, Y+3	; 0x03
     f42:	9c 81       	ldd	r25, Y+4	; 0x04
     f44:	ad 81       	ldd	r26, Y+5	; 0x05
     f46:	be 81       	ldd	r27, Y+6	; 0x06
     f48:	07 2e       	mov	r0, r23
     f4a:	7a e0       	ldi	r23, 0x0A	; 10
     f4c:	b6 95       	lsr	r27
     f4e:	a7 95       	ror	r26
     f50:	97 95       	ror	r25
     f52:	87 95       	ror	r24
     f54:	7a 95       	dec	r23
     f56:	d1 f7       	brne	.-12     	; 0xf4c <prvSetupTimerInterrupt+0x2a>
     f58:	70 2d       	mov	r23, r0
     f5a:	8b 83       	std	Y+3, r24	; 0x03
     f5c:	9c 83       	std	Y+4, r25	; 0x04
     f5e:	ad 83       	std	Y+5, r26	; 0x05
     f60:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
     f62:	8b 81       	ldd	r24, Y+3	; 0x03
     f64:	9c 81       	ldd	r25, Y+4	; 0x04
     f66:	ad 81       	ldd	r26, Y+5	; 0x05
     f68:	be 81       	ldd	r27, Y+6	; 0x06
     f6a:	01 97       	sbiw	r24, 0x01	; 1
     f6c:	a1 09       	sbc	r26, r1
     f6e:	b1 09       	sbc	r27, r1
     f70:	8b 83       	std	Y+3, r24	; 0x03
     f72:	9c 83       	std	Y+4, r25	; 0x04
     f74:	ad 83       	std	Y+5, r26	; 0x05
     f76:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     f78:	8b 81       	ldd	r24, Y+3	; 0x03
     f7a:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     f7c:	8b 81       	ldd	r24, Y+3	; 0x03
     f7e:	9c 81       	ldd	r25, Y+4	; 0x04
     f80:	ad 81       	ldd	r26, Y+5	; 0x05
     f82:	be 81       	ldd	r27, Y+6	; 0x06
     f84:	89 2f       	mov	r24, r25
     f86:	9a 2f       	mov	r25, r26
     f88:	ab 2f       	mov	r26, r27
     f8a:	bb 27       	eor	r27, r27
     f8c:	8b 83       	std	Y+3, r24	; 0x03
     f8e:	9c 83       	std	Y+4, r25	; 0x04
     f90:	ad 83       	std	Y+5, r26	; 0x05
     f92:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     f94:	8b 81       	ldd	r24, Y+3	; 0x03
     f96:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     f98:	eb e4       	ldi	r30, 0x4B	; 75
     f9a:	f0 e0       	ldi	r31, 0x00	; 0
     f9c:	8a 81       	ldd	r24, Y+2	; 0x02
     f9e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     fa0:	ea e4       	ldi	r30, 0x4A	; 74
     fa2:	f0 e0       	ldi	r31, 0x00	; 0
     fa4:	89 81       	ldd	r24, Y+1	; 0x01
     fa6:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_1024;
     fa8:	8d e0       	ldi	r24, 0x0D	; 13
     faa:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     fac:	ee e4       	ldi	r30, 0x4E	; 78
     fae:	f0 e0       	ldi	r31, 0x00	; 0
     fb0:	89 81       	ldd	r24, Y+1	; 0x01
     fb2:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     fb4:	e9 e5       	ldi	r30, 0x59	; 89
     fb6:	f0 e0       	ldi	r31, 0x00	; 0
     fb8:	80 81       	ld	r24, Z
     fba:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     fbc:	89 81       	ldd	r24, Y+1	; 0x01
     fbe:	80 61       	ori	r24, 0x10	; 16
     fc0:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     fc2:	e9 e5       	ldi	r30, 0x59	; 89
     fc4:	f0 e0       	ldi	r31, 0x00	; 0
     fc6:	89 81       	ldd	r24, Y+1	; 0x01
     fc8:	80 83       	st	Z, r24
}
     fca:	26 96       	adiw	r28, 0x06	; 6
     fcc:	0f b6       	in	r0, 0x3f	; 63
     fce:	f8 94       	cli
     fd0:	de bf       	out	0x3e, r29	; 62
     fd2:	0f be       	out	0x3f, r0	; 63
     fd4:	cd bf       	out	0x3d, r28	; 61
     fd6:	cf 91       	pop	r28
     fd8:	df 91       	pop	r29
     fda:	08 95       	ret

00000fdc <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
     fdc:	0e 94 36 07 	call	0xe6c	; 0xe6c <vPortYieldFromTick>
		asm volatile ( "reti" );
     fe0:	18 95       	reti

00000fe2 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     fe2:	df 93       	push	r29
     fe4:	cf 93       	push	r28
     fe6:	cd b7       	in	r28, 0x3d	; 61
     fe8:	de b7       	in	r29, 0x3e	; 62
     fea:	28 97       	sbiw	r28, 0x08	; 8
     fec:	0f b6       	in	r0, 0x3f	; 63
     fee:	f8 94       	cli
     ff0:	de bf       	out	0x3e, r29	; 62
     ff2:	0f be       	out	0x3f, r0	; 63
     ff4:	cd bf       	out	0x3d, r28	; 61
     ff6:	8f 83       	std	Y+7, r24	; 0x07
     ff8:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     ffa:	1a 82       	std	Y+2, r1	; 0x02
     ffc:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     ffe:	8f 81       	ldd	r24, Y+7	; 0x07
    1000:	88 23       	and	r24, r24
    1002:	09 f4       	brne	.+2      	; 0x1006 <xQueueCreate+0x24>
    1004:	8c c0       	rjmp	.+280    	; 0x111e <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1006:	8f e1       	ldi	r24, 0x1F	; 31
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	0e 94 77 03 	call	0x6ee	; 0x6ee <pvPortMalloc>
    100e:	9e 83       	std	Y+6, r25	; 0x06
    1010:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1012:	8d 81       	ldd	r24, Y+5	; 0x05
    1014:	9e 81       	ldd	r25, Y+6	; 0x06
    1016:	00 97       	sbiw	r24, 0x00	; 0
    1018:	09 f4       	brne	.+2      	; 0x101c <xQueueCreate+0x3a>
    101a:	81 c0       	rjmp	.+258    	; 0x111e <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    101c:	8f 81       	ldd	r24, Y+7	; 0x07
    101e:	28 2f       	mov	r18, r24
    1020:	30 e0       	ldi	r19, 0x00	; 0
    1022:	88 85       	ldd	r24, Y+8	; 0x08
    1024:	88 2f       	mov	r24, r24
    1026:	90 e0       	ldi	r25, 0x00	; 0
    1028:	ac 01       	movw	r20, r24
    102a:	24 9f       	mul	r18, r20
    102c:	c0 01       	movw	r24, r0
    102e:	25 9f       	mul	r18, r21
    1030:	90 0d       	add	r25, r0
    1032:	34 9f       	mul	r19, r20
    1034:	90 0d       	add	r25, r0
    1036:	11 24       	eor	r1, r1
    1038:	01 96       	adiw	r24, 0x01	; 1
    103a:	9c 83       	std	Y+4, r25	; 0x04
    103c:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    103e:	8b 81       	ldd	r24, Y+3	; 0x03
    1040:	9c 81       	ldd	r25, Y+4	; 0x04
    1042:	0e 94 77 03 	call	0x6ee	; 0x6ee <pvPortMalloc>
    1046:	ed 81       	ldd	r30, Y+5	; 0x05
    1048:	fe 81       	ldd	r31, Y+6	; 0x06
    104a:	91 83       	std	Z+1, r25	; 0x01
    104c:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    104e:	ed 81       	ldd	r30, Y+5	; 0x05
    1050:	fe 81       	ldd	r31, Y+6	; 0x06
    1052:	80 81       	ld	r24, Z
    1054:	91 81       	ldd	r25, Z+1	; 0x01
    1056:	00 97       	sbiw	r24, 0x00	; 0
    1058:	09 f4       	brne	.+2      	; 0x105c <xQueueCreate+0x7a>
    105a:	5d c0       	rjmp	.+186    	; 0x1116 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    105c:	ed 81       	ldd	r30, Y+5	; 0x05
    105e:	fe 81       	ldd	r31, Y+6	; 0x06
    1060:	40 81       	ld	r20, Z
    1062:	51 81       	ldd	r21, Z+1	; 0x01
    1064:	8f 81       	ldd	r24, Y+7	; 0x07
    1066:	28 2f       	mov	r18, r24
    1068:	30 e0       	ldi	r19, 0x00	; 0
    106a:	88 85       	ldd	r24, Y+8	; 0x08
    106c:	88 2f       	mov	r24, r24
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	bc 01       	movw	r22, r24
    1072:	26 9f       	mul	r18, r22
    1074:	c0 01       	movw	r24, r0
    1076:	27 9f       	mul	r18, r23
    1078:	90 0d       	add	r25, r0
    107a:	36 9f       	mul	r19, r22
    107c:	90 0d       	add	r25, r0
    107e:	11 24       	eor	r1, r1
    1080:	84 0f       	add	r24, r20
    1082:	95 1f       	adc	r25, r21
    1084:	ed 81       	ldd	r30, Y+5	; 0x05
    1086:	fe 81       	ldd	r31, Y+6	; 0x06
    1088:	93 83       	std	Z+3, r25	; 0x03
    108a:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    108c:	ed 81       	ldd	r30, Y+5	; 0x05
    108e:	fe 81       	ldd	r31, Y+6	; 0x06
    1090:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1092:	ed 81       	ldd	r30, Y+5	; 0x05
    1094:	fe 81       	ldd	r31, Y+6	; 0x06
    1096:	80 81       	ld	r24, Z
    1098:	91 81       	ldd	r25, Z+1	; 0x01
    109a:	ed 81       	ldd	r30, Y+5	; 0x05
    109c:	fe 81       	ldd	r31, Y+6	; 0x06
    109e:	95 83       	std	Z+5, r25	; 0x05
    10a0:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    10a2:	ed 81       	ldd	r30, Y+5	; 0x05
    10a4:	fe 81       	ldd	r31, Y+6	; 0x06
    10a6:	40 81       	ld	r20, Z
    10a8:	51 81       	ldd	r21, Z+1	; 0x01
    10aa:	8f 81       	ldd	r24, Y+7	; 0x07
    10ac:	88 2f       	mov	r24, r24
    10ae:	90 e0       	ldi	r25, 0x00	; 0
    10b0:	9c 01       	movw	r18, r24
    10b2:	21 50       	subi	r18, 0x01	; 1
    10b4:	30 40       	sbci	r19, 0x00	; 0
    10b6:	88 85       	ldd	r24, Y+8	; 0x08
    10b8:	88 2f       	mov	r24, r24
    10ba:	90 e0       	ldi	r25, 0x00	; 0
    10bc:	bc 01       	movw	r22, r24
    10be:	26 9f       	mul	r18, r22
    10c0:	c0 01       	movw	r24, r0
    10c2:	27 9f       	mul	r18, r23
    10c4:	90 0d       	add	r25, r0
    10c6:	36 9f       	mul	r19, r22
    10c8:	90 0d       	add	r25, r0
    10ca:	11 24       	eor	r1, r1
    10cc:	84 0f       	add	r24, r20
    10ce:	95 1f       	adc	r25, r21
    10d0:	ed 81       	ldd	r30, Y+5	; 0x05
    10d2:	fe 81       	ldd	r31, Y+6	; 0x06
    10d4:	97 83       	std	Z+7, r25	; 0x07
    10d6:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    10d8:	ed 81       	ldd	r30, Y+5	; 0x05
    10da:	fe 81       	ldd	r31, Y+6	; 0x06
    10dc:	8f 81       	ldd	r24, Y+7	; 0x07
    10de:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    10e0:	ed 81       	ldd	r30, Y+5	; 0x05
    10e2:	fe 81       	ldd	r31, Y+6	; 0x06
    10e4:	88 85       	ldd	r24, Y+8	; 0x08
    10e6:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    10e8:	ed 81       	ldd	r30, Y+5	; 0x05
    10ea:	fe 81       	ldd	r31, Y+6	; 0x06
    10ec:	8f ef       	ldi	r24, 0xFF	; 255
    10ee:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    10f0:	ed 81       	ldd	r30, Y+5	; 0x05
    10f2:	fe 81       	ldd	r31, Y+6	; 0x06
    10f4:	8f ef       	ldi	r24, 0xFF	; 255
    10f6:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    10f8:	8d 81       	ldd	r24, Y+5	; 0x05
    10fa:	9e 81       	ldd	r25, Y+6	; 0x06
    10fc:	08 96       	adiw	r24, 0x08	; 8
    10fe:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1102:	8d 81       	ldd	r24, Y+5	; 0x05
    1104:	9e 81       	ldd	r25, Y+6	; 0x06
    1106:	41 96       	adiw	r24, 0x11	; 17
    1108:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    110c:	8d 81       	ldd	r24, Y+5	; 0x05
    110e:	9e 81       	ldd	r25, Y+6	; 0x06
    1110:	9a 83       	std	Y+2, r25	; 0x02
    1112:	89 83       	std	Y+1, r24	; 0x01
    1114:	04 c0       	rjmp	.+8      	; 0x111e <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1116:	8d 81       	ldd	r24, Y+5	; 0x05
    1118:	9e 81       	ldd	r25, Y+6	; 0x06
    111a:	0e 94 bd 03 	call	0x77a	; 0x77a <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    111e:	89 81       	ldd	r24, Y+1	; 0x01
    1120:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1122:	28 96       	adiw	r28, 0x08	; 8
    1124:	0f b6       	in	r0, 0x3f	; 63
    1126:	f8 94       	cli
    1128:	de bf       	out	0x3e, r29	; 62
    112a:	0f be       	out	0x3f, r0	; 63
    112c:	cd bf       	out	0x3d, r28	; 61
    112e:	cf 91       	pop	r28
    1130:	df 91       	pop	r29
    1132:	08 95       	ret

00001134 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1134:	df 93       	push	r29
    1136:	cf 93       	push	r28
    1138:	cd b7       	in	r28, 0x3d	; 61
    113a:	de b7       	in	r29, 0x3e	; 62
    113c:	2c 97       	sbiw	r28, 0x0c	; 12
    113e:	0f b6       	in	r0, 0x3f	; 63
    1140:	f8 94       	cli
    1142:	de bf       	out	0x3e, r29	; 62
    1144:	0f be       	out	0x3f, r0	; 63
    1146:	cd bf       	out	0x3d, r28	; 61
    1148:	9e 83       	std	Y+6, r25	; 0x06
    114a:	8d 83       	std	Y+5, r24	; 0x05
    114c:	78 87       	std	Y+8, r23	; 0x08
    114e:	6f 83       	std	Y+7, r22	; 0x07
    1150:	5a 87       	std	Y+10, r21	; 0x0a
    1152:	49 87       	std	Y+9, r20	; 0x09
    1154:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1156:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1158:	0f b6       	in	r0, 0x3f	; 63
    115a:	f8 94       	cli
    115c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    115e:	ed 81       	ldd	r30, Y+5	; 0x05
    1160:	fe 81       	ldd	r31, Y+6	; 0x06
    1162:	92 8d       	ldd	r25, Z+26	; 0x1a
    1164:	ed 81       	ldd	r30, Y+5	; 0x05
    1166:	fe 81       	ldd	r31, Y+6	; 0x06
    1168:	83 8d       	ldd	r24, Z+27	; 0x1b
    116a:	98 17       	cp	r25, r24
    116c:	d8 f4       	brcc	.+54     	; 0x11a4 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    116e:	8d 81       	ldd	r24, Y+5	; 0x05
    1170:	9e 81       	ldd	r25, Y+6	; 0x06
    1172:	2f 81       	ldd	r18, Y+7	; 0x07
    1174:	38 85       	ldd	r19, Y+8	; 0x08
    1176:	b9 01       	movw	r22, r18
    1178:	4b 85       	ldd	r20, Y+11	; 0x0b
    117a:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    117e:	ed 81       	ldd	r30, Y+5	; 0x05
    1180:	fe 81       	ldd	r31, Y+6	; 0x06
    1182:	81 89       	ldd	r24, Z+17	; 0x11
    1184:	88 23       	and	r24, r24
    1186:	49 f0       	breq	.+18     	; 0x119a <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1188:	8d 81       	ldd	r24, Y+5	; 0x05
    118a:	9e 81       	ldd	r25, Y+6	; 0x06
    118c:	41 96       	adiw	r24, 0x11	; 17
    118e:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <xTaskRemoveFromEventList>
    1192:	81 30       	cpi	r24, 0x01	; 1
    1194:	11 f4       	brne	.+4      	; 0x119a <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1196:	0e 94 dd 06 	call	0xdba	; 0xdba <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    119a:	0f 90       	pop	r0
    119c:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    119e:	81 e0       	ldi	r24, 0x01	; 1
    11a0:	8c 87       	std	Y+12, r24	; 0x0c
    11a2:	5c c0       	rjmp	.+184    	; 0x125c <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    11a4:	89 85       	ldd	r24, Y+9	; 0x09
    11a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    11a8:	00 97       	sbiw	r24, 0x00	; 0
    11aa:	21 f4       	brne	.+8      	; 0x11b4 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11ac:	0f 90       	pop	r0
    11ae:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    11b0:	1c 86       	std	Y+12, r1	; 0x0c
    11b2:	54 c0       	rjmp	.+168    	; 0x125c <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    11b4:	89 81       	ldd	r24, Y+1	; 0x01
    11b6:	88 23       	and	r24, r24
    11b8:	31 f4       	brne	.+12     	; 0x11c6 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11ba:	ce 01       	movw	r24, r28
    11bc:	02 96       	adiw	r24, 0x02	; 2
    11be:	0e 94 52 11 	call	0x22a4	; 0x22a4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11c2:	81 e0       	ldi	r24, 0x01	; 1
    11c4:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    11c6:	0f 90       	pop	r0
    11c8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    11ca:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    11ce:	0f b6       	in	r0, 0x3f	; 63
    11d0:	f8 94       	cli
    11d2:	0f 92       	push	r0
    11d4:	ed 81       	ldd	r30, Y+5	; 0x05
    11d6:	fe 81       	ldd	r31, Y+6	; 0x06
    11d8:	85 8d       	ldd	r24, Z+29	; 0x1d
    11da:	8f 3f       	cpi	r24, 0xFF	; 255
    11dc:	19 f4       	brne	.+6      	; 0x11e4 <xQueueGenericSend+0xb0>
    11de:	ed 81       	ldd	r30, Y+5	; 0x05
    11e0:	fe 81       	ldd	r31, Y+6	; 0x06
    11e2:	15 8e       	std	Z+29, r1	; 0x1d
    11e4:	ed 81       	ldd	r30, Y+5	; 0x05
    11e6:	fe 81       	ldd	r31, Y+6	; 0x06
    11e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    11ea:	8f 3f       	cpi	r24, 0xFF	; 255
    11ec:	19 f4       	brne	.+6      	; 0x11f4 <xQueueGenericSend+0xc0>
    11ee:	ed 81       	ldd	r30, Y+5	; 0x05
    11f0:	fe 81       	ldd	r31, Y+6	; 0x06
    11f2:	16 8e       	std	Z+30, r1	; 0x1e
    11f4:	0f 90       	pop	r0
    11f6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    11f8:	ce 01       	movw	r24, r28
    11fa:	02 96       	adiw	r24, 0x02	; 2
    11fc:	9e 01       	movw	r18, r28
    11fe:	27 5f       	subi	r18, 0xF7	; 247
    1200:	3f 4f       	sbci	r19, 0xFF	; 255
    1202:	b9 01       	movw	r22, r18
    1204:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskCheckForTimeOut>
    1208:	88 23       	and	r24, r24
    120a:	09 f5       	brne	.+66     	; 0x124e <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    120c:	8d 81       	ldd	r24, Y+5	; 0x05
    120e:	9e 81       	ldd	r25, Y+6	; 0x06
    1210:	0e 94 39 0c 	call	0x1872	; 0x1872 <prvIsQueueFull>
    1214:	88 23       	and	r24, r24
    1216:	a1 f0       	breq	.+40     	; 0x1240 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1218:	8d 81       	ldd	r24, Y+5	; 0x05
    121a:	9e 81       	ldd	r25, Y+6	; 0x06
    121c:	08 96       	adiw	r24, 0x08	; 8
    121e:	29 85       	ldd	r18, Y+9	; 0x09
    1220:	3a 85       	ldd	r19, Y+10	; 0x0a
    1222:	b9 01       	movw	r22, r18
    1224:	0e 94 b4 10 	call	0x2168	; 0x2168 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1228:	8d 81       	ldd	r24, Y+5	; 0x05
    122a:	9e 81       	ldd	r25, Y+6	; 0x06
    122c:	0e 94 b2 0b 	call	0x1764	; 0x1764 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1230:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskResumeAll>
    1234:	88 23       	and	r24, r24
    1236:	09 f0       	breq	.+2      	; 0x123a <xQueueGenericSend+0x106>
    1238:	8f cf       	rjmp	.-226    	; 0x1158 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    123a:	0e 94 dd 06 	call	0xdba	; 0xdba <vPortYield>
    123e:	8c cf       	rjmp	.-232    	; 0x1158 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1240:	8d 81       	ldd	r24, Y+5	; 0x05
    1242:	9e 81       	ldd	r25, Y+6	; 0x06
    1244:	0e 94 b2 0b 	call	0x1764	; 0x1764 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1248:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskResumeAll>
    124c:	85 cf       	rjmp	.-246    	; 0x1158 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    124e:	8d 81       	ldd	r24, Y+5	; 0x05
    1250:	9e 81       	ldd	r25, Y+6	; 0x06
    1252:	0e 94 b2 0b 	call	0x1764	; 0x1764 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1256:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    125a:	1c 86       	std	Y+12, r1	; 0x0c
    125c:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    125e:	2c 96       	adiw	r28, 0x0c	; 12
    1260:	0f b6       	in	r0, 0x3f	; 63
    1262:	f8 94       	cli
    1264:	de bf       	out	0x3e, r29	; 62
    1266:	0f be       	out	0x3f, r0	; 63
    1268:	cd bf       	out	0x3d, r28	; 61
    126a:	cf 91       	pop	r28
    126c:	df 91       	pop	r29
    126e:	08 95       	ret

00001270 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1270:	df 93       	push	r29
    1272:	cf 93       	push	r28
    1274:	cd b7       	in	r28, 0x3d	; 61
    1276:	de b7       	in	r29, 0x3e	; 62
    1278:	29 97       	sbiw	r28, 0x09	; 9
    127a:	0f b6       	in	r0, 0x3f	; 63
    127c:	f8 94       	cli
    127e:	de bf       	out	0x3e, r29	; 62
    1280:	0f be       	out	0x3f, r0	; 63
    1282:	cd bf       	out	0x3d, r28	; 61
    1284:	9c 83       	std	Y+4, r25	; 0x04
    1286:	8b 83       	std	Y+3, r24	; 0x03
    1288:	7e 83       	std	Y+6, r23	; 0x06
    128a:	6d 83       	std	Y+5, r22	; 0x05
    128c:	58 87       	std	Y+8, r21	; 0x08
    128e:	4f 83       	std	Y+7, r20	; 0x07
    1290:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1292:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1294:	eb 81       	ldd	r30, Y+3	; 0x03
    1296:	fc 81       	ldd	r31, Y+4	; 0x04
    1298:	92 8d       	ldd	r25, Z+26	; 0x1a
    129a:	eb 81       	ldd	r30, Y+3	; 0x03
    129c:	fc 81       	ldd	r31, Y+4	; 0x04
    129e:	83 8d       	ldd	r24, Z+27	; 0x1b
    12a0:	98 17       	cp	r25, r24
    12a2:	40 f5       	brcc	.+80     	; 0x12f4 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12a4:	8b 81       	ldd	r24, Y+3	; 0x03
    12a6:	9c 81       	ldd	r25, Y+4	; 0x04
    12a8:	2d 81       	ldd	r18, Y+5	; 0x05
    12aa:	3e 81       	ldd	r19, Y+6	; 0x06
    12ac:	b9 01       	movw	r22, r18
    12ae:	49 85       	ldd	r20, Y+9	; 0x09
    12b0:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    12b4:	eb 81       	ldd	r30, Y+3	; 0x03
    12b6:	fc 81       	ldd	r31, Y+4	; 0x04
    12b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    12ba:	8f 3f       	cpi	r24, 0xFF	; 255
    12bc:	89 f4       	brne	.+34     	; 0x12e0 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12be:	eb 81       	ldd	r30, Y+3	; 0x03
    12c0:	fc 81       	ldd	r31, Y+4	; 0x04
    12c2:	81 89       	ldd	r24, Z+17	; 0x11
    12c4:	88 23       	and	r24, r24
    12c6:	99 f0       	breq	.+38     	; 0x12ee <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12c8:	8b 81       	ldd	r24, Y+3	; 0x03
    12ca:	9c 81       	ldd	r25, Y+4	; 0x04
    12cc:	41 96       	adiw	r24, 0x11	; 17
    12ce:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <xTaskRemoveFromEventList>
    12d2:	88 23       	and	r24, r24
    12d4:	61 f0       	breq	.+24     	; 0x12ee <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    12d6:	ef 81       	ldd	r30, Y+7	; 0x07
    12d8:	f8 85       	ldd	r31, Y+8	; 0x08
    12da:	81 e0       	ldi	r24, 0x01	; 1
    12dc:	80 83       	st	Z, r24
    12de:	07 c0       	rjmp	.+14     	; 0x12ee <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    12e0:	eb 81       	ldd	r30, Y+3	; 0x03
    12e2:	fc 81       	ldd	r31, Y+4	; 0x04
    12e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    12e6:	8f 5f       	subi	r24, 0xFF	; 255
    12e8:	eb 81       	ldd	r30, Y+3	; 0x03
    12ea:	fc 81       	ldd	r31, Y+4	; 0x04
    12ec:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	8a 83       	std	Y+2, r24	; 0x02
    12f2:	01 c0       	rjmp	.+2      	; 0x12f6 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    12f4:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    12f6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    12f8:	29 96       	adiw	r28, 0x09	; 9
    12fa:	0f b6       	in	r0, 0x3f	; 63
    12fc:	f8 94       	cli
    12fe:	de bf       	out	0x3e, r29	; 62
    1300:	0f be       	out	0x3f, r0	; 63
    1302:	cd bf       	out	0x3d, r28	; 61
    1304:	cf 91       	pop	r28
    1306:	df 91       	pop	r29
    1308:	08 95       	ret

0000130a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    130a:	df 93       	push	r29
    130c:	cf 93       	push	r28
    130e:	cd b7       	in	r28, 0x3d	; 61
    1310:	de b7       	in	r29, 0x3e	; 62
    1312:	2e 97       	sbiw	r28, 0x0e	; 14
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	de bf       	out	0x3e, r29	; 62
    131a:	0f be       	out	0x3f, r0	; 63
    131c:	cd bf       	out	0x3d, r28	; 61
    131e:	98 87       	std	Y+8, r25	; 0x08
    1320:	8f 83       	std	Y+7, r24	; 0x07
    1322:	7a 87       	std	Y+10, r23	; 0x0a
    1324:	69 87       	std	Y+9, r22	; 0x09
    1326:	5c 87       	std	Y+12, r21	; 0x0c
    1328:	4b 87       	std	Y+11, r20	; 0x0b
    132a:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    132c:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    132e:	0f b6       	in	r0, 0x3f	; 63
    1330:	f8 94       	cli
    1332:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1334:	ef 81       	ldd	r30, Y+7	; 0x07
    1336:	f8 85       	ldd	r31, Y+8	; 0x08
    1338:	82 8d       	ldd	r24, Z+26	; 0x1a
    133a:	88 23       	and	r24, r24
    133c:	09 f4       	brne	.+2      	; 0x1340 <xQueueGenericReceive+0x36>
    133e:	3f c0       	rjmp	.+126    	; 0x13be <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1340:	ef 81       	ldd	r30, Y+7	; 0x07
    1342:	f8 85       	ldd	r31, Y+8	; 0x08
    1344:	86 81       	ldd	r24, Z+6	; 0x06
    1346:	97 81       	ldd	r25, Z+7	; 0x07
    1348:	9a 83       	std	Y+2, r25	; 0x02
    134a:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    134c:	8f 81       	ldd	r24, Y+7	; 0x07
    134e:	98 85       	ldd	r25, Y+8	; 0x08
    1350:	29 85       	ldd	r18, Y+9	; 0x09
    1352:	3a 85       	ldd	r19, Y+10	; 0x0a
    1354:	b9 01       	movw	r22, r18
    1356:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    135a:	8d 85       	ldd	r24, Y+13	; 0x0d
    135c:	88 23       	and	r24, r24
    135e:	b1 f4       	brne	.+44     	; 0x138c <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1360:	ef 81       	ldd	r30, Y+7	; 0x07
    1362:	f8 85       	ldd	r31, Y+8	; 0x08
    1364:	82 8d       	ldd	r24, Z+26	; 0x1a
    1366:	81 50       	subi	r24, 0x01	; 1
    1368:	ef 81       	ldd	r30, Y+7	; 0x07
    136a:	f8 85       	ldd	r31, Y+8	; 0x08
    136c:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    136e:	ef 81       	ldd	r30, Y+7	; 0x07
    1370:	f8 85       	ldd	r31, Y+8	; 0x08
    1372:	80 85       	ldd	r24, Z+8	; 0x08
    1374:	88 23       	and	r24, r24
    1376:	f1 f0       	breq	.+60     	; 0x13b4 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1378:	8f 81       	ldd	r24, Y+7	; 0x07
    137a:	98 85       	ldd	r25, Y+8	; 0x08
    137c:	08 96       	adiw	r24, 0x08	; 8
    137e:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <xTaskRemoveFromEventList>
    1382:	81 30       	cpi	r24, 0x01	; 1
    1384:	b9 f4       	brne	.+46     	; 0x13b4 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1386:	0e 94 dd 06 	call	0xdba	; 0xdba <vPortYield>
    138a:	14 c0       	rjmp	.+40     	; 0x13b4 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    138c:	ef 81       	ldd	r30, Y+7	; 0x07
    138e:	f8 85       	ldd	r31, Y+8	; 0x08
    1390:	89 81       	ldd	r24, Y+1	; 0x01
    1392:	9a 81       	ldd	r25, Y+2	; 0x02
    1394:	97 83       	std	Z+7, r25	; 0x07
    1396:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1398:	ef 81       	ldd	r30, Y+7	; 0x07
    139a:	f8 85       	ldd	r31, Y+8	; 0x08
    139c:	81 89       	ldd	r24, Z+17	; 0x11
    139e:	88 23       	and	r24, r24
    13a0:	49 f0       	breq	.+18     	; 0x13b4 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13a2:	8f 81       	ldd	r24, Y+7	; 0x07
    13a4:	98 85       	ldd	r25, Y+8	; 0x08
    13a6:	41 96       	adiw	r24, 0x11	; 17
    13a8:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <xTaskRemoveFromEventList>
    13ac:	88 23       	and	r24, r24
    13ae:	11 f0       	breq	.+4      	; 0x13b4 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    13b0:	0e 94 dd 06 	call	0xdba	; 0xdba <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    13b4:	0f 90       	pop	r0
    13b6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	8e 87       	std	Y+14, r24	; 0x0e
    13bc:	5c c0       	rjmp	.+184    	; 0x1476 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    13be:	8b 85       	ldd	r24, Y+11	; 0x0b
    13c0:	9c 85       	ldd	r25, Y+12	; 0x0c
    13c2:	00 97       	sbiw	r24, 0x00	; 0
    13c4:	21 f4       	brne	.+8      	; 0x13ce <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    13c6:	0f 90       	pop	r0
    13c8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    13ca:	1e 86       	std	Y+14, r1	; 0x0e
    13cc:	54 c0       	rjmp	.+168    	; 0x1476 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    13ce:	8b 81       	ldd	r24, Y+3	; 0x03
    13d0:	88 23       	and	r24, r24
    13d2:	31 f4       	brne	.+12     	; 0x13e0 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    13d4:	ce 01       	movw	r24, r28
    13d6:	04 96       	adiw	r24, 0x04	; 4
    13d8:	0e 94 52 11 	call	0x22a4	; 0x22a4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    13dc:	81 e0       	ldi	r24, 0x01	; 1
    13de:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    13e0:	0f 90       	pop	r0
    13e2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    13e4:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    13e8:	0f b6       	in	r0, 0x3f	; 63
    13ea:	f8 94       	cli
    13ec:	0f 92       	push	r0
    13ee:	ef 81       	ldd	r30, Y+7	; 0x07
    13f0:	f8 85       	ldd	r31, Y+8	; 0x08
    13f2:	85 8d       	ldd	r24, Z+29	; 0x1d
    13f4:	8f 3f       	cpi	r24, 0xFF	; 255
    13f6:	19 f4       	brne	.+6      	; 0x13fe <xQueueGenericReceive+0xf4>
    13f8:	ef 81       	ldd	r30, Y+7	; 0x07
    13fa:	f8 85       	ldd	r31, Y+8	; 0x08
    13fc:	15 8e       	std	Z+29, r1	; 0x1d
    13fe:	ef 81       	ldd	r30, Y+7	; 0x07
    1400:	f8 85       	ldd	r31, Y+8	; 0x08
    1402:	86 8d       	ldd	r24, Z+30	; 0x1e
    1404:	8f 3f       	cpi	r24, 0xFF	; 255
    1406:	19 f4       	brne	.+6      	; 0x140e <xQueueGenericReceive+0x104>
    1408:	ef 81       	ldd	r30, Y+7	; 0x07
    140a:	f8 85       	ldd	r31, Y+8	; 0x08
    140c:	16 8e       	std	Z+30, r1	; 0x1e
    140e:	0f 90       	pop	r0
    1410:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1412:	ce 01       	movw	r24, r28
    1414:	04 96       	adiw	r24, 0x04	; 4
    1416:	9e 01       	movw	r18, r28
    1418:	25 5f       	subi	r18, 0xF5	; 245
    141a:	3f 4f       	sbci	r19, 0xFF	; 255
    141c:	b9 01       	movw	r22, r18
    141e:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskCheckForTimeOut>
    1422:	88 23       	and	r24, r24
    1424:	09 f5       	brne	.+66     	; 0x1468 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1426:	8f 81       	ldd	r24, Y+7	; 0x07
    1428:	98 85       	ldd	r25, Y+8	; 0x08
    142a:	0e 94 06 0c 	call	0x180c	; 0x180c <prvIsQueueEmpty>
    142e:	88 23       	and	r24, r24
    1430:	a1 f0       	breq	.+40     	; 0x145a <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1432:	8f 81       	ldd	r24, Y+7	; 0x07
    1434:	98 85       	ldd	r25, Y+8	; 0x08
    1436:	41 96       	adiw	r24, 0x11	; 17
    1438:	2b 85       	ldd	r18, Y+11	; 0x0b
    143a:	3c 85       	ldd	r19, Y+12	; 0x0c
    143c:	b9 01       	movw	r22, r18
    143e:	0e 94 b4 10 	call	0x2168	; 0x2168 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1442:	8f 81       	ldd	r24, Y+7	; 0x07
    1444:	98 85       	ldd	r25, Y+8	; 0x08
    1446:	0e 94 b2 0b 	call	0x1764	; 0x1764 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    144a:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskResumeAll>
    144e:	88 23       	and	r24, r24
    1450:	09 f0       	breq	.+2      	; 0x1454 <xQueueGenericReceive+0x14a>
    1452:	6d cf       	rjmp	.-294    	; 0x132e <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1454:	0e 94 dd 06 	call	0xdba	; 0xdba <vPortYield>
    1458:	6a cf       	rjmp	.-300    	; 0x132e <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    145a:	8f 81       	ldd	r24, Y+7	; 0x07
    145c:	98 85       	ldd	r25, Y+8	; 0x08
    145e:	0e 94 b2 0b 	call	0x1764	; 0x1764 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1462:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskResumeAll>
    1466:	63 cf       	rjmp	.-314    	; 0x132e <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1468:	8f 81       	ldd	r24, Y+7	; 0x07
    146a:	98 85       	ldd	r25, Y+8	; 0x08
    146c:	0e 94 b2 0b 	call	0x1764	; 0x1764 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1470:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1474:	1e 86       	std	Y+14, r1	; 0x0e
    1476:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1478:	2e 96       	adiw	r28, 0x0e	; 14
    147a:	0f b6       	in	r0, 0x3f	; 63
    147c:	f8 94       	cli
    147e:	de bf       	out	0x3e, r29	; 62
    1480:	0f be       	out	0x3f, r0	; 63
    1482:	cd bf       	out	0x3d, r28	; 61
    1484:	cf 91       	pop	r28
    1486:	df 91       	pop	r29
    1488:	08 95       	ret

0000148a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    148a:	df 93       	push	r29
    148c:	cf 93       	push	r28
    148e:	cd b7       	in	r28, 0x3d	; 61
    1490:	de b7       	in	r29, 0x3e	; 62
    1492:	28 97       	sbiw	r28, 0x08	; 8
    1494:	0f b6       	in	r0, 0x3f	; 63
    1496:	f8 94       	cli
    1498:	de bf       	out	0x3e, r29	; 62
    149a:	0f be       	out	0x3f, r0	; 63
    149c:	cd bf       	out	0x3d, r28	; 61
    149e:	9c 83       	std	Y+4, r25	; 0x04
    14a0:	8b 83       	std	Y+3, r24	; 0x03
    14a2:	7e 83       	std	Y+6, r23	; 0x06
    14a4:	6d 83       	std	Y+5, r22	; 0x05
    14a6:	58 87       	std	Y+8, r21	; 0x08
    14a8:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    14aa:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    14ac:	eb 81       	ldd	r30, Y+3	; 0x03
    14ae:	fc 81       	ldd	r31, Y+4	; 0x04
    14b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    14b2:	88 23       	and	r24, r24
    14b4:	71 f1       	breq	.+92     	; 0x1512 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    14b6:	8b 81       	ldd	r24, Y+3	; 0x03
    14b8:	9c 81       	ldd	r25, Y+4	; 0x04
    14ba:	2d 81       	ldd	r18, Y+5	; 0x05
    14bc:	3e 81       	ldd	r19, Y+6	; 0x06
    14be:	b9 01       	movw	r22, r18
    14c0:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    14c4:	eb 81       	ldd	r30, Y+3	; 0x03
    14c6:	fc 81       	ldd	r31, Y+4	; 0x04
    14c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    14ca:	81 50       	subi	r24, 0x01	; 1
    14cc:	eb 81       	ldd	r30, Y+3	; 0x03
    14ce:	fc 81       	ldd	r31, Y+4	; 0x04
    14d0:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    14d2:	eb 81       	ldd	r30, Y+3	; 0x03
    14d4:	fc 81       	ldd	r31, Y+4	; 0x04
    14d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    14d8:	8f 3f       	cpi	r24, 0xFF	; 255
    14da:	89 f4       	brne	.+34     	; 0x14fe <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14dc:	eb 81       	ldd	r30, Y+3	; 0x03
    14de:	fc 81       	ldd	r31, Y+4	; 0x04
    14e0:	80 85       	ldd	r24, Z+8	; 0x08
    14e2:	88 23       	and	r24, r24
    14e4:	99 f0       	breq	.+38     	; 0x150c <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14e6:	8b 81       	ldd	r24, Y+3	; 0x03
    14e8:	9c 81       	ldd	r25, Y+4	; 0x04
    14ea:	08 96       	adiw	r24, 0x08	; 8
    14ec:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <xTaskRemoveFromEventList>
    14f0:	88 23       	and	r24, r24
    14f2:	61 f0       	breq	.+24     	; 0x150c <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    14f4:	ef 81       	ldd	r30, Y+7	; 0x07
    14f6:	f8 85       	ldd	r31, Y+8	; 0x08
    14f8:	81 e0       	ldi	r24, 0x01	; 1
    14fa:	80 83       	st	Z, r24
    14fc:	07 c0       	rjmp	.+14     	; 0x150c <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    14fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1500:	fc 81       	ldd	r31, Y+4	; 0x04
    1502:	85 8d       	ldd	r24, Z+29	; 0x1d
    1504:	8f 5f       	subi	r24, 0xFF	; 255
    1506:	eb 81       	ldd	r30, Y+3	; 0x03
    1508:	fc 81       	ldd	r31, Y+4	; 0x04
    150a:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    150c:	81 e0       	ldi	r24, 0x01	; 1
    150e:	8a 83       	std	Y+2, r24	; 0x02
    1510:	01 c0       	rjmp	.+2      	; 0x1514 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1512:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1514:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1516:	28 96       	adiw	r28, 0x08	; 8
    1518:	0f b6       	in	r0, 0x3f	; 63
    151a:	f8 94       	cli
    151c:	de bf       	out	0x3e, r29	; 62
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	cd bf       	out	0x3d, r28	; 61
    1522:	cf 91       	pop	r28
    1524:	df 91       	pop	r29
    1526:	08 95       	ret

00001528 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1528:	df 93       	push	r29
    152a:	cf 93       	push	r28
    152c:	00 d0       	rcall	.+0      	; 0x152e <uxQueueMessagesWaiting+0x6>
    152e:	0f 92       	push	r0
    1530:	cd b7       	in	r28, 0x3d	; 61
    1532:	de b7       	in	r29, 0x3e	; 62
    1534:	9b 83       	std	Y+3, r25	; 0x03
    1536:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1538:	0f b6       	in	r0, 0x3f	; 63
    153a:	f8 94       	cli
    153c:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    153e:	ea 81       	ldd	r30, Y+2	; 0x02
    1540:	fb 81       	ldd	r31, Y+3	; 0x03
    1542:	82 8d       	ldd	r24, Z+26	; 0x1a
    1544:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1546:	0f 90       	pop	r0
    1548:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    154a:	89 81       	ldd	r24, Y+1	; 0x01
}
    154c:	0f 90       	pop	r0
    154e:	0f 90       	pop	r0
    1550:	0f 90       	pop	r0
    1552:	cf 91       	pop	r28
    1554:	df 91       	pop	r29
    1556:	08 95       	ret

00001558 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1558:	df 93       	push	r29
    155a:	cf 93       	push	r28
    155c:	00 d0       	rcall	.+0      	; 0x155e <uxQueueMessagesWaitingFromISR+0x6>
    155e:	0f 92       	push	r0
    1560:	cd b7       	in	r28, 0x3d	; 61
    1562:	de b7       	in	r29, 0x3e	; 62
    1564:	9b 83       	std	Y+3, r25	; 0x03
    1566:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1568:	ea 81       	ldd	r30, Y+2	; 0x02
    156a:	fb 81       	ldd	r31, Y+3	; 0x03
    156c:	82 8d       	ldd	r24, Z+26	; 0x1a
    156e:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1570:	89 81       	ldd	r24, Y+1	; 0x01
}
    1572:	0f 90       	pop	r0
    1574:	0f 90       	pop	r0
    1576:	0f 90       	pop	r0
    1578:	cf 91       	pop	r28
    157a:	df 91       	pop	r29
    157c:	08 95       	ret

0000157e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    157e:	df 93       	push	r29
    1580:	cf 93       	push	r28
    1582:	00 d0       	rcall	.+0      	; 0x1584 <vQueueDelete+0x6>
    1584:	cd b7       	in	r28, 0x3d	; 61
    1586:	de b7       	in	r29, 0x3e	; 62
    1588:	9a 83       	std	Y+2, r25	; 0x02
    158a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    158c:	e9 81       	ldd	r30, Y+1	; 0x01
    158e:	fa 81       	ldd	r31, Y+2	; 0x02
    1590:	80 81       	ld	r24, Z
    1592:	91 81       	ldd	r25, Z+1	; 0x01
    1594:	0e 94 bd 03 	call	0x77a	; 0x77a <vPortFree>
	vPortFree( pxQueue );
    1598:	89 81       	ldd	r24, Y+1	; 0x01
    159a:	9a 81       	ldd	r25, Y+2	; 0x02
    159c:	0e 94 bd 03 	call	0x77a	; 0x77a <vPortFree>
}
    15a0:	0f 90       	pop	r0
    15a2:	0f 90       	pop	r0
    15a4:	cf 91       	pop	r28
    15a6:	df 91       	pop	r29
    15a8:	08 95       	ret

000015aa <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    15aa:	df 93       	push	r29
    15ac:	cf 93       	push	r28
    15ae:	00 d0       	rcall	.+0      	; 0x15b0 <prvCopyDataToQueue+0x6>
    15b0:	00 d0       	rcall	.+0      	; 0x15b2 <prvCopyDataToQueue+0x8>
    15b2:	0f 92       	push	r0
    15b4:	cd b7       	in	r28, 0x3d	; 61
    15b6:	de b7       	in	r29, 0x3e	; 62
    15b8:	9a 83       	std	Y+2, r25	; 0x02
    15ba:	89 83       	std	Y+1, r24	; 0x01
    15bc:	7c 83       	std	Y+4, r23	; 0x04
    15be:	6b 83       	std	Y+3, r22	; 0x03
    15c0:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    15c2:	e9 81       	ldd	r30, Y+1	; 0x01
    15c4:	fa 81       	ldd	r31, Y+2	; 0x02
    15c6:	84 8d       	ldd	r24, Z+28	; 0x1c
    15c8:	88 23       	and	r24, r24
    15ca:	09 f4       	brne	.+2      	; 0x15ce <prvCopyDataToQueue+0x24>
    15cc:	74 c0       	rjmp	.+232    	; 0x16b6 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    15ce:	8d 81       	ldd	r24, Y+5	; 0x05
    15d0:	88 23       	and	r24, r24
    15d2:	99 f5       	brne	.+102    	; 0x163a <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    15d4:	e9 81       	ldd	r30, Y+1	; 0x01
    15d6:	fa 81       	ldd	r31, Y+2	; 0x02
    15d8:	64 81       	ldd	r22, Z+4	; 0x04
    15da:	75 81       	ldd	r23, Z+5	; 0x05
    15dc:	e9 81       	ldd	r30, Y+1	; 0x01
    15de:	fa 81       	ldd	r31, Y+2	; 0x02
    15e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    15e2:	48 2f       	mov	r20, r24
    15e4:	50 e0       	ldi	r21, 0x00	; 0
    15e6:	2b 81       	ldd	r18, Y+3	; 0x03
    15e8:	3c 81       	ldd	r19, Y+4	; 0x04
    15ea:	cb 01       	movw	r24, r22
    15ec:	b9 01       	movw	r22, r18
    15ee:	0e 94 5d 13 	call	0x26ba	; 0x26ba <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    15f2:	e9 81       	ldd	r30, Y+1	; 0x01
    15f4:	fa 81       	ldd	r31, Y+2	; 0x02
    15f6:	24 81       	ldd	r18, Z+4	; 0x04
    15f8:	35 81       	ldd	r19, Z+5	; 0x05
    15fa:	e9 81       	ldd	r30, Y+1	; 0x01
    15fc:	fa 81       	ldd	r31, Y+2	; 0x02
    15fe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1600:	88 2f       	mov	r24, r24
    1602:	90 e0       	ldi	r25, 0x00	; 0
    1604:	82 0f       	add	r24, r18
    1606:	93 1f       	adc	r25, r19
    1608:	e9 81       	ldd	r30, Y+1	; 0x01
    160a:	fa 81       	ldd	r31, Y+2	; 0x02
    160c:	95 83       	std	Z+5, r25	; 0x05
    160e:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1610:	e9 81       	ldd	r30, Y+1	; 0x01
    1612:	fa 81       	ldd	r31, Y+2	; 0x02
    1614:	24 81       	ldd	r18, Z+4	; 0x04
    1616:	35 81       	ldd	r19, Z+5	; 0x05
    1618:	e9 81       	ldd	r30, Y+1	; 0x01
    161a:	fa 81       	ldd	r31, Y+2	; 0x02
    161c:	82 81       	ldd	r24, Z+2	; 0x02
    161e:	93 81       	ldd	r25, Z+3	; 0x03
    1620:	28 17       	cp	r18, r24
    1622:	39 07       	cpc	r19, r25
    1624:	08 f4       	brcc	.+2      	; 0x1628 <prvCopyDataToQueue+0x7e>
    1626:	47 c0       	rjmp	.+142    	; 0x16b6 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1628:	e9 81       	ldd	r30, Y+1	; 0x01
    162a:	fa 81       	ldd	r31, Y+2	; 0x02
    162c:	80 81       	ld	r24, Z
    162e:	91 81       	ldd	r25, Z+1	; 0x01
    1630:	e9 81       	ldd	r30, Y+1	; 0x01
    1632:	fa 81       	ldd	r31, Y+2	; 0x02
    1634:	95 83       	std	Z+5, r25	; 0x05
    1636:	84 83       	std	Z+4, r24	; 0x04
    1638:	3e c0       	rjmp	.+124    	; 0x16b6 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    163a:	e9 81       	ldd	r30, Y+1	; 0x01
    163c:	fa 81       	ldd	r31, Y+2	; 0x02
    163e:	66 81       	ldd	r22, Z+6	; 0x06
    1640:	77 81       	ldd	r23, Z+7	; 0x07
    1642:	e9 81       	ldd	r30, Y+1	; 0x01
    1644:	fa 81       	ldd	r31, Y+2	; 0x02
    1646:	84 8d       	ldd	r24, Z+28	; 0x1c
    1648:	48 2f       	mov	r20, r24
    164a:	50 e0       	ldi	r21, 0x00	; 0
    164c:	2b 81       	ldd	r18, Y+3	; 0x03
    164e:	3c 81       	ldd	r19, Y+4	; 0x04
    1650:	cb 01       	movw	r24, r22
    1652:	b9 01       	movw	r22, r18
    1654:	0e 94 5d 13 	call	0x26ba	; 0x26ba <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1658:	e9 81       	ldd	r30, Y+1	; 0x01
    165a:	fa 81       	ldd	r31, Y+2	; 0x02
    165c:	26 81       	ldd	r18, Z+6	; 0x06
    165e:	37 81       	ldd	r19, Z+7	; 0x07
    1660:	e9 81       	ldd	r30, Y+1	; 0x01
    1662:	fa 81       	ldd	r31, Y+2	; 0x02
    1664:	84 8d       	ldd	r24, Z+28	; 0x1c
    1666:	88 2f       	mov	r24, r24
    1668:	90 e0       	ldi	r25, 0x00	; 0
    166a:	90 95       	com	r25
    166c:	81 95       	neg	r24
    166e:	9f 4f       	sbci	r25, 0xFF	; 255
    1670:	82 0f       	add	r24, r18
    1672:	93 1f       	adc	r25, r19
    1674:	e9 81       	ldd	r30, Y+1	; 0x01
    1676:	fa 81       	ldd	r31, Y+2	; 0x02
    1678:	97 83       	std	Z+7, r25	; 0x07
    167a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    167c:	e9 81       	ldd	r30, Y+1	; 0x01
    167e:	fa 81       	ldd	r31, Y+2	; 0x02
    1680:	26 81       	ldd	r18, Z+6	; 0x06
    1682:	37 81       	ldd	r19, Z+7	; 0x07
    1684:	e9 81       	ldd	r30, Y+1	; 0x01
    1686:	fa 81       	ldd	r31, Y+2	; 0x02
    1688:	80 81       	ld	r24, Z
    168a:	91 81       	ldd	r25, Z+1	; 0x01
    168c:	28 17       	cp	r18, r24
    168e:	39 07       	cpc	r19, r25
    1690:	90 f4       	brcc	.+36     	; 0x16b6 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1692:	e9 81       	ldd	r30, Y+1	; 0x01
    1694:	fa 81       	ldd	r31, Y+2	; 0x02
    1696:	22 81       	ldd	r18, Z+2	; 0x02
    1698:	33 81       	ldd	r19, Z+3	; 0x03
    169a:	e9 81       	ldd	r30, Y+1	; 0x01
    169c:	fa 81       	ldd	r31, Y+2	; 0x02
    169e:	84 8d       	ldd	r24, Z+28	; 0x1c
    16a0:	88 2f       	mov	r24, r24
    16a2:	90 e0       	ldi	r25, 0x00	; 0
    16a4:	90 95       	com	r25
    16a6:	81 95       	neg	r24
    16a8:	9f 4f       	sbci	r25, 0xFF	; 255
    16aa:	82 0f       	add	r24, r18
    16ac:	93 1f       	adc	r25, r19
    16ae:	e9 81       	ldd	r30, Y+1	; 0x01
    16b0:	fa 81       	ldd	r31, Y+2	; 0x02
    16b2:	97 83       	std	Z+7, r25	; 0x07
    16b4:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    16b6:	e9 81       	ldd	r30, Y+1	; 0x01
    16b8:	fa 81       	ldd	r31, Y+2	; 0x02
    16ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    16bc:	8f 5f       	subi	r24, 0xFF	; 255
    16be:	e9 81       	ldd	r30, Y+1	; 0x01
    16c0:	fa 81       	ldd	r31, Y+2	; 0x02
    16c2:	82 8f       	std	Z+26, r24	; 0x1a
}
    16c4:	0f 90       	pop	r0
    16c6:	0f 90       	pop	r0
    16c8:	0f 90       	pop	r0
    16ca:	0f 90       	pop	r0
    16cc:	0f 90       	pop	r0
    16ce:	cf 91       	pop	r28
    16d0:	df 91       	pop	r29
    16d2:	08 95       	ret

000016d4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    16d4:	df 93       	push	r29
    16d6:	cf 93       	push	r28
    16d8:	00 d0       	rcall	.+0      	; 0x16da <prvCopyDataFromQueue+0x6>
    16da:	00 d0       	rcall	.+0      	; 0x16dc <prvCopyDataFromQueue+0x8>
    16dc:	cd b7       	in	r28, 0x3d	; 61
    16de:	de b7       	in	r29, 0x3e	; 62
    16e0:	9a 83       	std	Y+2, r25	; 0x02
    16e2:	89 83       	std	Y+1, r24	; 0x01
    16e4:	7c 83       	std	Y+4, r23	; 0x04
    16e6:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    16e8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ea:	fa 81       	ldd	r31, Y+2	; 0x02
    16ec:	80 81       	ld	r24, Z
    16ee:	91 81       	ldd	r25, Z+1	; 0x01
    16f0:	00 97       	sbiw	r24, 0x00	; 0
    16f2:	89 f1       	breq	.+98     	; 0x1756 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    16f4:	e9 81       	ldd	r30, Y+1	; 0x01
    16f6:	fa 81       	ldd	r31, Y+2	; 0x02
    16f8:	26 81       	ldd	r18, Z+6	; 0x06
    16fa:	37 81       	ldd	r19, Z+7	; 0x07
    16fc:	e9 81       	ldd	r30, Y+1	; 0x01
    16fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1700:	84 8d       	ldd	r24, Z+28	; 0x1c
    1702:	88 2f       	mov	r24, r24
    1704:	90 e0       	ldi	r25, 0x00	; 0
    1706:	82 0f       	add	r24, r18
    1708:	93 1f       	adc	r25, r19
    170a:	e9 81       	ldd	r30, Y+1	; 0x01
    170c:	fa 81       	ldd	r31, Y+2	; 0x02
    170e:	97 83       	std	Z+7, r25	; 0x07
    1710:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1712:	e9 81       	ldd	r30, Y+1	; 0x01
    1714:	fa 81       	ldd	r31, Y+2	; 0x02
    1716:	26 81       	ldd	r18, Z+6	; 0x06
    1718:	37 81       	ldd	r19, Z+7	; 0x07
    171a:	e9 81       	ldd	r30, Y+1	; 0x01
    171c:	fa 81       	ldd	r31, Y+2	; 0x02
    171e:	82 81       	ldd	r24, Z+2	; 0x02
    1720:	93 81       	ldd	r25, Z+3	; 0x03
    1722:	28 17       	cp	r18, r24
    1724:	39 07       	cpc	r19, r25
    1726:	40 f0       	brcs	.+16     	; 0x1738 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1728:	e9 81       	ldd	r30, Y+1	; 0x01
    172a:	fa 81       	ldd	r31, Y+2	; 0x02
    172c:	80 81       	ld	r24, Z
    172e:	91 81       	ldd	r25, Z+1	; 0x01
    1730:	e9 81       	ldd	r30, Y+1	; 0x01
    1732:	fa 81       	ldd	r31, Y+2	; 0x02
    1734:	97 83       	std	Z+7, r25	; 0x07
    1736:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1738:	e9 81       	ldd	r30, Y+1	; 0x01
    173a:	fa 81       	ldd	r31, Y+2	; 0x02
    173c:	46 81       	ldd	r20, Z+6	; 0x06
    173e:	57 81       	ldd	r21, Z+7	; 0x07
    1740:	e9 81       	ldd	r30, Y+1	; 0x01
    1742:	fa 81       	ldd	r31, Y+2	; 0x02
    1744:	84 8d       	ldd	r24, Z+28	; 0x1c
    1746:	28 2f       	mov	r18, r24
    1748:	30 e0       	ldi	r19, 0x00	; 0
    174a:	8b 81       	ldd	r24, Y+3	; 0x03
    174c:	9c 81       	ldd	r25, Y+4	; 0x04
    174e:	ba 01       	movw	r22, r20
    1750:	a9 01       	movw	r20, r18
    1752:	0e 94 5d 13 	call	0x26ba	; 0x26ba <memcpy>
	}
}
    1756:	0f 90       	pop	r0
    1758:	0f 90       	pop	r0
    175a:	0f 90       	pop	r0
    175c:	0f 90       	pop	r0
    175e:	cf 91       	pop	r28
    1760:	df 91       	pop	r29
    1762:	08 95       	ret

00001764 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1764:	df 93       	push	r29
    1766:	cf 93       	push	r28
    1768:	00 d0       	rcall	.+0      	; 0x176a <prvUnlockQueue+0x6>
    176a:	cd b7       	in	r28, 0x3d	; 61
    176c:	de b7       	in	r29, 0x3e	; 62
    176e:	9a 83       	std	Y+2, r25	; 0x02
    1770:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1772:	0f b6       	in	r0, 0x3f	; 63
    1774:	f8 94       	cli
    1776:	0f 92       	push	r0
    1778:	15 c0       	rjmp	.+42     	; 0x17a4 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    177a:	e9 81       	ldd	r30, Y+1	; 0x01
    177c:	fa 81       	ldd	r31, Y+2	; 0x02
    177e:	81 89       	ldd	r24, Z+17	; 0x11
    1780:	88 23       	and	r24, r24
    1782:	a9 f0       	breq	.+42     	; 0x17ae <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1784:	89 81       	ldd	r24, Y+1	; 0x01
    1786:	9a 81       	ldd	r25, Y+2	; 0x02
    1788:	41 96       	adiw	r24, 0x11	; 17
    178a:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <xTaskRemoveFromEventList>
    178e:	88 23       	and	r24, r24
    1790:	11 f0       	breq	.+4      	; 0x1796 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1792:	0e 94 c8 11 	call	0x2390	; 0x2390 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1796:	e9 81       	ldd	r30, Y+1	; 0x01
    1798:	fa 81       	ldd	r31, Y+2	; 0x02
    179a:	86 8d       	ldd	r24, Z+30	; 0x1e
    179c:	81 50       	subi	r24, 0x01	; 1
    179e:	e9 81       	ldd	r30, Y+1	; 0x01
    17a0:	fa 81       	ldd	r31, Y+2	; 0x02
    17a2:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    17a4:	e9 81       	ldd	r30, Y+1	; 0x01
    17a6:	fa 81       	ldd	r31, Y+2	; 0x02
    17a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    17aa:	18 16       	cp	r1, r24
    17ac:	34 f3       	brlt	.-52     	; 0x177a <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    17ae:	e9 81       	ldd	r30, Y+1	; 0x01
    17b0:	fa 81       	ldd	r31, Y+2	; 0x02
    17b2:	8f ef       	ldi	r24, 0xFF	; 255
    17b4:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    17b6:	0f 90       	pop	r0
    17b8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    17ba:	0f b6       	in	r0, 0x3f	; 63
    17bc:	f8 94       	cli
    17be:	0f 92       	push	r0
    17c0:	15 c0       	rjmp	.+42     	; 0x17ec <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17c2:	e9 81       	ldd	r30, Y+1	; 0x01
    17c4:	fa 81       	ldd	r31, Y+2	; 0x02
    17c6:	80 85       	ldd	r24, Z+8	; 0x08
    17c8:	88 23       	and	r24, r24
    17ca:	a9 f0       	breq	.+42     	; 0x17f6 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17cc:	89 81       	ldd	r24, Y+1	; 0x01
    17ce:	9a 81       	ldd	r25, Y+2	; 0x02
    17d0:	08 96       	adiw	r24, 0x08	; 8
    17d2:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <xTaskRemoveFromEventList>
    17d6:	88 23       	and	r24, r24
    17d8:	11 f0       	breq	.+4      	; 0x17de <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    17da:	0e 94 c8 11 	call	0x2390	; 0x2390 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    17de:	e9 81       	ldd	r30, Y+1	; 0x01
    17e0:	fa 81       	ldd	r31, Y+2	; 0x02
    17e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    17e4:	81 50       	subi	r24, 0x01	; 1
    17e6:	e9 81       	ldd	r30, Y+1	; 0x01
    17e8:	fa 81       	ldd	r31, Y+2	; 0x02
    17ea:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    17ec:	e9 81       	ldd	r30, Y+1	; 0x01
    17ee:	fa 81       	ldd	r31, Y+2	; 0x02
    17f0:	85 8d       	ldd	r24, Z+29	; 0x1d
    17f2:	18 16       	cp	r1, r24
    17f4:	34 f3       	brlt	.-52     	; 0x17c2 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    17f6:	e9 81       	ldd	r30, Y+1	; 0x01
    17f8:	fa 81       	ldd	r31, Y+2	; 0x02
    17fa:	8f ef       	ldi	r24, 0xFF	; 255
    17fc:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    17fe:	0f 90       	pop	r0
    1800:	0f be       	out	0x3f, r0	; 63
}
    1802:	0f 90       	pop	r0
    1804:	0f 90       	pop	r0
    1806:	cf 91       	pop	r28
    1808:	df 91       	pop	r29
    180a:	08 95       	ret

0000180c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    180c:	df 93       	push	r29
    180e:	cf 93       	push	r28
    1810:	00 d0       	rcall	.+0      	; 0x1812 <prvIsQueueEmpty+0x6>
    1812:	0f 92       	push	r0
    1814:	cd b7       	in	r28, 0x3d	; 61
    1816:	de b7       	in	r29, 0x3e	; 62
    1818:	9b 83       	std	Y+3, r25	; 0x03
    181a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    181c:	0f b6       	in	r0, 0x3f	; 63
    181e:	f8 94       	cli
    1820:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1822:	ea 81       	ldd	r30, Y+2	; 0x02
    1824:	fb 81       	ldd	r31, Y+3	; 0x03
    1826:	82 8d       	ldd	r24, Z+26	; 0x1a
    1828:	19 82       	std	Y+1, r1	; 0x01
    182a:	88 23       	and	r24, r24
    182c:	11 f4       	brne	.+4      	; 0x1832 <prvIsQueueEmpty+0x26>
    182e:	81 e0       	ldi	r24, 0x01	; 1
    1830:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1832:	0f 90       	pop	r0
    1834:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1836:	89 81       	ldd	r24, Y+1	; 0x01
}
    1838:	0f 90       	pop	r0
    183a:	0f 90       	pop	r0
    183c:	0f 90       	pop	r0
    183e:	cf 91       	pop	r28
    1840:	df 91       	pop	r29
    1842:	08 95       	ret

00001844 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1844:	df 93       	push	r29
    1846:	cf 93       	push	r28
    1848:	00 d0       	rcall	.+0      	; 0x184a <xQueueIsQueueEmptyFromISR+0x6>
    184a:	0f 92       	push	r0
    184c:	cd b7       	in	r28, 0x3d	; 61
    184e:	de b7       	in	r29, 0x3e	; 62
    1850:	9b 83       	std	Y+3, r25	; 0x03
    1852:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1854:	ea 81       	ldd	r30, Y+2	; 0x02
    1856:	fb 81       	ldd	r31, Y+3	; 0x03
    1858:	82 8d       	ldd	r24, Z+26	; 0x1a
    185a:	19 82       	std	Y+1, r1	; 0x01
    185c:	88 23       	and	r24, r24
    185e:	11 f4       	brne	.+4      	; 0x1864 <xQueueIsQueueEmptyFromISR+0x20>
    1860:	81 e0       	ldi	r24, 0x01	; 1
    1862:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1864:	89 81       	ldd	r24, Y+1	; 0x01
}
    1866:	0f 90       	pop	r0
    1868:	0f 90       	pop	r0
    186a:	0f 90       	pop	r0
    186c:	cf 91       	pop	r28
    186e:	df 91       	pop	r29
    1870:	08 95       	ret

00001872 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1872:	df 93       	push	r29
    1874:	cf 93       	push	r28
    1876:	00 d0       	rcall	.+0      	; 0x1878 <prvIsQueueFull+0x6>
    1878:	0f 92       	push	r0
    187a:	cd b7       	in	r28, 0x3d	; 61
    187c:	de b7       	in	r29, 0x3e	; 62
    187e:	9b 83       	std	Y+3, r25	; 0x03
    1880:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1888:	ea 81       	ldd	r30, Y+2	; 0x02
    188a:	fb 81       	ldd	r31, Y+3	; 0x03
    188c:	92 8d       	ldd	r25, Z+26	; 0x1a
    188e:	ea 81       	ldd	r30, Y+2	; 0x02
    1890:	fb 81       	ldd	r31, Y+3	; 0x03
    1892:	83 8d       	ldd	r24, Z+27	; 0x1b
    1894:	19 82       	std	Y+1, r1	; 0x01
    1896:	98 17       	cp	r25, r24
    1898:	11 f4       	brne	.+4      	; 0x189e <prvIsQueueFull+0x2c>
    189a:	81 e0       	ldi	r24, 0x01	; 1
    189c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    189e:	0f 90       	pop	r0
    18a0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    18a2:	89 81       	ldd	r24, Y+1	; 0x01
}
    18a4:	0f 90       	pop	r0
    18a6:	0f 90       	pop	r0
    18a8:	0f 90       	pop	r0
    18aa:	cf 91       	pop	r28
    18ac:	df 91       	pop	r29
    18ae:	08 95       	ret

000018b0 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    18b0:	df 93       	push	r29
    18b2:	cf 93       	push	r28
    18b4:	00 d0       	rcall	.+0      	; 0x18b6 <xQueueIsQueueFullFromISR+0x6>
    18b6:	0f 92       	push	r0
    18b8:	cd b7       	in	r28, 0x3d	; 61
    18ba:	de b7       	in	r29, 0x3e	; 62
    18bc:	9b 83       	std	Y+3, r25	; 0x03
    18be:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    18c0:	ea 81       	ldd	r30, Y+2	; 0x02
    18c2:	fb 81       	ldd	r31, Y+3	; 0x03
    18c4:	92 8d       	ldd	r25, Z+26	; 0x1a
    18c6:	ea 81       	ldd	r30, Y+2	; 0x02
    18c8:	fb 81       	ldd	r31, Y+3	; 0x03
    18ca:	83 8d       	ldd	r24, Z+27	; 0x1b
    18cc:	19 82       	std	Y+1, r1	; 0x01
    18ce:	98 17       	cp	r25, r24
    18d0:	11 f4       	brne	.+4      	; 0x18d6 <xQueueIsQueueFullFromISR+0x26>
    18d2:	81 e0       	ldi	r24, 0x01	; 1
    18d4:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    18d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    18d8:	0f 90       	pop	r0
    18da:	0f 90       	pop	r0
    18dc:	0f 90       	pop	r0
    18de:	cf 91       	pop	r28
    18e0:	df 91       	pop	r29
    18e2:	08 95       	ret

000018e4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    18e4:	af 92       	push	r10
    18e6:	bf 92       	push	r11
    18e8:	cf 92       	push	r12
    18ea:	df 92       	push	r13
    18ec:	ef 92       	push	r14
    18ee:	ff 92       	push	r15
    18f0:	0f 93       	push	r16
    18f2:	1f 93       	push	r17
    18f4:	df 93       	push	r29
    18f6:	cf 93       	push	r28
    18f8:	cd b7       	in	r28, 0x3d	; 61
    18fa:	de b7       	in	r29, 0x3e	; 62
    18fc:	64 97       	sbiw	r28, 0x14	; 20
    18fe:	0f b6       	in	r0, 0x3f	; 63
    1900:	f8 94       	cli
    1902:	de bf       	out	0x3e, r29	; 62
    1904:	0f be       	out	0x3f, r0	; 63
    1906:	cd bf       	out	0x3d, r28	; 61
    1908:	9f 83       	std	Y+7, r25	; 0x07
    190a:	8e 83       	std	Y+6, r24	; 0x06
    190c:	79 87       	std	Y+9, r23	; 0x09
    190e:	68 87       	std	Y+8, r22	; 0x08
    1910:	5b 87       	std	Y+11, r21	; 0x0b
    1912:	4a 87       	std	Y+10, r20	; 0x0a
    1914:	3d 87       	std	Y+13, r19	; 0x0d
    1916:	2c 87       	std	Y+12, r18	; 0x0c
    1918:	0e 87       	std	Y+14, r16	; 0x0e
    191a:	f8 8a       	std	Y+16, r15	; 0x10
    191c:	ef 86       	std	Y+15, r14	; 0x0f
    191e:	da 8a       	std	Y+18, r13	; 0x12
    1920:	c9 8a       	std	Y+17, r12	; 0x11
    1922:	bc 8a       	std	Y+20, r11	; 0x14
    1924:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1926:	8a 85       	ldd	r24, Y+10	; 0x0a
    1928:	9b 85       	ldd	r25, Y+11	; 0x0b
    192a:	29 89       	ldd	r18, Y+17	; 0x11
    192c:	3a 89       	ldd	r19, Y+18	; 0x12
    192e:	b9 01       	movw	r22, r18
    1930:	0e 94 f7 12 	call	0x25ee	; 0x25ee <prvAllocateTCBAndStack>
    1934:	9c 83       	std	Y+4, r25	; 0x04
    1936:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1938:	8b 81       	ldd	r24, Y+3	; 0x03
    193a:	9c 81       	ldd	r25, Y+4	; 0x04
    193c:	00 97       	sbiw	r24, 0x00	; 0
    193e:	09 f4       	brne	.+2      	; 0x1942 <xTaskGenericCreate+0x5e>
    1940:	99 c0       	rjmp	.+306    	; 0x1a74 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1942:	eb 81       	ldd	r30, Y+3	; 0x03
    1944:	fc 81       	ldd	r31, Y+4	; 0x04
    1946:	27 89       	ldd	r18, Z+23	; 0x17
    1948:	30 8d       	ldd	r19, Z+24	; 0x18
    194a:	8a 85       	ldd	r24, Y+10	; 0x0a
    194c:	9b 85       	ldd	r25, Y+11	; 0x0b
    194e:	01 97       	sbiw	r24, 0x01	; 1
    1950:	82 0f       	add	r24, r18
    1952:	93 1f       	adc	r25, r19
    1954:	9a 83       	std	Y+2, r25	; 0x02
    1956:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1958:	8b 81       	ldd	r24, Y+3	; 0x03
    195a:	9c 81       	ldd	r25, Y+4	; 0x04
    195c:	28 85       	ldd	r18, Y+8	; 0x08
    195e:	39 85       	ldd	r19, Y+9	; 0x09
    1960:	eb 89       	ldd	r30, Y+19	; 0x13
    1962:	fc 89       	ldd	r31, Y+20	; 0x14
    1964:	aa 85       	ldd	r26, Y+10	; 0x0a
    1966:	bb 85       	ldd	r27, Y+11	; 0x0b
    1968:	b9 01       	movw	r22, r18
    196a:	4e 85       	ldd	r20, Y+14	; 0x0e
    196c:	9f 01       	movw	r18, r30
    196e:	8d 01       	movw	r16, r26
    1970:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1974:	89 81       	ldd	r24, Y+1	; 0x01
    1976:	9a 81       	ldd	r25, Y+2	; 0x02
    1978:	2e 81       	ldd	r18, Y+6	; 0x06
    197a:	3f 81       	ldd	r19, Y+7	; 0x07
    197c:	4c 85       	ldd	r20, Y+12	; 0x0c
    197e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1980:	b9 01       	movw	r22, r18
    1982:	0e 94 1e 05 	call	0xa3c	; 0xa3c <pxPortInitialiseStack>
    1986:	eb 81       	ldd	r30, Y+3	; 0x03
    1988:	fc 81       	ldd	r31, Y+4	; 0x04
    198a:	91 83       	std	Z+1, r25	; 0x01
    198c:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    198e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1990:	98 89       	ldd	r25, Y+16	; 0x10
    1992:	00 97       	sbiw	r24, 0x00	; 0
    1994:	31 f0       	breq	.+12     	; 0x19a2 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1996:	ef 85       	ldd	r30, Y+15	; 0x0f
    1998:	f8 89       	ldd	r31, Y+16	; 0x10
    199a:	8b 81       	ldd	r24, Y+3	; 0x03
    199c:	9c 81       	ldd	r25, Y+4	; 0x04
    199e:	91 83       	std	Z+1, r25	; 0x01
    19a0:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    19a2:	0f b6       	in	r0, 0x3f	; 63
    19a4:	f8 94       	cli
    19a6:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    19a8:	80 91 ff 02 	lds	r24, 0x02FF
    19ac:	8f 5f       	subi	r24, 0xFF	; 255
    19ae:	80 93 ff 02 	sts	0x02FF, r24
			if( pxCurrentTCB == NULL )
    19b2:	80 91 fc 02 	lds	r24, 0x02FC
    19b6:	90 91 fd 02 	lds	r25, 0x02FD
    19ba:	00 97       	sbiw	r24, 0x00	; 0
    19bc:	69 f4       	brne	.+26     	; 0x19d8 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    19be:	8b 81       	ldd	r24, Y+3	; 0x03
    19c0:	9c 81       	ldd	r25, Y+4	; 0x04
    19c2:	90 93 fd 02 	sts	0x02FD, r25
    19c6:	80 93 fc 02 	sts	0x02FC, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    19ca:	80 91 ff 02 	lds	r24, 0x02FF
    19ce:	81 30       	cpi	r24, 0x01	; 1
    19d0:	a9 f4       	brne	.+42     	; 0x19fc <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    19d2:	0e 94 33 12 	call	0x2466	; 0x2466 <prvInitialiseTaskLists>
    19d6:	12 c0       	rjmp	.+36     	; 0x19fc <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    19d8:	80 91 04 03 	lds	r24, 0x0304
    19dc:	88 23       	and	r24, r24
    19de:	71 f4       	brne	.+28     	; 0x19fc <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    19e0:	e0 91 fc 02 	lds	r30, 0x02FC
    19e4:	f0 91 fd 02 	lds	r31, 0x02FD
    19e8:	96 89       	ldd	r25, Z+22	; 0x16
    19ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    19ec:	89 17       	cp	r24, r25
    19ee:	30 f0       	brcs	.+12     	; 0x19fc <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    19f0:	8b 81       	ldd	r24, Y+3	; 0x03
    19f2:	9c 81       	ldd	r25, Y+4	; 0x04
    19f4:	90 93 fd 02 	sts	0x02FD, r25
    19f8:	80 93 fc 02 	sts	0x02FC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    19fc:	eb 81       	ldd	r30, Y+3	; 0x03
    19fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1a00:	96 89       	ldd	r25, Z+22	; 0x16
    1a02:	80 91 02 03 	lds	r24, 0x0302
    1a06:	89 17       	cp	r24, r25
    1a08:	28 f4       	brcc	.+10     	; 0x1a14 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1a0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a0e:	86 89       	ldd	r24, Z+22	; 0x16
    1a10:	80 93 02 03 	sts	0x0302, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1a14:	80 91 09 03 	lds	r24, 0x0309
    1a18:	8f 5f       	subi	r24, 0xFF	; 255
    1a1a:	80 93 09 03 	sts	0x0309, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1a1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a20:	fc 81       	ldd	r31, Y+4	; 0x04
    1a22:	96 89       	ldd	r25, Z+22	; 0x16
    1a24:	80 91 03 03 	lds	r24, 0x0303
    1a28:	89 17       	cp	r24, r25
    1a2a:	28 f4       	brcc	.+10     	; 0x1a36 <xTaskGenericCreate+0x152>
    1a2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a30:	86 89       	ldd	r24, Z+22	; 0x16
    1a32:	80 93 03 03 	sts	0x0303, r24
    1a36:	eb 81       	ldd	r30, Y+3	; 0x03
    1a38:	fc 81       	ldd	r31, Y+4	; 0x04
    1a3a:	86 89       	ldd	r24, Z+22	; 0x16
    1a3c:	28 2f       	mov	r18, r24
    1a3e:	30 e0       	ldi	r19, 0x00	; 0
    1a40:	c9 01       	movw	r24, r18
    1a42:	88 0f       	add	r24, r24
    1a44:	99 1f       	adc	r25, r25
    1a46:	88 0f       	add	r24, r24
    1a48:	99 1f       	adc	r25, r25
    1a4a:	88 0f       	add	r24, r24
    1a4c:	99 1f       	adc	r25, r25
    1a4e:	82 0f       	add	r24, r18
    1a50:	93 1f       	adc	r25, r19
    1a52:	ac 01       	movw	r20, r24
    1a54:	46 5f       	subi	r20, 0xF6	; 246
    1a56:	5c 4f       	sbci	r21, 0xFC	; 252
    1a58:	8b 81       	ldd	r24, Y+3	; 0x03
    1a5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a5c:	9c 01       	movw	r18, r24
    1a5e:	2e 5f       	subi	r18, 0xFE	; 254
    1a60:	3f 4f       	sbci	r19, 0xFF	; 255
    1a62:	ca 01       	movw	r24, r20
    1a64:	b9 01       	movw	r22, r18
    1a66:	0e 94 1d 04 	call	0x83a	; 0x83a <vListInsertEnd>

			xReturn = pdPASS;
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1a6e:	0f 90       	pop	r0
    1a70:	0f be       	out	0x3f, r0	; 63
    1a72:	02 c0       	rjmp	.+4      	; 0x1a78 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1a74:	8f ef       	ldi	r24, 0xFF	; 255
    1a76:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1a78:	8d 81       	ldd	r24, Y+5	; 0x05
    1a7a:	81 30       	cpi	r24, 0x01	; 1
    1a7c:	71 f4       	brne	.+28     	; 0x1a9a <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1a7e:	80 91 04 03 	lds	r24, 0x0304
    1a82:	88 23       	and	r24, r24
    1a84:	51 f0       	breq	.+20     	; 0x1a9a <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1a86:	e0 91 fc 02 	lds	r30, 0x02FC
    1a8a:	f0 91 fd 02 	lds	r31, 0x02FD
    1a8e:	96 89       	ldd	r25, Z+22	; 0x16
    1a90:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a92:	98 17       	cp	r25, r24
    1a94:	10 f4       	brcc	.+4      	; 0x1a9a <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1a96:	0e 94 dd 06 	call	0xdba	; 0xdba <vPortYield>
			}
		}
	}

	return xReturn;
    1a9a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1a9c:	64 96       	adiw	r28, 0x14	; 20
    1a9e:	0f b6       	in	r0, 0x3f	; 63
    1aa0:	f8 94       	cli
    1aa2:	de bf       	out	0x3e, r29	; 62
    1aa4:	0f be       	out	0x3f, r0	; 63
    1aa6:	cd bf       	out	0x3d, r28	; 61
    1aa8:	cf 91       	pop	r28
    1aaa:	df 91       	pop	r29
    1aac:	1f 91       	pop	r17
    1aae:	0f 91       	pop	r16
    1ab0:	ff 90       	pop	r15
    1ab2:	ef 90       	pop	r14
    1ab4:	df 90       	pop	r13
    1ab6:	cf 90       	pop	r12
    1ab8:	bf 90       	pop	r11
    1aba:	af 90       	pop	r10
    1abc:	08 95       	ret

00001abe <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1abe:	df 93       	push	r29
    1ac0:	cf 93       	push	r28
    1ac2:	00 d0       	rcall	.+0      	; 0x1ac4 <vTaskDelete+0x6>
    1ac4:	00 d0       	rcall	.+0      	; 0x1ac6 <vTaskDelete+0x8>
    1ac6:	00 d0       	rcall	.+0      	; 0x1ac8 <vTaskDelete+0xa>
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
    1acc:	9c 83       	std	Y+4, r25	; 0x04
    1ace:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1ad0:	0f b6       	in	r0, 0x3f	; 63
    1ad2:	f8 94       	cli
    1ad4:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1ad6:	20 91 fc 02 	lds	r18, 0x02FC
    1ada:	30 91 fd 02 	lds	r19, 0x02FD
    1ade:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae2:	82 17       	cp	r24, r18
    1ae4:	93 07       	cpc	r25, r19
    1ae6:	11 f4       	brne	.+4      	; 0x1aec <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1ae8:	1c 82       	std	Y+4, r1	; 0x04
    1aea:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1aec:	8b 81       	ldd	r24, Y+3	; 0x03
    1aee:	9c 81       	ldd	r25, Y+4	; 0x04
    1af0:	00 97       	sbiw	r24, 0x00	; 0
    1af2:	39 f4       	brne	.+14     	; 0x1b02 <vTaskDelete+0x44>
    1af4:	80 91 fc 02 	lds	r24, 0x02FC
    1af8:	90 91 fd 02 	lds	r25, 0x02FD
    1afc:	9e 83       	std	Y+6, r25	; 0x06
    1afe:	8d 83       	std	Y+5, r24	; 0x05
    1b00:	04 c0       	rjmp	.+8      	; 0x1b0a <vTaskDelete+0x4c>
    1b02:	8b 81       	ldd	r24, Y+3	; 0x03
    1b04:	9c 81       	ldd	r25, Y+4	; 0x04
    1b06:	9e 83       	std	Y+6, r25	; 0x06
    1b08:	8d 83       	std	Y+5, r24	; 0x05
    1b0a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b0c:	9e 81       	ldd	r25, Y+6	; 0x06
    1b0e:	9a 83       	std	Y+2, r25	; 0x02
    1b10:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1b12:	89 81       	ldd	r24, Y+1	; 0x01
    1b14:	9a 81       	ldd	r25, Y+2	; 0x02
    1b16:	02 96       	adiw	r24, 0x02	; 2
    1b18:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1b1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b20:	84 89       	ldd	r24, Z+20	; 0x14
    1b22:	95 89       	ldd	r25, Z+21	; 0x15
    1b24:	00 97       	sbiw	r24, 0x00	; 0
    1b26:	29 f0       	breq	.+10     	; 0x1b32 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1b28:	89 81       	ldd	r24, Y+1	; 0x01
    1b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b2c:	0c 96       	adiw	r24, 0x0c	; 12
    1b2e:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1b32:	89 81       	ldd	r24, Y+1	; 0x01
    1b34:	9a 81       	ldd	r25, Y+2	; 0x02
    1b36:	9c 01       	movw	r18, r24
    1b38:	2e 5f       	subi	r18, 0xFE	; 254
    1b3a:	3f 4f       	sbci	r19, 0xFF	; 255
    1b3c:	86 e5       	ldi	r24, 0x56	; 86
    1b3e:	93 e0       	ldi	r25, 0x03	; 3
    1b40:	b9 01       	movw	r22, r18
    1b42:	0e 94 1d 04 	call	0x83a	; 0x83a <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1b46:	80 91 fe 02 	lds	r24, 0x02FE
    1b4a:	8f 5f       	subi	r24, 0xFF	; 255
    1b4c:	80 93 fe 02 	sts	0x02FE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1b50:	80 91 09 03 	lds	r24, 0x0309
    1b54:	8f 5f       	subi	r24, 0xFF	; 255
    1b56:	80 93 09 03 	sts	0x0309, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1b5a:	0f 90       	pop	r0
    1b5c:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1b5e:	80 91 04 03 	lds	r24, 0x0304
    1b62:	88 23       	and	r24, r24
    1b64:	31 f0       	breq	.+12     	; 0x1b72 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1b66:	8b 81       	ldd	r24, Y+3	; 0x03
    1b68:	9c 81       	ldd	r25, Y+4	; 0x04
    1b6a:	00 97       	sbiw	r24, 0x00	; 0
    1b6c:	11 f4       	brne	.+4      	; 0x1b72 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1b6e:	0e 94 dd 06 	call	0xdba	; 0xdba <vPortYield>
			}
		}
	}
    1b72:	26 96       	adiw	r28, 0x06	; 6
    1b74:	0f b6       	in	r0, 0x3f	; 63
    1b76:	f8 94       	cli
    1b78:	de bf       	out	0x3e, r29	; 62
    1b7a:	0f be       	out	0x3f, r0	; 63
    1b7c:	cd bf       	out	0x3d, r28	; 61
    1b7e:	cf 91       	pop	r28
    1b80:	df 91       	pop	r29
    1b82:	08 95       	ret

00001b84 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1b84:	df 93       	push	r29
    1b86:	cf 93       	push	r28
    1b88:	cd b7       	in	r28, 0x3d	; 61
    1b8a:	de b7       	in	r29, 0x3e	; 62
    1b8c:	28 97       	sbiw	r28, 0x08	; 8
    1b8e:	0f b6       	in	r0, 0x3f	; 63
    1b90:	f8 94       	cli
    1b92:	de bf       	out	0x3e, r29	; 62
    1b94:	0f be       	out	0x3f, r0	; 63
    1b96:	cd bf       	out	0x3d, r28	; 61
    1b98:	9e 83       	std	Y+6, r25	; 0x06
    1b9a:	8d 83       	std	Y+5, r24	; 0x05
    1b9c:	78 87       	std	Y+8, r23	; 0x08
    1b9e:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1ba0:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1ba2:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1ba6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ba8:	fe 81       	ldd	r31, Y+6	; 0x06
    1baa:	20 81       	ld	r18, Z
    1bac:	31 81       	ldd	r19, Z+1	; 0x01
    1bae:	8f 81       	ldd	r24, Y+7	; 0x07
    1bb0:	98 85       	ldd	r25, Y+8	; 0x08
    1bb2:	82 0f       	add	r24, r18
    1bb4:	93 1f       	adc	r25, r19
    1bb6:	9c 83       	std	Y+4, r25	; 0x04
    1bb8:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1bba:	ed 81       	ldd	r30, Y+5	; 0x05
    1bbc:	fe 81       	ldd	r31, Y+6	; 0x06
    1bbe:	20 81       	ld	r18, Z
    1bc0:	31 81       	ldd	r19, Z+1	; 0x01
    1bc2:	80 91 00 03 	lds	r24, 0x0300
    1bc6:	90 91 01 03 	lds	r25, 0x0301
    1bca:	82 17       	cp	r24, r18
    1bcc:	93 07       	cpc	r25, r19
    1bce:	a8 f4       	brcc	.+42     	; 0x1bfa <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1bd0:	ed 81       	ldd	r30, Y+5	; 0x05
    1bd2:	fe 81       	ldd	r31, Y+6	; 0x06
    1bd4:	20 81       	ld	r18, Z
    1bd6:	31 81       	ldd	r19, Z+1	; 0x01
    1bd8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bda:	9c 81       	ldd	r25, Y+4	; 0x04
    1bdc:	82 17       	cp	r24, r18
    1bde:	93 07       	cpc	r25, r19
    1be0:	00 f5       	brcc	.+64     	; 0x1c22 <vTaskDelayUntil+0x9e>
    1be2:	20 91 00 03 	lds	r18, 0x0300
    1be6:	30 91 01 03 	lds	r19, 0x0301
    1bea:	8b 81       	ldd	r24, Y+3	; 0x03
    1bec:	9c 81       	ldd	r25, Y+4	; 0x04
    1bee:	28 17       	cp	r18, r24
    1bf0:	39 07       	cpc	r19, r25
    1bf2:	b8 f4       	brcc	.+46     	; 0x1c22 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1bf4:	81 e0       	ldi	r24, 0x01	; 1
    1bf6:	89 83       	std	Y+1, r24	; 0x01
    1bf8:	14 c0       	rjmp	.+40     	; 0x1c22 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1bfa:	ed 81       	ldd	r30, Y+5	; 0x05
    1bfc:	fe 81       	ldd	r31, Y+6	; 0x06
    1bfe:	20 81       	ld	r18, Z
    1c00:	31 81       	ldd	r19, Z+1	; 0x01
    1c02:	8b 81       	ldd	r24, Y+3	; 0x03
    1c04:	9c 81       	ldd	r25, Y+4	; 0x04
    1c06:	82 17       	cp	r24, r18
    1c08:	93 07       	cpc	r25, r19
    1c0a:	48 f0       	brcs	.+18     	; 0x1c1e <vTaskDelayUntil+0x9a>
    1c0c:	20 91 00 03 	lds	r18, 0x0300
    1c10:	30 91 01 03 	lds	r19, 0x0301
    1c14:	8b 81       	ldd	r24, Y+3	; 0x03
    1c16:	9c 81       	ldd	r25, Y+4	; 0x04
    1c18:	28 17       	cp	r18, r24
    1c1a:	39 07       	cpc	r19, r25
    1c1c:	10 f4       	brcc	.+4      	; 0x1c22 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c1e:	81 e0       	ldi	r24, 0x01	; 1
    1c20:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1c22:	ed 81       	ldd	r30, Y+5	; 0x05
    1c24:	fe 81       	ldd	r31, Y+6	; 0x06
    1c26:	8b 81       	ldd	r24, Y+3	; 0x03
    1c28:	9c 81       	ldd	r25, Y+4	; 0x04
    1c2a:	91 83       	std	Z+1, r25	; 0x01
    1c2c:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1c2e:	89 81       	ldd	r24, Y+1	; 0x01
    1c30:	88 23       	and	r24, r24
    1c32:	59 f0       	breq	.+22     	; 0x1c4a <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c34:	80 91 fc 02 	lds	r24, 0x02FC
    1c38:	90 91 fd 02 	lds	r25, 0x02FD
    1c3c:	02 96       	adiw	r24, 0x02	; 2
    1c3e:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c42:	8b 81       	ldd	r24, Y+3	; 0x03
    1c44:	9c 81       	ldd	r25, Y+4	; 0x04
    1c46:	0e 94 ae 12 	call	0x255c	; 0x255c <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1c4a:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskResumeAll>
    1c4e:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c50:	8a 81       	ldd	r24, Y+2	; 0x02
    1c52:	88 23       	and	r24, r24
    1c54:	11 f4       	brne	.+4      	; 0x1c5a <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1c56:	0e 94 dd 06 	call	0xdba	; 0xdba <vPortYield>
		}
	}
    1c5a:	28 96       	adiw	r28, 0x08	; 8
    1c5c:	0f b6       	in	r0, 0x3f	; 63
    1c5e:	f8 94       	cli
    1c60:	de bf       	out	0x3e, r29	; 62
    1c62:	0f be       	out	0x3f, r0	; 63
    1c64:	cd bf       	out	0x3d, r28	; 61
    1c66:	cf 91       	pop	r28
    1c68:	df 91       	pop	r29
    1c6a:	08 95       	ret

00001c6c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1c6c:	df 93       	push	r29
    1c6e:	cf 93       	push	r28
    1c70:	00 d0       	rcall	.+0      	; 0x1c72 <vTaskDelay+0x6>
    1c72:	00 d0       	rcall	.+0      	; 0x1c74 <vTaskDelay+0x8>
    1c74:	0f 92       	push	r0
    1c76:	cd b7       	in	r28, 0x3d	; 61
    1c78:	de b7       	in	r29, 0x3e	; 62
    1c7a:	9d 83       	std	Y+5, r25	; 0x05
    1c7c:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1c7e:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1c80:	8c 81       	ldd	r24, Y+4	; 0x04
    1c82:	9d 81       	ldd	r25, Y+5	; 0x05
    1c84:	00 97       	sbiw	r24, 0x00	; 0
    1c86:	d1 f0       	breq	.+52     	; 0x1cbc <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1c88:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1c8c:	20 91 00 03 	lds	r18, 0x0300
    1c90:	30 91 01 03 	lds	r19, 0x0301
    1c94:	8c 81       	ldd	r24, Y+4	; 0x04
    1c96:	9d 81       	ldd	r25, Y+5	; 0x05
    1c98:	82 0f       	add	r24, r18
    1c9a:	93 1f       	adc	r25, r19
    1c9c:	9b 83       	std	Y+3, r25	; 0x03
    1c9e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ca0:	80 91 fc 02 	lds	r24, 0x02FC
    1ca4:	90 91 fd 02 	lds	r25, 0x02FD
    1ca8:	02 96       	adiw	r24, 0x02	; 2
    1caa:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1cae:	8a 81       	ldd	r24, Y+2	; 0x02
    1cb0:	9b 81       	ldd	r25, Y+3	; 0x03
    1cb2:	0e 94 ae 12 	call	0x255c	; 0x255c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1cb6:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskResumeAll>
    1cba:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1cbc:	89 81       	ldd	r24, Y+1	; 0x01
    1cbe:	88 23       	and	r24, r24
    1cc0:	11 f4       	brne	.+4      	; 0x1cc6 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1cc2:	0e 94 dd 06 	call	0xdba	; 0xdba <vPortYield>
		}
	}
    1cc6:	0f 90       	pop	r0
    1cc8:	0f 90       	pop	r0
    1cca:	0f 90       	pop	r0
    1ccc:	0f 90       	pop	r0
    1cce:	0f 90       	pop	r0
    1cd0:	cf 91       	pop	r28
    1cd2:	df 91       	pop	r29
    1cd4:	08 95       	ret

00001cd6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1cd6:	af 92       	push	r10
    1cd8:	bf 92       	push	r11
    1cda:	cf 92       	push	r12
    1cdc:	df 92       	push	r13
    1cde:	ef 92       	push	r14
    1ce0:	ff 92       	push	r15
    1ce2:	0f 93       	push	r16
    1ce4:	df 93       	push	r29
    1ce6:	cf 93       	push	r28
    1ce8:	0f 92       	push	r0
    1cea:	cd b7       	in	r28, 0x3d	; 61
    1cec:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1cee:	20 e6       	ldi	r18, 0x60	; 96
    1cf0:	30 e0       	ldi	r19, 0x00	; 0
    1cf2:	82 ed       	ldi	r24, 0xD2	; 210
    1cf4:	91 e1       	ldi	r25, 0x11	; 17
    1cf6:	b9 01       	movw	r22, r18
    1cf8:	45 e5       	ldi	r20, 0x55	; 85
    1cfa:	50 e0       	ldi	r21, 0x00	; 0
    1cfc:	20 e0       	ldi	r18, 0x00	; 0
    1cfe:	30 e0       	ldi	r19, 0x00	; 0
    1d00:	00 e0       	ldi	r16, 0x00	; 0
    1d02:	ee 24       	eor	r14, r14
    1d04:	ff 24       	eor	r15, r15
    1d06:	cc 24       	eor	r12, r12
    1d08:	dd 24       	eor	r13, r13
    1d0a:	aa 24       	eor	r10, r10
    1d0c:	bb 24       	eor	r11, r11
    1d0e:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <xTaskGenericCreate>
    1d12:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1d14:	89 81       	ldd	r24, Y+1	; 0x01
    1d16:	81 30       	cpi	r24, 0x01	; 1
    1d18:	51 f4       	brne	.+20     	; 0x1d2e <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1d1a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1d1c:	81 e0       	ldi	r24, 0x01	; 1
    1d1e:	80 93 04 03 	sts	0x0304, r24
		xTickCount = ( portTickType ) 0U;
    1d22:	10 92 01 03 	sts	0x0301, r1
    1d26:	10 92 00 03 	sts	0x0300, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1d2a:	0e 94 a1 06 	call	0xd42	; 0xd42 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1d2e:	0f 90       	pop	r0
    1d30:	cf 91       	pop	r28
    1d32:	df 91       	pop	r29
    1d34:	0f 91       	pop	r16
    1d36:	ff 90       	pop	r15
    1d38:	ef 90       	pop	r14
    1d3a:	df 90       	pop	r13
    1d3c:	cf 90       	pop	r12
    1d3e:	bf 90       	pop	r11
    1d40:	af 90       	pop	r10
    1d42:	08 95       	ret

00001d44 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1d44:	df 93       	push	r29
    1d46:	cf 93       	push	r28
    1d48:	cd b7       	in	r28, 0x3d	; 61
    1d4a:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1d4c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1d4e:	10 92 04 03 	sts	0x0304, r1
	vPortEndScheduler();
    1d52:	0e 94 d6 06 	call	0xdac	; 0xdac <vPortEndScheduler>
}
    1d56:	cf 91       	pop	r28
    1d58:	df 91       	pop	r29
    1d5a:	08 95       	ret

00001d5c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1d5c:	df 93       	push	r29
    1d5e:	cf 93       	push	r28
    1d60:	cd b7       	in	r28, 0x3d	; 61
    1d62:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1d64:	80 91 05 03 	lds	r24, 0x0305
    1d68:	8f 5f       	subi	r24, 0xFF	; 255
    1d6a:	80 93 05 03 	sts	0x0305, r24
}
    1d6e:	cf 91       	pop	r28
    1d70:	df 91       	pop	r29
    1d72:	08 95       	ret

00001d74 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1d74:	df 93       	push	r29
    1d76:	cf 93       	push	r28
    1d78:	00 d0       	rcall	.+0      	; 0x1d7a <xTaskResumeAll+0x6>
    1d7a:	00 d0       	rcall	.+0      	; 0x1d7c <xTaskResumeAll+0x8>
    1d7c:	cd b7       	in	r28, 0x3d	; 61
    1d7e:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1d80:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1d82:	0f b6       	in	r0, 0x3f	; 63
    1d84:	f8 94       	cli
    1d86:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1d88:	80 91 05 03 	lds	r24, 0x0305
    1d8c:	81 50       	subi	r24, 0x01	; 1
    1d8e:	80 93 05 03 	sts	0x0305, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1d92:	80 91 05 03 	lds	r24, 0x0305
    1d96:	88 23       	and	r24, r24
    1d98:	09 f0       	breq	.+2      	; 0x1d9c <xTaskResumeAll+0x28>
    1d9a:	6c c0       	rjmp	.+216    	; 0x1e74 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1d9c:	80 91 ff 02 	lds	r24, 0x02FF
    1da0:	88 23       	and	r24, r24
    1da2:	09 f4       	brne	.+2      	; 0x1da6 <xTaskResumeAll+0x32>
    1da4:	67 c0       	rjmp	.+206    	; 0x1e74 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1da6:	19 82       	std	Y+1, r1	; 0x01
    1da8:	41 c0       	rjmp	.+130    	; 0x1e2c <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1daa:	e0 91 52 03 	lds	r30, 0x0352
    1dae:	f0 91 53 03 	lds	r31, 0x0353
    1db2:	86 81       	ldd	r24, Z+6	; 0x06
    1db4:	97 81       	ldd	r25, Z+7	; 0x07
    1db6:	9c 83       	std	Y+4, r25	; 0x04
    1db8:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    1dba:	8b 81       	ldd	r24, Y+3	; 0x03
    1dbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1dbe:	0c 96       	adiw	r24, 0x0c	; 12
    1dc0:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1dc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc8:	02 96       	adiw	r24, 0x02	; 2
    1dca:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1dce:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd0:	fc 81       	ldd	r31, Y+4	; 0x04
    1dd2:	96 89       	ldd	r25, Z+22	; 0x16
    1dd4:	80 91 03 03 	lds	r24, 0x0303
    1dd8:	89 17       	cp	r24, r25
    1dda:	28 f4       	brcc	.+10     	; 0x1de6 <xTaskResumeAll+0x72>
    1ddc:	eb 81       	ldd	r30, Y+3	; 0x03
    1dde:	fc 81       	ldd	r31, Y+4	; 0x04
    1de0:	86 89       	ldd	r24, Z+22	; 0x16
    1de2:	80 93 03 03 	sts	0x0303, r24
    1de6:	eb 81       	ldd	r30, Y+3	; 0x03
    1de8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dea:	86 89       	ldd	r24, Z+22	; 0x16
    1dec:	28 2f       	mov	r18, r24
    1dee:	30 e0       	ldi	r19, 0x00	; 0
    1df0:	c9 01       	movw	r24, r18
    1df2:	88 0f       	add	r24, r24
    1df4:	99 1f       	adc	r25, r25
    1df6:	88 0f       	add	r24, r24
    1df8:	99 1f       	adc	r25, r25
    1dfa:	88 0f       	add	r24, r24
    1dfc:	99 1f       	adc	r25, r25
    1dfe:	82 0f       	add	r24, r18
    1e00:	93 1f       	adc	r25, r19
    1e02:	86 5f       	subi	r24, 0xF6	; 246
    1e04:	9c 4f       	sbci	r25, 0xFC	; 252
    1e06:	2b 81       	ldd	r18, Y+3	; 0x03
    1e08:	3c 81       	ldd	r19, Y+4	; 0x04
    1e0a:	2e 5f       	subi	r18, 0xFE	; 254
    1e0c:	3f 4f       	sbci	r19, 0xFF	; 255
    1e0e:	b9 01       	movw	r22, r18
    1e10:	0e 94 1d 04 	call	0x83a	; 0x83a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e14:	eb 81       	ldd	r30, Y+3	; 0x03
    1e16:	fc 81       	ldd	r31, Y+4	; 0x04
    1e18:	96 89       	ldd	r25, Z+22	; 0x16
    1e1a:	e0 91 fc 02 	lds	r30, 0x02FC
    1e1e:	f0 91 fd 02 	lds	r31, 0x02FD
    1e22:	86 89       	ldd	r24, Z+22	; 0x16
    1e24:	98 17       	cp	r25, r24
    1e26:	10 f0       	brcs	.+4      	; 0x1e2c <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    1e28:	81 e0       	ldi	r24, 0x01	; 1
    1e2a:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1e2c:	80 91 4d 03 	lds	r24, 0x034D
    1e30:	88 23       	and	r24, r24
    1e32:	09 f0       	breq	.+2      	; 0x1e36 <xTaskResumeAll+0xc2>
    1e34:	ba cf       	rjmp	.-140    	; 0x1daa <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1e36:	80 91 06 03 	lds	r24, 0x0306
    1e3a:	88 23       	and	r24, r24
    1e3c:	71 f0       	breq	.+28     	; 0x1e5a <xTaskResumeAll+0xe6>
    1e3e:	07 c0       	rjmp	.+14     	; 0x1e4e <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1e40:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <vTaskIncrementTick>
						--uxMissedTicks;
    1e44:	80 91 06 03 	lds	r24, 0x0306
    1e48:	81 50       	subi	r24, 0x01	; 1
    1e4a:	80 93 06 03 	sts	0x0306, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1e4e:	80 91 06 03 	lds	r24, 0x0306
    1e52:	88 23       	and	r24, r24
    1e54:	a9 f7       	brne	.-22     	; 0x1e40 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    1e56:	81 e0       	ldi	r24, 0x01	; 1
    1e58:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1e5a:	89 81       	ldd	r24, Y+1	; 0x01
    1e5c:	81 30       	cpi	r24, 0x01	; 1
    1e5e:	21 f0       	breq	.+8      	; 0x1e68 <xTaskResumeAll+0xf4>
    1e60:	80 91 07 03 	lds	r24, 0x0307
    1e64:	81 30       	cpi	r24, 0x01	; 1
    1e66:	31 f4       	brne	.+12     	; 0x1e74 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    1e68:	81 e0       	ldi	r24, 0x01	; 1
    1e6a:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    1e6c:	10 92 07 03 	sts	0x0307, r1
					portYIELD_WITHIN_API();
    1e70:	0e 94 dd 06 	call	0xdba	; 0xdba <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1e74:	0f 90       	pop	r0
    1e76:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    1e78:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1e7a:	0f 90       	pop	r0
    1e7c:	0f 90       	pop	r0
    1e7e:	0f 90       	pop	r0
    1e80:	0f 90       	pop	r0
    1e82:	cf 91       	pop	r28
    1e84:	df 91       	pop	r29
    1e86:	08 95       	ret

00001e88 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    1e88:	df 93       	push	r29
    1e8a:	cf 93       	push	r28
    1e8c:	00 d0       	rcall	.+0      	; 0x1e8e <xTaskGetTickCount+0x6>
    1e8e:	cd b7       	in	r28, 0x3d	; 61
    1e90:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1e92:	0f b6       	in	r0, 0x3f	; 63
    1e94:	f8 94       	cli
    1e96:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1e98:	80 91 00 03 	lds	r24, 0x0300
    1e9c:	90 91 01 03 	lds	r25, 0x0301
    1ea0:	9a 83       	std	Y+2, r25	; 0x02
    1ea2:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1ea4:	0f 90       	pop	r0
    1ea6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    1ea8:	89 81       	ldd	r24, Y+1	; 0x01
    1eaa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1eac:	0f 90       	pop	r0
    1eae:	0f 90       	pop	r0
    1eb0:	cf 91       	pop	r28
    1eb2:	df 91       	pop	r29
    1eb4:	08 95       	ret

00001eb6 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    1eb6:	df 93       	push	r29
    1eb8:	cf 93       	push	r28
    1eba:	00 d0       	rcall	.+0      	; 0x1ebc <xTaskGetTickCountFromISR+0x6>
    1ebc:	0f 92       	push	r0
    1ebe:	cd b7       	in	r28, 0x3d	; 61
    1ec0:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1ec2:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    1ec4:	80 91 00 03 	lds	r24, 0x0300
    1ec8:	90 91 01 03 	lds	r25, 0x0301
    1ecc:	9b 83       	std	Y+3, r25	; 0x03
    1ece:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1ed0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ed2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    1ed4:	0f 90       	pop	r0
    1ed6:	0f 90       	pop	r0
    1ed8:	0f 90       	pop	r0
    1eda:	cf 91       	pop	r28
    1edc:	df 91       	pop	r29
    1ede:	08 95       	ret

00001ee0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    1ee0:	df 93       	push	r29
    1ee2:	cf 93       	push	r28
    1ee4:	cd b7       	in	r28, 0x3d	; 61
    1ee6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1ee8:	80 91 ff 02 	lds	r24, 0x02FF
}
    1eec:	cf 91       	pop	r28
    1eee:	df 91       	pop	r29
    1ef0:	08 95       	ret

00001ef2 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1ef2:	df 93       	push	r29
    1ef4:	cf 93       	push	r28
    1ef6:	00 d0       	rcall	.+0      	; 0x1ef8 <vTaskIncrementTick+0x6>
    1ef8:	00 d0       	rcall	.+0      	; 0x1efa <vTaskIncrementTick+0x8>
    1efa:	00 d0       	rcall	.+0      	; 0x1efc <vTaskIncrementTick+0xa>
    1efc:	cd b7       	in	r28, 0x3d	; 61
    1efe:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1f00:	80 91 05 03 	lds	r24, 0x0305
    1f04:	88 23       	and	r24, r24
    1f06:	09 f0       	breq	.+2      	; 0x1f0a <vTaskIncrementTick+0x18>
    1f08:	bb c0       	rjmp	.+374    	; 0x2080 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    1f0a:	80 91 00 03 	lds	r24, 0x0300
    1f0e:	90 91 01 03 	lds	r25, 0x0301
    1f12:	01 96       	adiw	r24, 0x01	; 1
    1f14:	90 93 01 03 	sts	0x0301, r25
    1f18:	80 93 00 03 	sts	0x0300, r24
		if( xTickCount == ( portTickType ) 0U )
    1f1c:	80 91 00 03 	lds	r24, 0x0300
    1f20:	90 91 01 03 	lds	r25, 0x0301
    1f24:	00 97       	sbiw	r24, 0x00	; 0
    1f26:	d1 f5       	brne	.+116    	; 0x1f9c <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1f28:	80 91 49 03 	lds	r24, 0x0349
    1f2c:	90 91 4a 03 	lds	r25, 0x034A
    1f30:	9c 83       	std	Y+4, r25	; 0x04
    1f32:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1f34:	80 91 4b 03 	lds	r24, 0x034B
    1f38:	90 91 4c 03 	lds	r25, 0x034C
    1f3c:	90 93 4a 03 	sts	0x034A, r25
    1f40:	80 93 49 03 	sts	0x0349, r24
			pxOverflowDelayedTaskList = pxTemp;
    1f44:	8b 81       	ldd	r24, Y+3	; 0x03
    1f46:	9c 81       	ldd	r25, Y+4	; 0x04
    1f48:	90 93 4c 03 	sts	0x034C, r25
    1f4c:	80 93 4b 03 	sts	0x034B, r24
			xNumOfOverflows++;
    1f50:	80 91 08 03 	lds	r24, 0x0308
    1f54:	8f 5f       	subi	r24, 0xFF	; 255
    1f56:	80 93 08 03 	sts	0x0308, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1f5a:	e0 91 49 03 	lds	r30, 0x0349
    1f5e:	f0 91 4a 03 	lds	r31, 0x034A
    1f62:	80 81       	ld	r24, Z
    1f64:	88 23       	and	r24, r24
    1f66:	39 f4       	brne	.+14     	; 0x1f76 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1f68:	8f ef       	ldi	r24, 0xFF	; 255
    1f6a:	9f ef       	ldi	r25, 0xFF	; 255
    1f6c:	90 93 66 00 	sts	0x0066, r25
    1f70:	80 93 65 00 	sts	0x0065, r24
    1f74:	13 c0       	rjmp	.+38     	; 0x1f9c <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1f76:	e0 91 49 03 	lds	r30, 0x0349
    1f7a:	f0 91 4a 03 	lds	r31, 0x034A
    1f7e:	05 80       	ldd	r0, Z+5	; 0x05
    1f80:	f6 81       	ldd	r31, Z+6	; 0x06
    1f82:	e0 2d       	mov	r30, r0
    1f84:	86 81       	ldd	r24, Z+6	; 0x06
    1f86:	97 81       	ldd	r25, Z+7	; 0x07
    1f88:	9e 83       	std	Y+6, r25	; 0x06
    1f8a:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1f8c:	ed 81       	ldd	r30, Y+5	; 0x05
    1f8e:	fe 81       	ldd	r31, Y+6	; 0x06
    1f90:	82 81       	ldd	r24, Z+2	; 0x02
    1f92:	93 81       	ldd	r25, Z+3	; 0x03
    1f94:	90 93 66 00 	sts	0x0066, r25
    1f98:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1f9c:	20 91 00 03 	lds	r18, 0x0300
    1fa0:	30 91 01 03 	lds	r19, 0x0301
    1fa4:	80 91 65 00 	lds	r24, 0x0065
    1fa8:	90 91 66 00 	lds	r25, 0x0066
    1fac:	28 17       	cp	r18, r24
    1fae:	39 07       	cpc	r19, r25
    1fb0:	08 f4       	brcc	.+2      	; 0x1fb4 <vTaskIncrementTick+0xc2>
    1fb2:	6b c0       	rjmp	.+214    	; 0x208a <vTaskIncrementTick+0x198>
    1fb4:	e0 91 49 03 	lds	r30, 0x0349
    1fb8:	f0 91 4a 03 	lds	r31, 0x034A
    1fbc:	80 81       	ld	r24, Z
    1fbe:	88 23       	and	r24, r24
    1fc0:	39 f4       	brne	.+14     	; 0x1fd0 <vTaskIncrementTick+0xde>
    1fc2:	8f ef       	ldi	r24, 0xFF	; 255
    1fc4:	9f ef       	ldi	r25, 0xFF	; 255
    1fc6:	90 93 66 00 	sts	0x0066, r25
    1fca:	80 93 65 00 	sts	0x0065, r24
    1fce:	5d c0       	rjmp	.+186    	; 0x208a <vTaskIncrementTick+0x198>
    1fd0:	e0 91 49 03 	lds	r30, 0x0349
    1fd4:	f0 91 4a 03 	lds	r31, 0x034A
    1fd8:	05 80       	ldd	r0, Z+5	; 0x05
    1fda:	f6 81       	ldd	r31, Z+6	; 0x06
    1fdc:	e0 2d       	mov	r30, r0
    1fde:	86 81       	ldd	r24, Z+6	; 0x06
    1fe0:	97 81       	ldd	r25, Z+7	; 0x07
    1fe2:	9e 83       	std	Y+6, r25	; 0x06
    1fe4:	8d 83       	std	Y+5, r24	; 0x05
    1fe6:	ed 81       	ldd	r30, Y+5	; 0x05
    1fe8:	fe 81       	ldd	r31, Y+6	; 0x06
    1fea:	82 81       	ldd	r24, Z+2	; 0x02
    1fec:	93 81       	ldd	r25, Z+3	; 0x03
    1fee:	9a 83       	std	Y+2, r25	; 0x02
    1ff0:	89 83       	std	Y+1, r24	; 0x01
    1ff2:	20 91 00 03 	lds	r18, 0x0300
    1ff6:	30 91 01 03 	lds	r19, 0x0301
    1ffa:	89 81       	ldd	r24, Y+1	; 0x01
    1ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffe:	28 17       	cp	r18, r24
    2000:	39 07       	cpc	r19, r25
    2002:	38 f4       	brcc	.+14     	; 0x2012 <vTaskIncrementTick+0x120>
    2004:	89 81       	ldd	r24, Y+1	; 0x01
    2006:	9a 81       	ldd	r25, Y+2	; 0x02
    2008:	90 93 66 00 	sts	0x0066, r25
    200c:	80 93 65 00 	sts	0x0065, r24
    2010:	3c c0       	rjmp	.+120    	; 0x208a <vTaskIncrementTick+0x198>
    2012:	8d 81       	ldd	r24, Y+5	; 0x05
    2014:	9e 81       	ldd	r25, Y+6	; 0x06
    2016:	02 96       	adiw	r24, 0x02	; 2
    2018:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
    201c:	ed 81       	ldd	r30, Y+5	; 0x05
    201e:	fe 81       	ldd	r31, Y+6	; 0x06
    2020:	84 89       	ldd	r24, Z+20	; 0x14
    2022:	95 89       	ldd	r25, Z+21	; 0x15
    2024:	00 97       	sbiw	r24, 0x00	; 0
    2026:	29 f0       	breq	.+10     	; 0x2032 <vTaskIncrementTick+0x140>
    2028:	8d 81       	ldd	r24, Y+5	; 0x05
    202a:	9e 81       	ldd	r25, Y+6	; 0x06
    202c:	0c 96       	adiw	r24, 0x0c	; 12
    202e:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
    2032:	ed 81       	ldd	r30, Y+5	; 0x05
    2034:	fe 81       	ldd	r31, Y+6	; 0x06
    2036:	96 89       	ldd	r25, Z+22	; 0x16
    2038:	80 91 03 03 	lds	r24, 0x0303
    203c:	89 17       	cp	r24, r25
    203e:	28 f4       	brcc	.+10     	; 0x204a <vTaskIncrementTick+0x158>
    2040:	ed 81       	ldd	r30, Y+5	; 0x05
    2042:	fe 81       	ldd	r31, Y+6	; 0x06
    2044:	86 89       	ldd	r24, Z+22	; 0x16
    2046:	80 93 03 03 	sts	0x0303, r24
    204a:	ed 81       	ldd	r30, Y+5	; 0x05
    204c:	fe 81       	ldd	r31, Y+6	; 0x06
    204e:	86 89       	ldd	r24, Z+22	; 0x16
    2050:	28 2f       	mov	r18, r24
    2052:	30 e0       	ldi	r19, 0x00	; 0
    2054:	c9 01       	movw	r24, r18
    2056:	88 0f       	add	r24, r24
    2058:	99 1f       	adc	r25, r25
    205a:	88 0f       	add	r24, r24
    205c:	99 1f       	adc	r25, r25
    205e:	88 0f       	add	r24, r24
    2060:	99 1f       	adc	r25, r25
    2062:	82 0f       	add	r24, r18
    2064:	93 1f       	adc	r25, r19
    2066:	ac 01       	movw	r20, r24
    2068:	46 5f       	subi	r20, 0xF6	; 246
    206a:	5c 4f       	sbci	r21, 0xFC	; 252
    206c:	8d 81       	ldd	r24, Y+5	; 0x05
    206e:	9e 81       	ldd	r25, Y+6	; 0x06
    2070:	9c 01       	movw	r18, r24
    2072:	2e 5f       	subi	r18, 0xFE	; 254
    2074:	3f 4f       	sbci	r19, 0xFF	; 255
    2076:	ca 01       	movw	r24, r20
    2078:	b9 01       	movw	r22, r18
    207a:	0e 94 1d 04 	call	0x83a	; 0x83a <vListInsertEnd>
    207e:	9a cf       	rjmp	.-204    	; 0x1fb4 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2080:	80 91 06 03 	lds	r24, 0x0306
    2084:	8f 5f       	subi	r24, 0xFF	; 255
    2086:	80 93 06 03 	sts	0x0306, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    208a:	26 96       	adiw	r28, 0x06	; 6
    208c:	0f b6       	in	r0, 0x3f	; 63
    208e:	f8 94       	cli
    2090:	de bf       	out	0x3e, r29	; 62
    2092:	0f be       	out	0x3f, r0	; 63
    2094:	cd bf       	out	0x3d, r28	; 61
    2096:	cf 91       	pop	r28
    2098:	df 91       	pop	r29
    209a:	08 95       	ret

0000209c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    209c:	df 93       	push	r29
    209e:	cf 93       	push	r28
    20a0:	00 d0       	rcall	.+0      	; 0x20a2 <vTaskSwitchContext+0x6>
    20a2:	cd b7       	in	r28, 0x3d	; 61
    20a4:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    20a6:	80 91 05 03 	lds	r24, 0x0305
    20aa:	88 23       	and	r24, r24
    20ac:	49 f0       	breq	.+18     	; 0x20c0 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    20ae:	81 e0       	ldi	r24, 0x01	; 1
    20b0:	80 93 07 03 	sts	0x0307, r24
    20b4:	54 c0       	rjmp	.+168    	; 0x215e <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    20b6:	80 91 03 03 	lds	r24, 0x0303
    20ba:	81 50       	subi	r24, 0x01	; 1
    20bc:	80 93 03 03 	sts	0x0303, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20c0:	80 91 03 03 	lds	r24, 0x0303
    20c4:	28 2f       	mov	r18, r24
    20c6:	30 e0       	ldi	r19, 0x00	; 0
    20c8:	c9 01       	movw	r24, r18
    20ca:	88 0f       	add	r24, r24
    20cc:	99 1f       	adc	r25, r25
    20ce:	88 0f       	add	r24, r24
    20d0:	99 1f       	adc	r25, r25
    20d2:	88 0f       	add	r24, r24
    20d4:	99 1f       	adc	r25, r25
    20d6:	82 0f       	add	r24, r18
    20d8:	93 1f       	adc	r25, r19
    20da:	fc 01       	movw	r30, r24
    20dc:	e6 5f       	subi	r30, 0xF6	; 246
    20de:	fc 4f       	sbci	r31, 0xFC	; 252
    20e0:	80 81       	ld	r24, Z
    20e2:	88 23       	and	r24, r24
    20e4:	41 f3       	breq	.-48     	; 0x20b6 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    20e6:	80 91 03 03 	lds	r24, 0x0303
    20ea:	28 2f       	mov	r18, r24
    20ec:	30 e0       	ldi	r19, 0x00	; 0
    20ee:	c9 01       	movw	r24, r18
    20f0:	88 0f       	add	r24, r24
    20f2:	99 1f       	adc	r25, r25
    20f4:	88 0f       	add	r24, r24
    20f6:	99 1f       	adc	r25, r25
    20f8:	88 0f       	add	r24, r24
    20fa:	99 1f       	adc	r25, r25
    20fc:	82 0f       	add	r24, r18
    20fe:	93 1f       	adc	r25, r19
    2100:	86 5f       	subi	r24, 0xF6	; 246
    2102:	9c 4f       	sbci	r25, 0xFC	; 252
    2104:	9a 83       	std	Y+2, r25	; 0x02
    2106:	89 83       	std	Y+1, r24	; 0x01
    2108:	e9 81       	ldd	r30, Y+1	; 0x01
    210a:	fa 81       	ldd	r31, Y+2	; 0x02
    210c:	01 80       	ldd	r0, Z+1	; 0x01
    210e:	f2 81       	ldd	r31, Z+2	; 0x02
    2110:	e0 2d       	mov	r30, r0
    2112:	82 81       	ldd	r24, Z+2	; 0x02
    2114:	93 81       	ldd	r25, Z+3	; 0x03
    2116:	e9 81       	ldd	r30, Y+1	; 0x01
    2118:	fa 81       	ldd	r31, Y+2	; 0x02
    211a:	92 83       	std	Z+2, r25	; 0x02
    211c:	81 83       	std	Z+1, r24	; 0x01
    211e:	e9 81       	ldd	r30, Y+1	; 0x01
    2120:	fa 81       	ldd	r31, Y+2	; 0x02
    2122:	21 81       	ldd	r18, Z+1	; 0x01
    2124:	32 81       	ldd	r19, Z+2	; 0x02
    2126:	89 81       	ldd	r24, Y+1	; 0x01
    2128:	9a 81       	ldd	r25, Y+2	; 0x02
    212a:	03 96       	adiw	r24, 0x03	; 3
    212c:	28 17       	cp	r18, r24
    212e:	39 07       	cpc	r19, r25
    2130:	59 f4       	brne	.+22     	; 0x2148 <vTaskSwitchContext+0xac>
    2132:	e9 81       	ldd	r30, Y+1	; 0x01
    2134:	fa 81       	ldd	r31, Y+2	; 0x02
    2136:	01 80       	ldd	r0, Z+1	; 0x01
    2138:	f2 81       	ldd	r31, Z+2	; 0x02
    213a:	e0 2d       	mov	r30, r0
    213c:	82 81       	ldd	r24, Z+2	; 0x02
    213e:	93 81       	ldd	r25, Z+3	; 0x03
    2140:	e9 81       	ldd	r30, Y+1	; 0x01
    2142:	fa 81       	ldd	r31, Y+2	; 0x02
    2144:	92 83       	std	Z+2, r25	; 0x02
    2146:	81 83       	std	Z+1, r24	; 0x01
    2148:	e9 81       	ldd	r30, Y+1	; 0x01
    214a:	fa 81       	ldd	r31, Y+2	; 0x02
    214c:	01 80       	ldd	r0, Z+1	; 0x01
    214e:	f2 81       	ldd	r31, Z+2	; 0x02
    2150:	e0 2d       	mov	r30, r0
    2152:	86 81       	ldd	r24, Z+6	; 0x06
    2154:	97 81       	ldd	r25, Z+7	; 0x07
    2156:	90 93 fd 02 	sts	0x02FD, r25
    215a:	80 93 fc 02 	sts	0x02FC, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    215e:	0f 90       	pop	r0
    2160:	0f 90       	pop	r0
    2162:	cf 91       	pop	r28
    2164:	df 91       	pop	r29
    2166:	08 95       	ret

00002168 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2168:	df 93       	push	r29
    216a:	cf 93       	push	r28
    216c:	00 d0       	rcall	.+0      	; 0x216e <vTaskPlaceOnEventList+0x6>
    216e:	00 d0       	rcall	.+0      	; 0x2170 <vTaskPlaceOnEventList+0x8>
    2170:	00 d0       	rcall	.+0      	; 0x2172 <vTaskPlaceOnEventList+0xa>
    2172:	cd b7       	in	r28, 0x3d	; 61
    2174:	de b7       	in	r29, 0x3e	; 62
    2176:	9c 83       	std	Y+4, r25	; 0x04
    2178:	8b 83       	std	Y+3, r24	; 0x03
    217a:	7e 83       	std	Y+6, r23	; 0x06
    217c:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    217e:	4b 81       	ldd	r20, Y+3	; 0x03
    2180:	5c 81       	ldd	r21, Y+4	; 0x04
    2182:	80 91 fc 02 	lds	r24, 0x02FC
    2186:	90 91 fd 02 	lds	r25, 0x02FD
    218a:	9c 01       	movw	r18, r24
    218c:	24 5f       	subi	r18, 0xF4	; 244
    218e:	3f 4f       	sbci	r19, 0xFF	; 255
    2190:	ca 01       	movw	r24, r20
    2192:	b9 01       	movw	r22, r18
    2194:	0e 94 69 04 	call	0x8d2	; 0x8d2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2198:	80 91 fc 02 	lds	r24, 0x02FC
    219c:	90 91 fd 02 	lds	r25, 0x02FD
    21a0:	02 96       	adiw	r24, 0x02	; 2
    21a2:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    21a6:	20 91 00 03 	lds	r18, 0x0300
    21aa:	30 91 01 03 	lds	r19, 0x0301
    21ae:	8d 81       	ldd	r24, Y+5	; 0x05
    21b0:	9e 81       	ldd	r25, Y+6	; 0x06
    21b2:	82 0f       	add	r24, r18
    21b4:	93 1f       	adc	r25, r19
    21b6:	9a 83       	std	Y+2, r25	; 0x02
    21b8:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    21ba:	89 81       	ldd	r24, Y+1	; 0x01
    21bc:	9a 81       	ldd	r25, Y+2	; 0x02
    21be:	0e 94 ae 12 	call	0x255c	; 0x255c <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    21c2:	26 96       	adiw	r28, 0x06	; 6
    21c4:	0f b6       	in	r0, 0x3f	; 63
    21c6:	f8 94       	cli
    21c8:	de bf       	out	0x3e, r29	; 62
    21ca:	0f be       	out	0x3f, r0	; 63
    21cc:	cd bf       	out	0x3d, r28	; 61
    21ce:	cf 91       	pop	r28
    21d0:	df 91       	pop	r29
    21d2:	08 95       	ret

000021d4 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    21d4:	df 93       	push	r29
    21d6:	cf 93       	push	r28
    21d8:	00 d0       	rcall	.+0      	; 0x21da <xTaskRemoveFromEventList+0x6>
    21da:	00 d0       	rcall	.+0      	; 0x21dc <xTaskRemoveFromEventList+0x8>
    21dc:	0f 92       	push	r0
    21de:	cd b7       	in	r28, 0x3d	; 61
    21e0:	de b7       	in	r29, 0x3e	; 62
    21e2:	9d 83       	std	Y+5, r25	; 0x05
    21e4:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    21e6:	ec 81       	ldd	r30, Y+4	; 0x04
    21e8:	fd 81       	ldd	r31, Y+5	; 0x05
    21ea:	05 80       	ldd	r0, Z+5	; 0x05
    21ec:	f6 81       	ldd	r31, Z+6	; 0x06
    21ee:	e0 2d       	mov	r30, r0
    21f0:	86 81       	ldd	r24, Z+6	; 0x06
    21f2:	97 81       	ldd	r25, Z+7	; 0x07
    21f4:	9b 83       	std	Y+3, r25	; 0x03
    21f6:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    21f8:	8a 81       	ldd	r24, Y+2	; 0x02
    21fa:	9b 81       	ldd	r25, Y+3	; 0x03
    21fc:	0c 96       	adiw	r24, 0x0c	; 12
    21fe:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2202:	80 91 05 03 	lds	r24, 0x0305
    2206:	88 23       	and	r24, r24
    2208:	61 f5       	brne	.+88     	; 0x2262 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    220a:	8a 81       	ldd	r24, Y+2	; 0x02
    220c:	9b 81       	ldd	r25, Y+3	; 0x03
    220e:	02 96       	adiw	r24, 0x02	; 2
    2210:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2214:	ea 81       	ldd	r30, Y+2	; 0x02
    2216:	fb 81       	ldd	r31, Y+3	; 0x03
    2218:	96 89       	ldd	r25, Z+22	; 0x16
    221a:	80 91 03 03 	lds	r24, 0x0303
    221e:	89 17       	cp	r24, r25
    2220:	28 f4       	brcc	.+10     	; 0x222c <xTaskRemoveFromEventList+0x58>
    2222:	ea 81       	ldd	r30, Y+2	; 0x02
    2224:	fb 81       	ldd	r31, Y+3	; 0x03
    2226:	86 89       	ldd	r24, Z+22	; 0x16
    2228:	80 93 03 03 	sts	0x0303, r24
    222c:	ea 81       	ldd	r30, Y+2	; 0x02
    222e:	fb 81       	ldd	r31, Y+3	; 0x03
    2230:	86 89       	ldd	r24, Z+22	; 0x16
    2232:	28 2f       	mov	r18, r24
    2234:	30 e0       	ldi	r19, 0x00	; 0
    2236:	c9 01       	movw	r24, r18
    2238:	88 0f       	add	r24, r24
    223a:	99 1f       	adc	r25, r25
    223c:	88 0f       	add	r24, r24
    223e:	99 1f       	adc	r25, r25
    2240:	88 0f       	add	r24, r24
    2242:	99 1f       	adc	r25, r25
    2244:	82 0f       	add	r24, r18
    2246:	93 1f       	adc	r25, r19
    2248:	ac 01       	movw	r20, r24
    224a:	46 5f       	subi	r20, 0xF6	; 246
    224c:	5c 4f       	sbci	r21, 0xFC	; 252
    224e:	8a 81       	ldd	r24, Y+2	; 0x02
    2250:	9b 81       	ldd	r25, Y+3	; 0x03
    2252:	9c 01       	movw	r18, r24
    2254:	2e 5f       	subi	r18, 0xFE	; 254
    2256:	3f 4f       	sbci	r19, 0xFF	; 255
    2258:	ca 01       	movw	r24, r20
    225a:	b9 01       	movw	r22, r18
    225c:	0e 94 1d 04 	call	0x83a	; 0x83a <vListInsertEnd>
    2260:	0a c0       	rjmp	.+20     	; 0x2276 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2262:	8a 81       	ldd	r24, Y+2	; 0x02
    2264:	9b 81       	ldd	r25, Y+3	; 0x03
    2266:	9c 01       	movw	r18, r24
    2268:	24 5f       	subi	r18, 0xF4	; 244
    226a:	3f 4f       	sbci	r19, 0xFF	; 255
    226c:	8d e4       	ldi	r24, 0x4D	; 77
    226e:	93 e0       	ldi	r25, 0x03	; 3
    2270:	b9 01       	movw	r22, r18
    2272:	0e 94 1d 04 	call	0x83a	; 0x83a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2276:	ea 81       	ldd	r30, Y+2	; 0x02
    2278:	fb 81       	ldd	r31, Y+3	; 0x03
    227a:	96 89       	ldd	r25, Z+22	; 0x16
    227c:	e0 91 fc 02 	lds	r30, 0x02FC
    2280:	f0 91 fd 02 	lds	r31, 0x02FD
    2284:	86 89       	ldd	r24, Z+22	; 0x16
    2286:	98 17       	cp	r25, r24
    2288:	18 f0       	brcs	.+6      	; 0x2290 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    228a:	81 e0       	ldi	r24, 0x01	; 1
    228c:	89 83       	std	Y+1, r24	; 0x01
    228e:	01 c0       	rjmp	.+2      	; 0x2292 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2290:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2292:	89 81       	ldd	r24, Y+1	; 0x01
}
    2294:	0f 90       	pop	r0
    2296:	0f 90       	pop	r0
    2298:	0f 90       	pop	r0
    229a:	0f 90       	pop	r0
    229c:	0f 90       	pop	r0
    229e:	cf 91       	pop	r28
    22a0:	df 91       	pop	r29
    22a2:	08 95       	ret

000022a4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    22a4:	df 93       	push	r29
    22a6:	cf 93       	push	r28
    22a8:	00 d0       	rcall	.+0      	; 0x22aa <vTaskSetTimeOutState+0x6>
    22aa:	cd b7       	in	r28, 0x3d	; 61
    22ac:	de b7       	in	r29, 0x3e	; 62
    22ae:	9a 83       	std	Y+2, r25	; 0x02
    22b0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    22b2:	80 91 08 03 	lds	r24, 0x0308
    22b6:	e9 81       	ldd	r30, Y+1	; 0x01
    22b8:	fa 81       	ldd	r31, Y+2	; 0x02
    22ba:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    22bc:	80 91 00 03 	lds	r24, 0x0300
    22c0:	90 91 01 03 	lds	r25, 0x0301
    22c4:	e9 81       	ldd	r30, Y+1	; 0x01
    22c6:	fa 81       	ldd	r31, Y+2	; 0x02
    22c8:	92 83       	std	Z+2, r25	; 0x02
    22ca:	81 83       	std	Z+1, r24	; 0x01
}
    22cc:	0f 90       	pop	r0
    22ce:	0f 90       	pop	r0
    22d0:	cf 91       	pop	r28
    22d2:	df 91       	pop	r29
    22d4:	08 95       	ret

000022d6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    22d6:	df 93       	push	r29
    22d8:	cf 93       	push	r28
    22da:	00 d0       	rcall	.+0      	; 0x22dc <xTaskCheckForTimeOut+0x6>
    22dc:	00 d0       	rcall	.+0      	; 0x22de <xTaskCheckForTimeOut+0x8>
    22de:	0f 92       	push	r0
    22e0:	cd b7       	in	r28, 0x3d	; 61
    22e2:	de b7       	in	r29, 0x3e	; 62
    22e4:	9b 83       	std	Y+3, r25	; 0x03
    22e6:	8a 83       	std	Y+2, r24	; 0x02
    22e8:	7d 83       	std	Y+5, r23	; 0x05
    22ea:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    22ec:	0f b6       	in	r0, 0x3f	; 63
    22ee:	f8 94       	cli
    22f0:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    22f2:	ea 81       	ldd	r30, Y+2	; 0x02
    22f4:	fb 81       	ldd	r31, Y+3	; 0x03
    22f6:	90 81       	ld	r25, Z
    22f8:	80 91 08 03 	lds	r24, 0x0308
    22fc:	98 17       	cp	r25, r24
    22fe:	71 f0       	breq	.+28     	; 0x231c <xTaskCheckForTimeOut+0x46>
    2300:	ea 81       	ldd	r30, Y+2	; 0x02
    2302:	fb 81       	ldd	r31, Y+3	; 0x03
    2304:	21 81       	ldd	r18, Z+1	; 0x01
    2306:	32 81       	ldd	r19, Z+2	; 0x02
    2308:	80 91 00 03 	lds	r24, 0x0300
    230c:	90 91 01 03 	lds	r25, 0x0301
    2310:	82 17       	cp	r24, r18
    2312:	93 07       	cpc	r25, r19
    2314:	18 f0       	brcs	.+6      	; 0x231c <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	89 83       	std	Y+1, r24	; 0x01
    231a:	2f c0       	rjmp	.+94     	; 0x237a <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    231c:	20 91 00 03 	lds	r18, 0x0300
    2320:	30 91 01 03 	lds	r19, 0x0301
    2324:	ea 81       	ldd	r30, Y+2	; 0x02
    2326:	fb 81       	ldd	r31, Y+3	; 0x03
    2328:	81 81       	ldd	r24, Z+1	; 0x01
    232a:	92 81       	ldd	r25, Z+2	; 0x02
    232c:	28 1b       	sub	r18, r24
    232e:	39 0b       	sbc	r19, r25
    2330:	ec 81       	ldd	r30, Y+4	; 0x04
    2332:	fd 81       	ldd	r31, Y+5	; 0x05
    2334:	80 81       	ld	r24, Z
    2336:	91 81       	ldd	r25, Z+1	; 0x01
    2338:	28 17       	cp	r18, r24
    233a:	39 07       	cpc	r19, r25
    233c:	e0 f4       	brcc	.+56     	; 0x2376 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    233e:	ec 81       	ldd	r30, Y+4	; 0x04
    2340:	fd 81       	ldd	r31, Y+5	; 0x05
    2342:	40 81       	ld	r20, Z
    2344:	51 81       	ldd	r21, Z+1	; 0x01
    2346:	ea 81       	ldd	r30, Y+2	; 0x02
    2348:	fb 81       	ldd	r31, Y+3	; 0x03
    234a:	21 81       	ldd	r18, Z+1	; 0x01
    234c:	32 81       	ldd	r19, Z+2	; 0x02
    234e:	80 91 00 03 	lds	r24, 0x0300
    2352:	90 91 01 03 	lds	r25, 0x0301
    2356:	b9 01       	movw	r22, r18
    2358:	68 1b       	sub	r22, r24
    235a:	79 0b       	sbc	r23, r25
    235c:	cb 01       	movw	r24, r22
    235e:	84 0f       	add	r24, r20
    2360:	95 1f       	adc	r25, r21
    2362:	ec 81       	ldd	r30, Y+4	; 0x04
    2364:	fd 81       	ldd	r31, Y+5	; 0x05
    2366:	91 83       	std	Z+1, r25	; 0x01
    2368:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    236a:	8a 81       	ldd	r24, Y+2	; 0x02
    236c:	9b 81       	ldd	r25, Y+3	; 0x03
    236e:	0e 94 52 11 	call	0x22a4	; 0x22a4 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2372:	19 82       	std	Y+1, r1	; 0x01
    2374:	02 c0       	rjmp	.+4      	; 0x237a <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2376:	81 e0       	ldi	r24, 0x01	; 1
    2378:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    237a:	0f 90       	pop	r0
    237c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    237e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2380:	0f 90       	pop	r0
    2382:	0f 90       	pop	r0
    2384:	0f 90       	pop	r0
    2386:	0f 90       	pop	r0
    2388:	0f 90       	pop	r0
    238a:	cf 91       	pop	r28
    238c:	df 91       	pop	r29
    238e:	08 95       	ret

00002390 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2390:	df 93       	push	r29
    2392:	cf 93       	push	r28
    2394:	cd b7       	in	r28, 0x3d	; 61
    2396:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2398:	81 e0       	ldi	r24, 0x01	; 1
    239a:	80 93 07 03 	sts	0x0307, r24
}
    239e:	cf 91       	pop	r28
    23a0:	df 91       	pop	r29
    23a2:	08 95       	ret

000023a4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    23a4:	df 93       	push	r29
    23a6:	cf 93       	push	r28
    23a8:	00 d0       	rcall	.+0      	; 0x23aa <prvIdleTask+0x6>
    23aa:	cd b7       	in	r28, 0x3d	; 61
    23ac:	de b7       	in	r29, 0x3e	; 62
    23ae:	9a 83       	std	Y+2, r25	; 0x02
    23b0:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    23b2:	0e 94 70 12 	call	0x24e0	; 0x24e0 <prvCheckTasksWaitingTermination>
    23b6:	fd cf       	rjmp	.-6      	; 0x23b2 <prvIdleTask+0xe>

000023b8 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    23b8:	0f 93       	push	r16
    23ba:	1f 93       	push	r17
    23bc:	df 93       	push	r29
    23be:	cf 93       	push	r28
    23c0:	cd b7       	in	r28, 0x3d	; 61
    23c2:	de b7       	in	r29, 0x3e	; 62
    23c4:	29 97       	sbiw	r28, 0x09	; 9
    23c6:	0f b6       	in	r0, 0x3f	; 63
    23c8:	f8 94       	cli
    23ca:	de bf       	out	0x3e, r29	; 62
    23cc:	0f be       	out	0x3f, r0	; 63
    23ce:	cd bf       	out	0x3d, r28	; 61
    23d0:	9a 83       	std	Y+2, r25	; 0x02
    23d2:	89 83       	std	Y+1, r24	; 0x01
    23d4:	7c 83       	std	Y+4, r23	; 0x04
    23d6:	6b 83       	std	Y+3, r22	; 0x03
    23d8:	4d 83       	std	Y+5, r20	; 0x05
    23da:	3f 83       	std	Y+7, r19	; 0x07
    23dc:	2e 83       	std	Y+6, r18	; 0x06
    23de:	19 87       	std	Y+9, r17	; 0x09
    23e0:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    23e2:	89 81       	ldd	r24, Y+1	; 0x01
    23e4:	9a 81       	ldd	r25, Y+2	; 0x02
    23e6:	49 96       	adiw	r24, 0x19	; 25
    23e8:	2b 81       	ldd	r18, Y+3	; 0x03
    23ea:	3c 81       	ldd	r19, Y+4	; 0x04
    23ec:	b9 01       	movw	r22, r18
    23ee:	48 e0       	ldi	r20, 0x08	; 8
    23f0:	50 e0       	ldi	r21, 0x00	; 0
    23f2:	0e 94 6d 13 	call	0x26da	; 0x26da <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    23f6:	e9 81       	ldd	r30, Y+1	; 0x01
    23f8:	fa 81       	ldd	r31, Y+2	; 0x02
    23fa:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    23fc:	8d 81       	ldd	r24, Y+5	; 0x05
    23fe:	85 30       	cpi	r24, 0x05	; 5
    2400:	10 f0       	brcs	.+4      	; 0x2406 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2402:	84 e0       	ldi	r24, 0x04	; 4
    2404:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2406:	e9 81       	ldd	r30, Y+1	; 0x01
    2408:	fa 81       	ldd	r31, Y+2	; 0x02
    240a:	8d 81       	ldd	r24, Y+5	; 0x05
    240c:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    240e:	89 81       	ldd	r24, Y+1	; 0x01
    2410:	9a 81       	ldd	r25, Y+2	; 0x02
    2412:	02 96       	adiw	r24, 0x02	; 2
    2414:	0e 94 0d 04 	call	0x81a	; 0x81a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2418:	89 81       	ldd	r24, Y+1	; 0x01
    241a:	9a 81       	ldd	r25, Y+2	; 0x02
    241c:	0c 96       	adiw	r24, 0x0c	; 12
    241e:	0e 94 0d 04 	call	0x81a	; 0x81a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2422:	e9 81       	ldd	r30, Y+1	; 0x01
    2424:	fa 81       	ldd	r31, Y+2	; 0x02
    2426:	89 81       	ldd	r24, Y+1	; 0x01
    2428:	9a 81       	ldd	r25, Y+2	; 0x02
    242a:	91 87       	std	Z+9, r25	; 0x09
    242c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    242e:	8d 81       	ldd	r24, Y+5	; 0x05
    2430:	28 2f       	mov	r18, r24
    2432:	30 e0       	ldi	r19, 0x00	; 0
    2434:	85 e0       	ldi	r24, 0x05	; 5
    2436:	90 e0       	ldi	r25, 0x00	; 0
    2438:	82 1b       	sub	r24, r18
    243a:	93 0b       	sbc	r25, r19
    243c:	e9 81       	ldd	r30, Y+1	; 0x01
    243e:	fa 81       	ldd	r31, Y+2	; 0x02
    2440:	95 87       	std	Z+13, r25	; 0x0d
    2442:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2444:	e9 81       	ldd	r30, Y+1	; 0x01
    2446:	fa 81       	ldd	r31, Y+2	; 0x02
    2448:	89 81       	ldd	r24, Y+1	; 0x01
    244a:	9a 81       	ldd	r25, Y+2	; 0x02
    244c:	93 8b       	std	Z+19, r25	; 0x13
    244e:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2450:	29 96       	adiw	r28, 0x09	; 9
    2452:	0f b6       	in	r0, 0x3f	; 63
    2454:	f8 94       	cli
    2456:	de bf       	out	0x3e, r29	; 62
    2458:	0f be       	out	0x3f, r0	; 63
    245a:	cd bf       	out	0x3d, r28	; 61
    245c:	cf 91       	pop	r28
    245e:	df 91       	pop	r29
    2460:	1f 91       	pop	r17
    2462:	0f 91       	pop	r16
    2464:	08 95       	ret

00002466 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2466:	df 93       	push	r29
    2468:	cf 93       	push	r28
    246a:	0f 92       	push	r0
    246c:	cd b7       	in	r28, 0x3d	; 61
    246e:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2470:	19 82       	std	Y+1, r1	; 0x01
    2472:	13 c0       	rjmp	.+38     	; 0x249a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2474:	89 81       	ldd	r24, Y+1	; 0x01
    2476:	28 2f       	mov	r18, r24
    2478:	30 e0       	ldi	r19, 0x00	; 0
    247a:	c9 01       	movw	r24, r18
    247c:	88 0f       	add	r24, r24
    247e:	99 1f       	adc	r25, r25
    2480:	88 0f       	add	r24, r24
    2482:	99 1f       	adc	r25, r25
    2484:	88 0f       	add	r24, r24
    2486:	99 1f       	adc	r25, r25
    2488:	82 0f       	add	r24, r18
    248a:	93 1f       	adc	r25, r19
    248c:	86 5f       	subi	r24, 0xF6	; 246
    248e:	9c 4f       	sbci	r25, 0xFC	; 252
    2490:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2494:	89 81       	ldd	r24, Y+1	; 0x01
    2496:	8f 5f       	subi	r24, 0xFF	; 255
    2498:	89 83       	std	Y+1, r24	; 0x01
    249a:	89 81       	ldd	r24, Y+1	; 0x01
    249c:	85 30       	cpi	r24, 0x05	; 5
    249e:	50 f3       	brcs	.-44     	; 0x2474 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    24a0:	87 e3       	ldi	r24, 0x37	; 55
    24a2:	93 e0       	ldi	r25, 0x03	; 3
    24a4:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    24a8:	80 e4       	ldi	r24, 0x40	; 64
    24aa:	93 e0       	ldi	r25, 0x03	; 3
    24ac:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    24b0:	8d e4       	ldi	r24, 0x4D	; 77
    24b2:	93 e0       	ldi	r25, 0x03	; 3
    24b4:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    24b8:	86 e5       	ldi	r24, 0x56	; 86
    24ba:	93 e0       	ldi	r25, 0x03	; 3
    24bc:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    24c0:	87 e3       	ldi	r24, 0x37	; 55
    24c2:	93 e0       	ldi	r25, 0x03	; 3
    24c4:	90 93 4a 03 	sts	0x034A, r25
    24c8:	80 93 49 03 	sts	0x0349, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    24cc:	80 e4       	ldi	r24, 0x40	; 64
    24ce:	93 e0       	ldi	r25, 0x03	; 3
    24d0:	90 93 4c 03 	sts	0x034C, r25
    24d4:	80 93 4b 03 	sts	0x034B, r24
}
    24d8:	0f 90       	pop	r0
    24da:	cf 91       	pop	r28
    24dc:	df 91       	pop	r29
    24de:	08 95       	ret

000024e0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    24e0:	df 93       	push	r29
    24e2:	cf 93       	push	r28
    24e4:	00 d0       	rcall	.+0      	; 0x24e6 <prvCheckTasksWaitingTermination+0x6>
    24e6:	0f 92       	push	r0
    24e8:	cd b7       	in	r28, 0x3d	; 61
    24ea:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    24ec:	80 91 fe 02 	lds	r24, 0x02FE
    24f0:	88 23       	and	r24, r24
    24f2:	71 f1       	breq	.+92     	; 0x2550 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    24f4:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    24f8:	80 91 56 03 	lds	r24, 0x0356
    24fc:	1b 82       	std	Y+3, r1	; 0x03
    24fe:	88 23       	and	r24, r24
    2500:	11 f4       	brne	.+4      	; 0x2506 <prvCheckTasksWaitingTermination+0x26>
    2502:	81 e0       	ldi	r24, 0x01	; 1
    2504:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2506:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    250a:	8b 81       	ldd	r24, Y+3	; 0x03
    250c:	88 23       	and	r24, r24
    250e:	01 f5       	brne	.+64     	; 0x2550 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2510:	0f b6       	in	r0, 0x3f	; 63
    2512:	f8 94       	cli
    2514:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2516:	e0 91 5b 03 	lds	r30, 0x035B
    251a:	f0 91 5c 03 	lds	r31, 0x035C
    251e:	86 81       	ldd	r24, Z+6	; 0x06
    2520:	97 81       	ldd	r25, Z+7	; 0x07
    2522:	9a 83       	std	Y+2, r25	; 0x02
    2524:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2526:	89 81       	ldd	r24, Y+1	; 0x01
    2528:	9a 81       	ldd	r25, Y+2	; 0x02
    252a:	02 96       	adiw	r24, 0x02	; 2
    252c:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListRemove>
					--uxCurrentNumberOfTasks;
    2530:	80 91 ff 02 	lds	r24, 0x02FF
    2534:	81 50       	subi	r24, 0x01	; 1
    2536:	80 93 ff 02 	sts	0x02FF, r24
					--uxTasksDeleted;
    253a:	80 91 fe 02 	lds	r24, 0x02FE
    253e:	81 50       	subi	r24, 0x01	; 1
    2540:	80 93 fe 02 	sts	0x02FE, r24
				}
				taskEXIT_CRITICAL();
    2544:	0f 90       	pop	r0
    2546:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2548:	89 81       	ldd	r24, Y+1	; 0x01
    254a:	9a 81       	ldd	r25, Y+2	; 0x02
    254c:	0e 94 47 13 	call	0x268e	; 0x268e <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2550:	0f 90       	pop	r0
    2552:	0f 90       	pop	r0
    2554:	0f 90       	pop	r0
    2556:	cf 91       	pop	r28
    2558:	df 91       	pop	r29
    255a:	08 95       	ret

0000255c <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    255c:	df 93       	push	r29
    255e:	cf 93       	push	r28
    2560:	00 d0       	rcall	.+0      	; 0x2562 <prvAddCurrentTaskToDelayedList+0x6>
    2562:	cd b7       	in	r28, 0x3d	; 61
    2564:	de b7       	in	r29, 0x3e	; 62
    2566:	9a 83       	std	Y+2, r25	; 0x02
    2568:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    256a:	e0 91 fc 02 	lds	r30, 0x02FC
    256e:	f0 91 fd 02 	lds	r31, 0x02FD
    2572:	89 81       	ldd	r24, Y+1	; 0x01
    2574:	9a 81       	ldd	r25, Y+2	; 0x02
    2576:	93 83       	std	Z+3, r25	; 0x03
    2578:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    257a:	20 91 00 03 	lds	r18, 0x0300
    257e:	30 91 01 03 	lds	r19, 0x0301
    2582:	89 81       	ldd	r24, Y+1	; 0x01
    2584:	9a 81       	ldd	r25, Y+2	; 0x02
    2586:	82 17       	cp	r24, r18
    2588:	93 07       	cpc	r25, r19
    258a:	70 f4       	brcc	.+28     	; 0x25a8 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    258c:	80 91 4b 03 	lds	r24, 0x034B
    2590:	90 91 4c 03 	lds	r25, 0x034C
    2594:	20 91 fc 02 	lds	r18, 0x02FC
    2598:	30 91 fd 02 	lds	r19, 0x02FD
    259c:	2e 5f       	subi	r18, 0xFE	; 254
    259e:	3f 4f       	sbci	r19, 0xFF	; 255
    25a0:	b9 01       	movw	r22, r18
    25a2:	0e 94 69 04 	call	0x8d2	; 0x8d2 <vListInsert>
    25a6:	1e c0       	rjmp	.+60     	; 0x25e4 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25a8:	40 91 49 03 	lds	r20, 0x0349
    25ac:	50 91 4a 03 	lds	r21, 0x034A
    25b0:	80 91 fc 02 	lds	r24, 0x02FC
    25b4:	90 91 fd 02 	lds	r25, 0x02FD
    25b8:	9c 01       	movw	r18, r24
    25ba:	2e 5f       	subi	r18, 0xFE	; 254
    25bc:	3f 4f       	sbci	r19, 0xFF	; 255
    25be:	ca 01       	movw	r24, r20
    25c0:	b9 01       	movw	r22, r18
    25c2:	0e 94 69 04 	call	0x8d2	; 0x8d2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    25c6:	20 91 65 00 	lds	r18, 0x0065
    25ca:	30 91 66 00 	lds	r19, 0x0066
    25ce:	89 81       	ldd	r24, Y+1	; 0x01
    25d0:	9a 81       	ldd	r25, Y+2	; 0x02
    25d2:	82 17       	cp	r24, r18
    25d4:	93 07       	cpc	r25, r19
    25d6:	30 f4       	brcc	.+12     	; 0x25e4 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    25d8:	89 81       	ldd	r24, Y+1	; 0x01
    25da:	9a 81       	ldd	r25, Y+2	; 0x02
    25dc:	90 93 66 00 	sts	0x0066, r25
    25e0:	80 93 65 00 	sts	0x0065, r24
		}
	}
}
    25e4:	0f 90       	pop	r0
    25e6:	0f 90       	pop	r0
    25e8:	cf 91       	pop	r28
    25ea:	df 91       	pop	r29
    25ec:	08 95       	ret

000025ee <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    25ee:	df 93       	push	r29
    25f0:	cf 93       	push	r28
    25f2:	cd b7       	in	r28, 0x3d	; 61
    25f4:	de b7       	in	r29, 0x3e	; 62
    25f6:	28 97       	sbiw	r28, 0x08	; 8
    25f8:	0f b6       	in	r0, 0x3f	; 63
    25fa:	f8 94       	cli
    25fc:	de bf       	out	0x3e, r29	; 62
    25fe:	0f be       	out	0x3f, r0	; 63
    2600:	cd bf       	out	0x3d, r28	; 61
    2602:	9c 83       	std	Y+4, r25	; 0x04
    2604:	8b 83       	std	Y+3, r24	; 0x03
    2606:	7e 83       	std	Y+6, r23	; 0x06
    2608:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    260a:	81 e2       	ldi	r24, 0x21	; 33
    260c:	90 e0       	ldi	r25, 0x00	; 0
    260e:	0e 94 77 03 	call	0x6ee	; 0x6ee <pvPortMalloc>
    2612:	9a 83       	std	Y+2, r25	; 0x02
    2614:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2616:	89 81       	ldd	r24, Y+1	; 0x01
    2618:	9a 81       	ldd	r25, Y+2	; 0x02
    261a:	00 97       	sbiw	r24, 0x00	; 0
    261c:	69 f1       	breq	.+90     	; 0x2678 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    261e:	8d 81       	ldd	r24, Y+5	; 0x05
    2620:	9e 81       	ldd	r25, Y+6	; 0x06
    2622:	00 97       	sbiw	r24, 0x00	; 0
    2624:	39 f4       	brne	.+14     	; 0x2634 <prvAllocateTCBAndStack+0x46>
    2626:	8b 81       	ldd	r24, Y+3	; 0x03
    2628:	9c 81       	ldd	r25, Y+4	; 0x04
    262a:	0e 94 77 03 	call	0x6ee	; 0x6ee <pvPortMalloc>
    262e:	98 87       	std	Y+8, r25	; 0x08
    2630:	8f 83       	std	Y+7, r24	; 0x07
    2632:	04 c0       	rjmp	.+8      	; 0x263c <prvAllocateTCBAndStack+0x4e>
    2634:	8d 81       	ldd	r24, Y+5	; 0x05
    2636:	9e 81       	ldd	r25, Y+6	; 0x06
    2638:	98 87       	std	Y+8, r25	; 0x08
    263a:	8f 83       	std	Y+7, r24	; 0x07
    263c:	e9 81       	ldd	r30, Y+1	; 0x01
    263e:	fa 81       	ldd	r31, Y+2	; 0x02
    2640:	8f 81       	ldd	r24, Y+7	; 0x07
    2642:	98 85       	ldd	r25, Y+8	; 0x08
    2644:	90 8f       	std	Z+24, r25	; 0x18
    2646:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2648:	e9 81       	ldd	r30, Y+1	; 0x01
    264a:	fa 81       	ldd	r31, Y+2	; 0x02
    264c:	87 89       	ldd	r24, Z+23	; 0x17
    264e:	90 8d       	ldd	r25, Z+24	; 0x18
    2650:	00 97       	sbiw	r24, 0x00	; 0
    2652:	39 f4       	brne	.+14     	; 0x2662 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2654:	89 81       	ldd	r24, Y+1	; 0x01
    2656:	9a 81       	ldd	r25, Y+2	; 0x02
    2658:	0e 94 bd 03 	call	0x77a	; 0x77a <vPortFree>
			pxNewTCB = NULL;
    265c:	1a 82       	std	Y+2, r1	; 0x02
    265e:	19 82       	std	Y+1, r1	; 0x01
    2660:	0b c0       	rjmp	.+22     	; 0x2678 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2662:	e9 81       	ldd	r30, Y+1	; 0x01
    2664:	fa 81       	ldd	r31, Y+2	; 0x02
    2666:	87 89       	ldd	r24, Z+23	; 0x17
    2668:	90 8d       	ldd	r25, Z+24	; 0x18
    266a:	2b 81       	ldd	r18, Y+3	; 0x03
    266c:	3c 81       	ldd	r19, Y+4	; 0x04
    266e:	65 ea       	ldi	r22, 0xA5	; 165
    2670:	70 e0       	ldi	r23, 0x00	; 0
    2672:	a9 01       	movw	r20, r18
    2674:	0e 94 66 13 	call	0x26cc	; 0x26cc <memset>
		}
	}

	return pxNewTCB;
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    267c:	28 96       	adiw	r28, 0x08	; 8
    267e:	0f b6       	in	r0, 0x3f	; 63
    2680:	f8 94       	cli
    2682:	de bf       	out	0x3e, r29	; 62
    2684:	0f be       	out	0x3f, r0	; 63
    2686:	cd bf       	out	0x3d, r28	; 61
    2688:	cf 91       	pop	r28
    268a:	df 91       	pop	r29
    268c:	08 95       	ret

0000268e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    268e:	df 93       	push	r29
    2690:	cf 93       	push	r28
    2692:	00 d0       	rcall	.+0      	; 0x2694 <prvDeleteTCB+0x6>
    2694:	cd b7       	in	r28, 0x3d	; 61
    2696:	de b7       	in	r29, 0x3e	; 62
    2698:	9a 83       	std	Y+2, r25	; 0x02
    269a:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    269c:	e9 81       	ldd	r30, Y+1	; 0x01
    269e:	fa 81       	ldd	r31, Y+2	; 0x02
    26a0:	87 89       	ldd	r24, Z+23	; 0x17
    26a2:	90 8d       	ldd	r25, Z+24	; 0x18
    26a4:	0e 94 bd 03 	call	0x77a	; 0x77a <vPortFree>
		vPortFree( pxTCB );
    26a8:	89 81       	ldd	r24, Y+1	; 0x01
    26aa:	9a 81       	ldd	r25, Y+2	; 0x02
    26ac:	0e 94 bd 03 	call	0x77a	; 0x77a <vPortFree>
	}
    26b0:	0f 90       	pop	r0
    26b2:	0f 90       	pop	r0
    26b4:	cf 91       	pop	r28
    26b6:	df 91       	pop	r29
    26b8:	08 95       	ret

000026ba <memcpy>:
    26ba:	fb 01       	movw	r30, r22
    26bc:	dc 01       	movw	r26, r24
    26be:	02 c0       	rjmp	.+4      	; 0x26c4 <memcpy+0xa>
    26c0:	01 90       	ld	r0, Z+
    26c2:	0d 92       	st	X+, r0
    26c4:	41 50       	subi	r20, 0x01	; 1
    26c6:	50 40       	sbci	r21, 0x00	; 0
    26c8:	d8 f7       	brcc	.-10     	; 0x26c0 <memcpy+0x6>
    26ca:	08 95       	ret

000026cc <memset>:
    26cc:	dc 01       	movw	r26, r24
    26ce:	01 c0       	rjmp	.+2      	; 0x26d2 <memset+0x6>
    26d0:	6d 93       	st	X+, r22
    26d2:	41 50       	subi	r20, 0x01	; 1
    26d4:	50 40       	sbci	r21, 0x00	; 0
    26d6:	e0 f7       	brcc	.-8      	; 0x26d0 <memset+0x4>
    26d8:	08 95       	ret

000026da <strncpy>:
    26da:	fb 01       	movw	r30, r22
    26dc:	dc 01       	movw	r26, r24
    26de:	41 50       	subi	r20, 0x01	; 1
    26e0:	50 40       	sbci	r21, 0x00	; 0
    26e2:	48 f0       	brcs	.+18     	; 0x26f6 <strncpy+0x1c>
    26e4:	01 90       	ld	r0, Z+
    26e6:	0d 92       	st	X+, r0
    26e8:	00 20       	and	r0, r0
    26ea:	c9 f7       	brne	.-14     	; 0x26de <strncpy+0x4>
    26ec:	01 c0       	rjmp	.+2      	; 0x26f0 <strncpy+0x16>
    26ee:	1d 92       	st	X+, r1
    26f0:	41 50       	subi	r20, 0x01	; 1
    26f2:	50 40       	sbci	r21, 0x00	; 0
    26f4:	e0 f7       	brcc	.-8      	; 0x26ee <strncpy+0x14>
    26f6:	08 95       	ret

000026f8 <_exit>:
    26f8:	f8 94       	cli

000026fa <__stop_program>:
    26fa:	ff cf       	rjmp	.-2      	; 0x26fa <__stop_program>
